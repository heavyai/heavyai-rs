// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(clippy::too_many_arguments, clippy::type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::common;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TResultSetLayout {
  GroupByPerfectHash = 0,
  GroupByBaselineHash = 1,
  Projection = 2,
  NonGroupedAggregate = 3,
}

impl TResultSetLayout {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TResultSetLayout> {
    let enum_value = i_prot.read_i32()?;
    TResultSetLayout::try_from(enum_value)  }
}

impl TryFrom<i32> for TResultSetLayout {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TResultSetLayout::GroupByPerfectHash),
      1 => Ok(TResultSetLayout::GroupByBaselineHash),
      2 => Ok(TResultSetLayout::Projection),
      3 => Ok(TResultSetLayout::NonGroupedAggregate),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TResultSetLayout", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TCountDistinctImplType {
  Invalid = 0,
  Bitmap = 1,
  StdSet = 2,
}

impl TCountDistinctImplType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCountDistinctImplType> {
    let enum_value = i_prot.read_i32()?;
    TCountDistinctImplType::try_from(enum_value)  }
}

impl TryFrom<i32> for TCountDistinctImplType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TCountDistinctImplType::Invalid),
      1 => Ok(TCountDistinctImplType::Bitmap),
      2 => Ok(TCountDistinctImplType::StdSet),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TCountDistinctImplType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TAggKind {
  Avg = 0,
  Min = 1,
  Max = 2,
  Sum = 3,
  Count = 4,
  ApproxCountDistinct = 5,
  Sample = 6,
}

impl TAggKind {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggKind> {
    let enum_value = i_prot.read_i32()?;
    TAggKind::try_from(enum_value)  }
}

impl TryFrom<i32> for TAggKind {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TAggKind::Avg),
      1 => Ok(TAggKind::Min),
      2 => Ok(TAggKind::Max),
      3 => Ok(TAggKind::Sum),
      4 => Ok(TAggKind::Count),
      5 => Ok(TAggKind::ApproxCountDistinct),
      6 => Ok(TAggKind::Sample),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TAggKind", i)
            )
          )
        )
      },
    }
  }
}

pub type TCountDistinctDescriptors = Vec<TCountDistinctDescriptor>;

//
// TSlotSize
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSlotSize {
  pub padded: Option<i16>,
  pub logical: Option<i16>,
}

impl TSlotSize {
  pub fn new<F1, F2>(padded: F1, logical: F2) -> TSlotSize where F1: Into<Option<i16>>, F2: Into<Option<i16>> {
    TSlotSize {
      padded: padded.into(),
      logical: logical.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSlotSize> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i16> = Some(0);
    let mut f_2: Option<i16> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i16()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSlotSize {
      padded: f_1,
      logical: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSlotSize");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.padded {
      o_prot.write_field_begin(&TFieldIdentifier::new("padded", TType::I16, 1))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.logical {
      o_prot.write_field_begin(&TFieldIdentifier::new("logical", TType::I16, 2))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSlotSize {
  fn default() -> Self {
    TSlotSize{
      padded: Some(0),
      logical: Some(0),
    }
  }
}

//
// TColSlotContext
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColSlotContext {
  pub slot_sizes: Option<Vec<TSlotSize>>,
  pub col_to_slot_map: Option<Vec<Vec<i32>>>,
}

impl TColSlotContext {
  pub fn new<F1, F2>(slot_sizes: F1, col_to_slot_map: F2) -> TColSlotContext where F1: Into<Option<Vec<TSlotSize>>>, F2: Into<Option<Vec<Vec<i32>>>> {
    TColSlotContext {
      slot_sizes: slot_sizes.into(),
      col_to_slot_map: col_to_slot_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColSlotContext> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TSlotSize>> = Some(Vec::new());
    let mut f_2: Option<Vec<Vec<i32>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TSlotSize> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = TSlotSize::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_1: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_2 = i_prot.read_i32()?;
              list_elem_1.push(list_elem_2);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColSlotContext {
      slot_sizes: f_1,
      col_to_slot_map: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColSlotContext");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.slot_sizes {
      o_prot.write_field_begin(&TFieldIdentifier::new("slot_sizes", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_to_slot_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_to_slot_map", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
        for e in e {
          o_prot.write_i32(*e)?;
          o_prot.write_list_end()?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColSlotContext {
  fn default() -> Self {
    TColSlotContext{
      slot_sizes: Some(Vec::new()),
      col_to_slot_map: Some(Vec::new()),
    }
  }
}

//
// TCountDistinctDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCountDistinctDescriptor {
  pub impl_type: Option<TCountDistinctImplType>,
  pub min_val: Option<i64>,
  pub bitmap_sz_bits: Option<i64>,
  pub approximate: Option<bool>,
  pub device_type: Option<common::TDeviceType>,
  pub sub_bitmap_count: Option<i64>,
}

impl TCountDistinctDescriptor {
  pub fn new<F1, F2, F3, F4, F5, F6>(impl_type: F1, min_val: F2, bitmap_sz_bits: F3, approximate: F4, device_type: F5, sub_bitmap_count: F6) -> TCountDistinctDescriptor where F1: Into<Option<TCountDistinctImplType>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<common::TDeviceType>>, F6: Into<Option<i64>> {
    TCountDistinctDescriptor {
      impl_type: impl_type.into(),
      min_val: min_val.into(),
      bitmap_sz_bits: bitmap_sz_bits.into(),
      approximate: approximate.into(),
      device_type: device_type.into(),
      sub_bitmap_count: sub_bitmap_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCountDistinctDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TCountDistinctImplType> = None;
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<common::TDeviceType> = None;
    let mut f_6: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TCountDistinctImplType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCountDistinctDescriptor {
      impl_type: f_1,
      min_val: f_2,
      bitmap_sz_bits: f_3,
      approximate: f_4,
      device_type: f_5,
      sub_bitmap_count: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCountDistinctDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.impl_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("impl_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.min_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_val", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.bitmap_sz_bits {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitmap_sz_bits", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.approximate {
      o_prot.write_field_begin(&TFieldIdentifier::new("approximate", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.device_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sub_bitmap_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("sub_bitmap_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCountDistinctDescriptor {
  fn default() -> Self {
    TCountDistinctDescriptor{
      impl_type: None,
      min_val: Some(0),
      bitmap_sz_bits: Some(0),
      approximate: Some(false),
      device_type: None,
      sub_bitmap_count: Some(0),
    }
  }
}

//
// TResultSetBufferDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TResultSetBufferDescriptor {
  pub layout: Option<TResultSetLayout>,
  pub keyless: Option<bool>,
  pub entry_count: Option<i32>,
  pub idx_target_as_key: Option<i32>,
  pub min_val: Option<i64>,
  pub max_val: Option<i64>,
  pub bucket: Option<i64>,
  pub group_col_widths: Option<Vec<i16>>,
  pub key_bytewidth: Option<i16>,
  pub col_slot_context: Option<TColSlotContext>,
  pub target_groupby_indices: Option<Vec<i32>>,
  pub count_distinct_descriptors: Option<TCountDistinctDescriptors>,
  pub force_4byte_float: Option<bool>,
}

impl TResultSetBufferDescriptor {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13>(layout: F1, keyless: F2, entry_count: F3, idx_target_as_key: F4, min_val: F5, max_val: F6, bucket: F7, group_col_widths: F8, key_bytewidth: F9, col_slot_context: F10, target_groupby_indices: F11, count_distinct_descriptors: F12, force_4byte_float: F13) -> TResultSetBufferDescriptor where F1: Into<Option<TResultSetLayout>>, F2: Into<Option<bool>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<Vec<i16>>>, F9: Into<Option<i16>>, F10: Into<Option<TColSlotContext>>, F11: Into<Option<Vec<i32>>>, F12: Into<Option<TCountDistinctDescriptors>>, F13: Into<Option<bool>> {
    TResultSetBufferDescriptor {
      layout: layout.into(),
      keyless: keyless.into(),
      entry_count: entry_count.into(),
      idx_target_as_key: idx_target_as_key.into(),
      min_val: min_val.into(),
      max_val: max_val.into(),
      bucket: bucket.into(),
      group_col_widths: group_col_widths.into(),
      key_bytewidth: key_bytewidth.into(),
      col_slot_context: col_slot_context.into(),
      target_groupby_indices: target_groupby_indices.into(),
      count_distinct_descriptors: count_distinct_descriptors.into(),
      force_4byte_float: force_4byte_float.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TResultSetBufferDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TResultSetLayout> = None;
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<Vec<i16>> = Some(Vec::new());
    let mut f_9: Option<i16> = Some(0);
    let mut f_10: Option<TColSlotContext> = None;
    let mut f_11: Option<Vec<i32>> = Some(Vec::new());
    let mut f_12: Option<TCountDistinctDescriptors> = Some(Vec::new());
    let mut f_13: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TResultSetLayout::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i16> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_i16()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i16()?;
          f_9 = Some(val);
        },
        10 => {
          let val = TColSlotContext::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_i32()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TCountDistinctDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = TCountDistinctDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TResultSetBufferDescriptor {
      layout: f_1,
      keyless: f_2,
      entry_count: f_3,
      idx_target_as_key: f_4,
      min_val: f_5,
      max_val: f_6,
      bucket: f_7,
      group_col_widths: f_8,
      key_bytewidth: f_9,
      col_slot_context: f_10,
      target_groupby_indices: f_11,
      count_distinct_descriptors: f_12,
      force_4byte_float: f_13,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TResultSetBufferDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.layout {
      o_prot.write_field_begin(&TFieldIdentifier::new("layout", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.keyless {
      o_prot.write_field_begin(&TFieldIdentifier::new("keyless", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.entry_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("entry_count", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.idx_target_as_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("idx_target_as_key", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.min_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_val", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_val", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.bucket {
      o_prot.write_field_begin(&TFieldIdentifier::new("bucket", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.group_col_widths {
      o_prot.write_field_begin(&TFieldIdentifier::new("group_col_widths", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I16, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i16(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.key_bytewidth {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_bytewidth", TType::I16, 9))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_slot_context {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_slot_context", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.target_groupby_indices {
      o_prot.write_field_begin(&TFieldIdentifier::new("target_groupby_indices", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.count_distinct_descriptors {
      o_prot.write_field_begin(&TFieldIdentifier::new("count_distinct_descriptors", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.force_4byte_float {
      o_prot.write_field_begin(&TFieldIdentifier::new("force_4byte_float", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TResultSetBufferDescriptor {
  fn default() -> Self {
    TResultSetBufferDescriptor{
      layout: None,
      keyless: Some(false),
      entry_count: Some(0),
      idx_target_as_key: Some(0),
      min_val: Some(0),
      max_val: Some(0),
      bucket: Some(0),
      group_col_widths: Some(Vec::new()),
      key_bytewidth: Some(0),
      col_slot_context: None,
      target_groupby_indices: Some(Vec::new()),
      count_distinct_descriptors: Some(Vec::new()),
      force_4byte_float: Some(false),
    }
  }
}

//
// TTargetInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTargetInfo {
  pub is_agg: Option<bool>,
  pub kind: Option<TAggKind>,
  pub type_: Option<common::TTypeInfo>,
  pub arg_type: Option<common::TTypeInfo>,
  pub skip_nulls: Option<bool>,
  pub is_distinct: Option<bool>,
}

impl TTargetInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(is_agg: F1, kind: F2, type_: F3, arg_type: F4, skip_nulls: F5, is_distinct: F6) -> TTargetInfo where F1: Into<Option<bool>>, F2: Into<Option<TAggKind>>, F3: Into<Option<common::TTypeInfo>>, F4: Into<Option<common::TTypeInfo>>, F5: Into<Option<bool>>, F6: Into<Option<bool>> {
    TTargetInfo {
      is_agg: is_agg.into(),
      kind: kind.into(),
      type_: type_.into(),
      arg_type: arg_type.into(),
      skip_nulls: skip_nulls.into(),
      is_distinct: is_distinct.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTargetInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<TAggKind> = None;
    let mut f_3: Option<common::TTypeInfo> = None;
    let mut f_4: Option<common::TTypeInfo> = None;
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TAggKind::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TTypeInfo::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = common::TTypeInfo::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTargetInfo {
      is_agg: f_1,
      kind: f_2,
      type_: f_3,
      arg_type: f_4,
      skip_nulls: f_5,
      is_distinct: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTargetInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_agg {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_agg", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.arg_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("arg_type", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.skip_nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_nulls", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_distinct {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_distinct", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTargetInfo {
  fn default() -> Self {
    TTargetInfo{
      is_agg: Some(false),
      kind: None,
      type_: None,
      arg_type: None,
      skip_nulls: Some(false),
      is_distinct: Some(false),
    }
  }
}

//
// TCountDistinctSetStorage
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TCountDistinctSetStorage {
  Bitmap(Vec<u8>),
  SparseSet(BTreeSet<i64>),
}

impl TCountDistinctSetStorage {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCountDistinctSetStorage> {
    let mut ret: Option<TCountDistinctSetStorage> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TCountDistinctSetStorage::Bitmap(val));
          }
          received_field_count += 1;
        },
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<i64> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_6 = i_prot.read_i64()?;
            val.insert(set_elem_6);
          }
          i_prot.read_set_end()?;
          if ret.is_none() {
            ret = Some(TCountDistinctSetStorage::SparseSet(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TCountDistinctSetStorage"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TCountDistinctSetStorage"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCountDistinctSetStorage");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TCountDistinctSetStorage::Bitmap(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("bitmap", TType::String, 1))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TCountDistinctSetStorage::SparseSet(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("sparse_set", TType::Set, 2))?;
        o_prot.write_set_begin(&TSetIdentifier::new(TType::I64, f.len() as i32))?;
        for e in f {
          o_prot.write_i64(*e)?;
          o_prot.write_set_end()?;
        }
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCountDistinctSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCountDistinctSet {
  pub type_: Option<TCountDistinctImplType>,
  pub storage: Option<TCountDistinctSetStorage>,
  pub remote_ptr: Option<i64>,
}

impl TCountDistinctSet {
  pub fn new<F1, F2, F3>(type_: F1, storage: F2, remote_ptr: F3) -> TCountDistinctSet where F1: Into<Option<TCountDistinctImplType>>, F2: Into<Option<TCountDistinctSetStorage>>, F3: Into<Option<i64>> {
    TCountDistinctSet {
      type_: type_.into(),
      storage: storage.into(),
      remote_ptr: remote_ptr.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCountDistinctSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TCountDistinctImplType> = None;
    let mut f_2: Option<TCountDistinctSetStorage> = None;
    let mut f_3: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TCountDistinctImplType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TCountDistinctSetStorage::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCountDistinctSet {
      type_: f_1,
      storage: f_2,
      remote_ptr: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCountDistinctSet");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.storage {
      o_prot.write_field_begin(&TFieldIdentifier::new("storage", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.remote_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("remote_ptr", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCountDistinctSet {
  fn default() -> Self {
    TCountDistinctSet{
      type_: None,
      storage: None,
      remote_ptr: Some(0),
    }
  }
}

//
// TSerializedRows
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSerializedRows {
  pub buffers: Option<Vec<Vec<u8>>>,
  pub buffer_lengths: Option<Vec<i64>>,
  pub buffers_total_size: Option<i64>,
  pub total_compression_time_ms: Option<i32>,
  pub descriptor: Option<TResultSetBufferDescriptor>,
  pub targets: Option<Vec<TTargetInfo>>,
  pub target_init_vals: Option<Vec<i64>>,
  pub varlen_buffer: Option<Vec<Vec<u8>>>,
  pub count_distinct_sets: Option<Vec<TCountDistinctSet>>,
  pub explanation: Option<String>,
}

impl TSerializedRows {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(buffers: F1, buffer_lengths: F2, buffers_total_size: F3, total_compression_time_ms: F4, descriptor: F5, targets: F6, target_init_vals: F7, varlen_buffer: F8, count_distinct_sets: F9, explanation: F10) -> TSerializedRows where F1: Into<Option<Vec<Vec<u8>>>>, F2: Into<Option<Vec<i64>>>, F3: Into<Option<i64>>, F4: Into<Option<i32>>, F5: Into<Option<TResultSetBufferDescriptor>>, F6: Into<Option<Vec<TTargetInfo>>>, F7: Into<Option<Vec<i64>>>, F8: Into<Option<Vec<Vec<u8>>>>, F9: Into<Option<Vec<TCountDistinctSet>>>, F10: Into<Option<String>> {
    TSerializedRows {
      buffers: buffers.into(),
      buffer_lengths: buffer_lengths.into(),
      buffers_total_size: buffers_total_size.into(),
      total_compression_time_ms: total_compression_time_ms.into(),
      descriptor: descriptor.into(),
      targets: targets.into(),
      target_init_vals: target_init_vals.into(),
      varlen_buffer: varlen_buffer.into(),
      count_distinct_sets: count_distinct_sets.into(),
      explanation: explanation.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSerializedRows> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Vec<u8>>> = Some(Vec::new());
    let mut f_2: Option<Vec<i64>> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<TResultSetBufferDescriptor> = None;
    let mut f_6: Option<Vec<TTargetInfo>> = Some(Vec::new());
    let mut f_7: Option<Vec<i64>> = Some(Vec::new());
    let mut f_8: Option<Vec<Vec<u8>>> = Some(Vec::new());
    let mut f_9: Option<Vec<TCountDistinctSet>> = Some(Vec::new());
    let mut f_10: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_bytes()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_i64()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TResultSetBufferDescriptor::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTargetInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = TTargetInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = i_prot.read_i64()?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = i_prot.read_bytes()?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TCountDistinctSet> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = TCountDistinctSet::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSerializedRows {
      buffers: f_1,
      buffer_lengths: f_2,
      buffers_total_size: f_3,
      total_compression_time_ms: f_4,
      descriptor: f_5,
      targets: f_6,
      target_init_vals: f_7,
      varlen_buffer: f_8,
      count_distinct_sets: f_9,
      explanation: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSerializedRows");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.buffers {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffers", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.buffer_lengths {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffer_lengths", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.buffers_total_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffers_total_size", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_compression_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_compression_time_ms", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.descriptor {
      o_prot.write_field_begin(&TFieldIdentifier::new("descriptor", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.targets {
      o_prot.write_field_begin(&TFieldIdentifier::new("targets", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.target_init_vals {
      o_prot.write_field_begin(&TFieldIdentifier::new("target_init_vals", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.varlen_buffer {
      o_prot.write_field_begin(&TFieldIdentifier::new("varlen_buffer", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.count_distinct_sets {
      o_prot.write_field_begin(&TFieldIdentifier::new("count_distinct_sets", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.explanation {
      o_prot.write_field_begin(&TFieldIdentifier::new("explanation", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSerializedRows {
  fn default() -> Self {
    TSerializedRows{
      buffers: Some(Vec::new()),
      buffer_lengths: Some(Vec::new()),
      buffers_total_size: Some(0),
      total_compression_time_ms: Some(0),
      descriptor: None,
      targets: Some(Vec::new()),
      target_init_vals: Some(Vec::new()),
      varlen_buffer: Some(Vec::new()),
      count_distinct_sets: Some(Vec::new()),
      explanation: Some("".to_owned()),
    }
  }
}
