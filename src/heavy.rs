// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::common;
use crate::completion_hints;
use crate::extension_functions;
use crate::serialized_result_set;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExecuteMode(pub i32);

impl TExecuteMode {
  pub const GPU: TExecuteMode = TExecuteMode(1);
  pub const CPU: TExecuteMode = TExecuteMode(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GPU,
    Self::CPU,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExecuteMode> {
    let enum_value = i_prot.read_i32()?;
    Ok(TExecuteMode::from(enum_value))
  }
}

impl From<i32> for TExecuteMode {
  fn from(i: i32) -> Self {
    match i {
      1 => TExecuteMode::GPU,
      2 => TExecuteMode::CPU,
      _ => TExecuteMode(i)
    }
  }
}

impl From<&i32> for TExecuteMode {
  fn from(i: &i32) -> Self {
    TExecuteMode::from(*i)
  }
}

impl From<TExecuteMode> for i32 {
  fn from(e: TExecuteMode) -> i32 {
    e.0
  }
}

impl From<&TExecuteMode> for i32 {
  fn from(e: &TExecuteMode) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSourceType(pub i32);

impl TSourceType {
  pub const DELIMITED_FILE: TSourceType = TSourceType(0);
  pub const GEO_FILE: TSourceType = TSourceType(1);
  pub const PARQUET_FILE: TSourceType = TSourceType(2);
  pub const RASTER_FILE: TSourceType = TSourceType(3);
  pub const ODBC: TSourceType = TSourceType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DELIMITED_FILE,
    Self::GEO_FILE,
    Self::PARQUET_FILE,
    Self::RASTER_FILE,
    Self::ODBC,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSourceType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSourceType::from(enum_value))
  }
}

impl From<i32> for TSourceType {
  fn from(i: i32) -> Self {
    match i {
      0 => TSourceType::DELIMITED_FILE,
      1 => TSourceType::GEO_FILE,
      2 => TSourceType::PARQUET_FILE,
      3 => TSourceType::RASTER_FILE,
      4 => TSourceType::ODBC,
      _ => TSourceType(i)
    }
  }
}

impl From<&i32> for TSourceType {
  fn from(i: &i32) -> Self {
    TSourceType::from(*i)
  }
}

impl From<TSourceType> for i32 {
  fn from(e: TSourceType) -> i32 {
    e.0
  }
}

impl From<&TSourceType> for i32 {
  fn from(e: &TSourceType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionDetail(pub i32);

impl TPartitionDetail {
  pub const DEFAULT: TPartitionDetail = TPartitionDetail(0);
  pub const REPLICATED: TPartitionDetail = TPartitionDetail(1);
  pub const SHARDED: TPartitionDetail = TPartitionDetail(2);
  pub const OTHER: TPartitionDetail = TPartitionDetail(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::REPLICATED,
    Self::SHARDED,
    Self::OTHER,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionDetail> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPartitionDetail::from(enum_value))
  }
}

impl From<i32> for TPartitionDetail {
  fn from(i: i32) -> Self {
    match i {
      0 => TPartitionDetail::DEFAULT,
      1 => TPartitionDetail::REPLICATED,
      2 => TPartitionDetail::SHARDED,
      3 => TPartitionDetail::OTHER,
      _ => TPartitionDetail(i)
    }
  }
}

impl From<&i32> for TPartitionDetail {
  fn from(i: &i32) -> Self {
    TPartitionDetail::from(*i)
  }
}

impl From<TPartitionDetail> for i32 {
  fn from(e: TPartitionDetail) -> i32 {
    e.0
  }
}

impl From<&TPartitionDetail> for i32 {
  fn from(e: &TPartitionDetail) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGeoFileLayerContents(pub i32);

impl TGeoFileLayerContents {
  pub const EMPTY: TGeoFileLayerContents = TGeoFileLayerContents(0);
  pub const GEO: TGeoFileLayerContents = TGeoFileLayerContents(1);
  pub const NON_GEO: TGeoFileLayerContents = TGeoFileLayerContents(2);
  pub const UNSUPPORTED_GEO: TGeoFileLayerContents = TGeoFileLayerContents(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EMPTY,
    Self::GEO,
    Self::NON_GEO,
    Self::UNSUPPORTED_GEO,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGeoFileLayerContents> {
    let enum_value = i_prot.read_i32()?;
    Ok(TGeoFileLayerContents::from(enum_value))
  }
}

impl From<i32> for TGeoFileLayerContents {
  fn from(i: i32) -> Self {
    match i {
      0 => TGeoFileLayerContents::EMPTY,
      1 => TGeoFileLayerContents::GEO,
      2 => TGeoFileLayerContents::NON_GEO,
      3 => TGeoFileLayerContents::UNSUPPORTED_GEO,
      _ => TGeoFileLayerContents(i)
    }
  }
}

impl From<&i32> for TGeoFileLayerContents {
  fn from(i: &i32) -> Self {
    TGeoFileLayerContents::from(*i)
  }
}

impl From<TGeoFileLayerContents> for i32 {
  fn from(e: TGeoFileLayerContents) -> i32 {
    e.0
  }
}

impl From<&TGeoFileLayerContents> for i32 {
  fn from(e: &TGeoFileLayerContents) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TImportHeaderRow(pub i32);

impl TImportHeaderRow {
  pub const AUTODETECT: TImportHeaderRow = TImportHeaderRow(0);
  pub const NO_HEADER: TImportHeaderRow = TImportHeaderRow(1);
  pub const HAS_HEADER: TImportHeaderRow = TImportHeaderRow(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AUTODETECT,
    Self::NO_HEADER,
    Self::HAS_HEADER,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TImportHeaderRow> {
    let enum_value = i_prot.read_i32()?;
    Ok(TImportHeaderRow::from(enum_value))
  }
}

impl From<i32> for TImportHeaderRow {
  fn from(i: i32) -> Self {
    match i {
      0 => TImportHeaderRow::AUTODETECT,
      1 => TImportHeaderRow::NO_HEADER,
      2 => TImportHeaderRow::HAS_HEADER,
      _ => TImportHeaderRow(i)
    }
  }
}

impl From<&i32> for TImportHeaderRow {
  fn from(i: &i32) -> Self {
    TImportHeaderRow::from(*i)
  }
}

impl From<TImportHeaderRow> for i32 {
  fn from(e: TImportHeaderRow) -> i32 {
    e.0
  }
}

impl From<&TImportHeaderRow> for i32 {
  fn from(e: &TImportHeaderRow) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRole(pub i32);

impl TRole {
  pub const SERVER: TRole = TRole(0);
  pub const AGGREGATOR: TRole = TRole(1);
  pub const LEAF: TRole = TRole(2);
  pub const STRING_DICTIONARY: TRole = TRole(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SERVER,
    Self::AGGREGATOR,
    Self::LEAF,
    Self::STRING_DICTIONARY,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRole> {
    let enum_value = i_prot.read_i32()?;
    Ok(TRole::from(enum_value))
  }
}

impl From<i32> for TRole {
  fn from(i: i32) -> Self {
    match i {
      0 => TRole::SERVER,
      1 => TRole::AGGREGATOR,
      2 => TRole::LEAF,
      3 => TRole::STRING_DICTIONARY,
      _ => TRole(i)
    }
  }
}

impl From<&i32> for TRole {
  fn from(i: &i32) -> Self {
    TRole::from(*i)
  }
}

impl From<TRole> for i32 {
  fn from(e: TRole) -> i32 {
    e.0
  }
}

impl From<&TRole> for i32 {
  fn from(e: &TRole) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableType(pub i32);

impl TTableType {
  pub const DEFAULT: TTableType = TTableType(0);
  pub const TEMPORARY: TTableType = TTableType(1);
  pub const FOREIGN: TTableType = TTableType(2);
  pub const VIEW: TTableType = TTableType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::TEMPORARY,
    Self::FOREIGN,
    Self::VIEW,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTableType::from(enum_value))
  }
}

impl From<i32> for TTableType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTableType::DEFAULT,
      1 => TTableType::TEMPORARY,
      2 => TTableType::FOREIGN,
      3 => TTableType::VIEW,
      _ => TTableType(i)
    }
  }
}

impl From<&i32> for TTableType {
  fn from(i: &i32) -> Self {
    TTableType::from(*i)
  }
}

impl From<TTableType> for i32 {
  fn from(e: TTableType) -> i32 {
    e.0
  }
}

impl From<&TTableType> for i32 {
  fn from(e: &TTableType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableRefreshUpdateType(pub i32);

impl TTableRefreshUpdateType {
  pub const ALL: TTableRefreshUpdateType = TTableRefreshUpdateType(0);
  pub const APPEND: TTableRefreshUpdateType = TTableRefreshUpdateType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ALL,
    Self::APPEND,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableRefreshUpdateType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTableRefreshUpdateType::from(enum_value))
  }
}

impl From<i32> for TTableRefreshUpdateType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTableRefreshUpdateType::ALL,
      1 => TTableRefreshUpdateType::APPEND,
      _ => TTableRefreshUpdateType(i)
    }
  }
}

impl From<&i32> for TTableRefreshUpdateType {
  fn from(i: &i32) -> Self {
    TTableRefreshUpdateType::from(*i)
  }
}

impl From<TTableRefreshUpdateType> for i32 {
  fn from(e: TTableRefreshUpdateType) -> i32 {
    e.0
  }
}

impl From<&TTableRefreshUpdateType> for i32 {
  fn from(e: &TTableRefreshUpdateType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableRefreshTimingType(pub i32);

impl TTableRefreshTimingType {
  pub const MANUAL: TTableRefreshTimingType = TTableRefreshTimingType(0);
  pub const SCHEDULED: TTableRefreshTimingType = TTableRefreshTimingType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MANUAL,
    Self::SCHEDULED,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableRefreshTimingType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTableRefreshTimingType::from(enum_value))
  }
}

impl From<i32> for TTableRefreshTimingType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTableRefreshTimingType::MANUAL,
      1 => TTableRefreshTimingType::SCHEDULED,
      _ => TTableRefreshTimingType(i)
    }
  }
}

impl From<&i32> for TTableRefreshTimingType {
  fn from(i: &i32) -> Self {
    TTableRefreshTimingType::from(*i)
  }
}

impl From<TTableRefreshTimingType> for i32 {
  fn from(e: TTableRefreshTimingType) -> i32 {
    e.0
  }
}

impl From<&TTableRefreshTimingType> for i32 {
  fn from(e: &TTableRefreshTimingType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableRefreshIntervalType(pub i32);

impl TTableRefreshIntervalType {
  pub const NONE: TTableRefreshIntervalType = TTableRefreshIntervalType(0);
  pub const HOUR: TTableRefreshIntervalType = TTableRefreshIntervalType(1);
  pub const DAY: TTableRefreshIntervalType = TTableRefreshIntervalType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::HOUR,
    Self::DAY,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableRefreshIntervalType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTableRefreshIntervalType::from(enum_value))
  }
}

impl From<i32> for TTableRefreshIntervalType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTableRefreshIntervalType::NONE,
      1 => TTableRefreshIntervalType::HOUR,
      2 => TTableRefreshIntervalType::DAY,
      _ => TTableRefreshIntervalType(i)
    }
  }
}

impl From<&i32> for TTableRefreshIntervalType {
  fn from(i: &i32) -> Self {
    TTableRefreshIntervalType::from(*i)
  }
}

impl From<TTableRefreshIntervalType> for i32 {
  fn from(e: TTableRefreshIntervalType) -> i32 {
    e.0
  }
}

impl From<&TTableRefreshIntervalType> for i32 {
  fn from(e: &TTableRefreshIntervalType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMergeType(pub i32);

impl TMergeType {
  pub const UNION: TMergeType = TMergeType(0);
  pub const REDUCE: TMergeType = TMergeType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNION,
    Self::REDUCE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMergeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TMergeType::from(enum_value))
  }
}

impl From<i32> for TMergeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TMergeType::UNION,
      1 => TMergeType::REDUCE,
      _ => TMergeType(i)
    }
  }
}

impl From<&i32> for TMergeType {
  fn from(i: &i32) -> Self {
    TMergeType::from(*i)
  }
}

impl From<TMergeType> for i32 {
  fn from(e: TMergeType) -> i32 {
    e.0
  }
}

impl From<&TMergeType> for i32 {
  fn from(e: &TMergeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRasterPointType(pub i32);

impl TRasterPointType {
  pub const NONE: TRasterPointType = TRasterPointType(0);
  pub const AUTO: TRasterPointType = TRasterPointType(1);
  pub const SMALLINT: TRasterPointType = TRasterPointType(2);
  pub const INT: TRasterPointType = TRasterPointType(3);
  pub const FLOAT: TRasterPointType = TRasterPointType(4);
  pub const DOUBLE: TRasterPointType = TRasterPointType(5);
  pub const POINT: TRasterPointType = TRasterPointType(6);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AUTO,
    Self::SMALLINT,
    Self::INT,
    Self::FLOAT,
    Self::DOUBLE,
    Self::POINT,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRasterPointType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TRasterPointType::from(enum_value))
  }
}

impl From<i32> for TRasterPointType {
  fn from(i: i32) -> Self {
    match i {
      0 => TRasterPointType::NONE,
      1 => TRasterPointType::AUTO,
      2 => TRasterPointType::SMALLINT,
      3 => TRasterPointType::INT,
      4 => TRasterPointType::FLOAT,
      5 => TRasterPointType::DOUBLE,
      6 => TRasterPointType::POINT,
      _ => TRasterPointType(i)
    }
  }
}

impl From<&i32> for TRasterPointType {
  fn from(i: &i32) -> Self {
    TRasterPointType::from(*i)
  }
}

impl From<TRasterPointType> for i32 {
  fn from(e: TRasterPointType) -> i32 {
    e.0
  }
}

impl From<&TRasterPointType> for i32 {
  fn from(e: &TRasterPointType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRasterPointTransform(pub i32);

impl TRasterPointTransform {
  pub const NONE: TRasterPointTransform = TRasterPointTransform(0);
  pub const AUTO: TRasterPointTransform = TRasterPointTransform(1);
  pub const FILE: TRasterPointTransform = TRasterPointTransform(2);
  pub const WORLD: TRasterPointTransform = TRasterPointTransform(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AUTO,
    Self::FILE,
    Self::WORLD,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRasterPointTransform> {
    let enum_value = i_prot.read_i32()?;
    Ok(TRasterPointTransform::from(enum_value))
  }
}

impl From<i32> for TRasterPointTransform {
  fn from(i: i32) -> Self {
    match i {
      0 => TRasterPointTransform::NONE,
      1 => TRasterPointTransform::AUTO,
      2 => TRasterPointTransform::FILE,
      3 => TRasterPointTransform::WORLD,
      _ => TRasterPointTransform(i)
    }
  }
}

impl From<&i32> for TRasterPointTransform {
  fn from(i: &i32) -> Self {
    TRasterPointTransform::from(*i)
  }
}

impl From<TRasterPointTransform> for i32 {
  fn from(e: TRasterPointTransform) -> i32 {
    e.0
  }
}

impl From<&TRasterPointTransform> for i32 {
  fn from(e: &TRasterPointTransform) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryType(pub i32);

impl TQueryType {
  pub const UNKNOWN: TQueryType = TQueryType(0);
  pub const READ: TQueryType = TQueryType(1);
  pub const WRITE: TQueryType = TQueryType(2);
  pub const SCHEMA_READ: TQueryType = TQueryType(3);
  pub const SCHEMA_WRITE: TQueryType = TQueryType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::READ,
    Self::WRITE,
    Self::SCHEMA_READ,
    Self::SCHEMA_WRITE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TQueryType::from(enum_value))
  }
}

impl From<i32> for TQueryType {
  fn from(i: i32) -> Self {
    match i {
      0 => TQueryType::UNKNOWN,
      1 => TQueryType::READ,
      2 => TQueryType::WRITE,
      3 => TQueryType::SCHEMA_READ,
      4 => TQueryType::SCHEMA_WRITE,
      _ => TQueryType(i)
    }
  }
}

impl From<&i32> for TQueryType {
  fn from(i: &i32) -> Self {
    TQueryType::from(*i)
  }
}

impl From<TQueryType> for i32 {
  fn from(e: TQueryType) -> i32 {
    e.0
  }
}

impl From<&TQueryType> for i32 {
  fn from(e: &TQueryType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TArrowTransport(pub i32);

impl TArrowTransport {
  pub const SHARED_MEMORY: TArrowTransport = TArrowTransport(0);
  pub const WIRE: TArrowTransport = TArrowTransport(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SHARED_MEMORY,
    Self::WIRE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TArrowTransport> {
    let enum_value = i_prot.read_i32()?;
    Ok(TArrowTransport::from(enum_value))
  }
}

impl From<i32> for TArrowTransport {
  fn from(i: i32) -> Self {
    match i {
      0 => TArrowTransport::SHARED_MEMORY,
      1 => TArrowTransport::WIRE,
      _ => TArrowTransport(i)
    }
  }
}

impl From<&i32> for TArrowTransport {
  fn from(i: &i32) -> Self {
    TArrowTransport::from(*i)
  }
}

impl From<TArrowTransport> for i32 {
  fn from(e: TArrowTransport) -> i32 {
    e.0
  }
}

impl From<&TArrowTransport> for i32 {
  fn from(e: &TArrowTransport) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExpressionRangeType(pub i32);

impl TExpressionRangeType {
  pub const INVALID: TExpressionRangeType = TExpressionRangeType(0);
  pub const INTEGER: TExpressionRangeType = TExpressionRangeType(1);
  pub const FLOAT: TExpressionRangeType = TExpressionRangeType(2);
  pub const DOUBLE: TExpressionRangeType = TExpressionRangeType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INVALID,
    Self::INTEGER,
    Self::FLOAT,
    Self::DOUBLE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExpressionRangeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TExpressionRangeType::from(enum_value))
  }
}

impl From<i32> for TExpressionRangeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TExpressionRangeType::INVALID,
      1 => TExpressionRangeType::INTEGER,
      2 => TExpressionRangeType::FLOAT,
      3 => TExpressionRangeType::DOUBLE,
      _ => TExpressionRangeType(i)
    }
  }
}

impl From<&i32> for TExpressionRangeType {
  fn from(i: &i32) -> Self {
    TExpressionRangeType::from(*i)
  }
}

impl From<TExpressionRangeType> for i32 {
  fn from(e: TExpressionRangeType) -> i32 {
    e.0
  }
}

impl From<&TExpressionRangeType> for i32 {
  fn from(e: &TExpressionRangeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBObjectType(pub i32);

impl TDBObjectType {
  pub const ABSTRACT_D_B_OBJECT_TYPE: TDBObjectType = TDBObjectType(0);
  pub const DATABASE_D_B_OBJECT_TYPE: TDBObjectType = TDBObjectType(1);
  pub const TABLE_D_B_OBJECT_TYPE: TDBObjectType = TDBObjectType(2);
  pub const DASHBOARD_D_B_OBJECT_TYPE: TDBObjectType = TDBObjectType(3);
  pub const VIEW_D_B_OBJECT_TYPE: TDBObjectType = TDBObjectType(4);
  pub const SERVER_D_B_OBJECT_TYPE: TDBObjectType = TDBObjectType(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ABSTRACT_D_B_OBJECT_TYPE,
    Self::DATABASE_D_B_OBJECT_TYPE,
    Self::TABLE_D_B_OBJECT_TYPE,
    Self::DASHBOARD_D_B_OBJECT_TYPE,
    Self::VIEW_D_B_OBJECT_TYPE,
    Self::SERVER_D_B_OBJECT_TYPE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObjectType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TDBObjectType::from(enum_value))
  }
}

impl From<i32> for TDBObjectType {
  fn from(i: i32) -> Self {
    match i {
      0 => TDBObjectType::ABSTRACT_D_B_OBJECT_TYPE,
      1 => TDBObjectType::DATABASE_D_B_OBJECT_TYPE,
      2 => TDBObjectType::TABLE_D_B_OBJECT_TYPE,
      3 => TDBObjectType::DASHBOARD_D_B_OBJECT_TYPE,
      4 => TDBObjectType::VIEW_D_B_OBJECT_TYPE,
      5 => TDBObjectType::SERVER_D_B_OBJECT_TYPE,
      _ => TDBObjectType(i)
    }
  }
}

impl From<&i32> for TDBObjectType {
  fn from(i: &i32) -> Self {
    TDBObjectType::from(*i)
  }
}

impl From<TDBObjectType> for i32 {
  fn from(e: TDBObjectType) -> i32 {
    e.0
  }
}

impl From<&TDBObjectType> for i32 {
  fn from(e: &TDBObjectType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataSourceType(pub i32);

impl TDataSourceType {
  pub const TABLE: TDataSourceType = TDataSourceType(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TABLE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataSourceType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TDataSourceType::from(enum_value))
  }
}

impl From<i32> for TDataSourceType {
  fn from(i: i32) -> Self {
    match i {
      0 => TDataSourceType::TABLE,
      _ => TDataSourceType(i)
    }
  }
}

impl From<&i32> for TDataSourceType {
  fn from(i: &i32) -> Self {
    TDataSourceType::from(*i)
  }
}

impl From<TDataSourceType> for i32 {
  fn from(e: TDataSourceType) -> i32 {
    e.0
  }
}

impl From<&TDataSourceType> for i32 {
  fn from(e: &TDataSourceType) -> i32 {
    e.0
  }
}

pub type TRowDescriptor = Vec<TColumnType>;

pub type TSessionId = String;

pub type TKrb5Token = String;

pub type TQueryId = i64;

pub type TSubqueryId = i64;

pub type TRenderPassMap = BTreeMap<i32, TRawRenderPassDataResult>;

pub type TRenderAggDataMap = BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>>;

//
// TDatumVal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatumVal {
  pub int_val: Option<i64>,
  pub real_val: Option<OrderedFloat<f64>>,
  pub str_val: Option<String>,
  pub arr_val: Option<Vec<Box<TDatum>>>,
}

impl TDatumVal {
  pub fn new<F1, F2, F3, F4>(int_val: F1, real_val: F2, str_val: F3, arr_val: F4) -> TDatumVal where F1: Into<Option<i64>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<String>>, F4: Into<Option<Vec<Box<TDatum>>>> {
    TDatumVal {
      int_val: int_val.into(),
      real_val: real_val.into(),
      str_val: str_val.into(),
      arr_val: arr_val.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatumVal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<Box<TDatum>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TDatum>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TDatum::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatumVal {
      int_val: f_1,
      real_val: f_2,
      str_val: f_3,
      arr_val: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatumVal");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.int_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_val", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.real_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("real_val", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.str_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_val", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.arr_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("arr_val", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatumVal {
  fn default() -> Self {
    TDatumVal{
      int_val: Some(0),
      real_val: Some(OrderedFloat::from(0.0)),
      str_val: Some("".to_owned()),
      arr_val: Some(Vec::new()),
    }
  }
}

//
// TDatum
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatum {
  pub val: Option<TDatumVal>,
  pub is_null: Option<bool>,
}

impl TDatum {
  pub fn new<F1, F2>(val: F1, is_null: F2) -> TDatum where F1: Into<Option<TDatumVal>>, F2: Into<Option<bool>> {
    TDatum {
      val: val.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatum> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDatumVal> = None;
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatumVal::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatum {
      val: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatum");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.val {
      o_prot.write_field_begin(&TFieldIdentifier::new("val", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatum {
  fn default() -> Self {
    TDatum{
      val: None,
      is_null: Some(false),
    }
  }
}

//
// TStringValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringValue {
  pub str_val: Option<String>,
  pub is_null: Option<bool>,
}

impl TStringValue {
  pub fn new<F1, F2>(str_val: F1, is_null: F2) -> TStringValue where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    TStringValue {
      str_val: str_val.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringValue {
      str_val: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.str_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_val", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringValue {
  fn default() -> Self {
    TStringValue{
      str_val: Some("".to_owned()),
      is_null: Some(false),
    }
  }
}

//
// TColumnType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnType {
  pub col_name: Option<String>,
  pub col_type: Option<common::TTypeInfo>,
  pub is_reserved_keyword: Option<bool>,
  pub src_name: Option<String>,
  pub is_system: Option<bool>,
  pub is_physical: Option<bool>,
  pub col_id: Option<i64>,
  pub default_value: Option<String>,
}

impl TColumnType {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(col_name: F1, col_type: F2, is_reserved_keyword: F3, src_name: F4, is_system: F5, is_physical: F6, col_id: F7, default_value: F8) -> TColumnType where F1: Into<Option<String>>, F2: Into<Option<common::TTypeInfo>>, F3: Into<Option<bool>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<i64>>, F8: Into<Option<String>> {
    TColumnType {
      col_name: col_name.into(),
      col_type: col_type.into(),
      is_reserved_keyword: is_reserved_keyword.into(),
      src_name: src_name.into(),
      is_system: is_system.into(),
      is_physical: is_physical.into(),
      col_id: col_id.into(),
      default_value: default_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<common::TTypeInfo> = None;
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = common::TTypeInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnType {
      col_name: f_1,
      col_type: f_2,
      is_reserved_keyword: f_3,
      src_name: f_4,
      is_system: f_5,
      is_physical: f_6,
      col_id: f_7,
      default_value: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.col_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_type", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_reserved_keyword {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_reserved_keyword", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.src_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("src_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_system {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_system", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_physical {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_physical", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.col_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_id", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_value", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnType {
  fn default() -> Self {
    TColumnType{
      col_name: Some("".to_owned()),
      col_type: None,
      is_reserved_keyword: Some(false),
      src_name: Some("".to_owned()),
      is_system: Some(false),
      is_physical: Some(false),
      col_id: Some(0),
      default_value: Some("".to_owned()),
    }
  }
}

//
// TRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRow {
  pub cols: Option<Vec<TDatum>>,
}

impl TRow {
  pub fn new<F1>(cols: F1) -> TRow where F1: Into<Option<Vec<TDatum>>> {
    TRow {
      cols: cols.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TDatum>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDatum> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = TDatum::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRow {
      cols: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRow");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRow {
  fn default() -> Self {
    TRow{
      cols: Some(Vec::new()),
    }
  }
}

//
// TColumnData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnData {
  pub int_col: Option<Vec<i64>>,
  pub real_col: Option<Vec<OrderedFloat<f64>>>,
  pub str_col: Option<Vec<String>>,
  pub arr_col: Option<Vec<Box<TColumn>>>,
}

impl TColumnData {
  pub fn new<F1, F2, F3, F4>(int_col: F1, real_col: F2, str_col: F3, arr_col: F4) -> TColumnData where F1: Into<Option<Vec<i64>>>, F2: Into<Option<Vec<OrderedFloat<f64>>>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<Vec<Box<TColumn>>>> {
    TColumnData {
      int_col: int_col.into(),
      real_col: real_col.into(),
      str_col: str_col.into(),
      arr_col: arr_col.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = Some(Vec::new());
    let mut f_2: Option<Vec<OrderedFloat<f64>>> = Some(Vec::new());
    let mut f_3: Option<Vec<String>> = Some(Vec::new());
    let mut f_4: Option<Vec<Box<TColumn>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_i64()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = OrderedFloat::from(i_prot.read_double()?);
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TColumn>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = Box::new(TColumn::read_from_in_protocol(i_prot)?);
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnData {
      int_col: f_1,
      real_col: f_2,
      str_col: f_3,
      arr_col: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.int_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_col", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.real_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("real_col", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_double((*e).into())?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.str_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_col", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.arr_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("arr_col", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnData {
  fn default() -> Self {
    TColumnData{
      int_col: Some(Vec::new()),
      real_col: Some(Vec::new()),
      str_col: Some(Vec::new()),
      arr_col: Some(Vec::new()),
    }
  }
}

//
// TColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumn {
  pub data: Option<TColumnData>,
  pub nulls: Option<Vec<bool>>,
}

impl TColumn {
  pub fn new<F1, F2>(data: F1, nulls: F2) -> TColumn where F1: Into<Option<TColumnData>>, F2: Into<Option<Vec<bool>>> {
    TColumn {
      data: data.into(),
      nulls: nulls.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TColumnData> = None;
    let mut f_2: Option<Vec<bool>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TColumnData::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_bool()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumn {
      data: f_1,
      nulls: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumn {
  fn default() -> Self {
    TColumn{
      data: None,
      nulls: Some(Vec::new()),
    }
  }
}

//
// TStringRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringRow {
  pub cols: Option<Vec<TStringValue>>,
}

impl TStringRow {
  pub fn new<F1>(cols: F1) -> TStringRow where F1: Into<Option<Vec<TStringValue>>> {
    TStringRow {
      cols: cols.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TStringValue>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStringValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = TStringValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringRow {
      cols: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringRow");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringRow {
  fn default() -> Self {
    TStringRow{
      cols: Some(Vec::new()),
    }
  }
}

//
// TKrb5Session
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TKrb5Session {
  pub session_id: Option<TSessionId>,
  pub krb_token: Option<TKrb5Token>,
}

impl TKrb5Session {
  pub fn new<F1, F2>(session_id: F1, krb_token: F2) -> TKrb5Session where F1: Into<Option<TSessionId>>, F2: Into<Option<TKrb5Token>> {
    TKrb5Session {
      session_id: session_id.into(),
      krb_token: krb_token.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TKrb5Session> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = Some("".to_owned());
    let mut f_2: Option<TKrb5Token> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TKrb5Session {
      session_id: f_1,
      krb_token: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TKrb5Session");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.krb_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("krbToken", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TKrb5Session {
  fn default() -> Self {
    TKrb5Session{
      session_id: Some("".to_owned()),
      krb_token: Some("".to_owned()),
    }
  }
}

//
// TStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStepResult {
  pub serialized_rows: Option<serialized_result_set::TSerializedRows>,
  pub execution_finished: Option<bool>,
  pub merge_type: Option<TMergeType>,
  pub sharded: Option<bool>,
  pub row_desc: Option<TRowDescriptor>,
  pub node_id: Option<i32>,
}

impl TStepResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(serialized_rows: F1, execution_finished: F2, merge_type: F3, sharded: F4, row_desc: F5, node_id: F6) -> TStepResult where F1: Into<Option<serialized_result_set::TSerializedRows>>, F2: Into<Option<bool>>, F3: Into<Option<TMergeType>>, F4: Into<Option<bool>>, F5: Into<Option<TRowDescriptor>>, F6: Into<Option<i32>> {
    TStepResult {
      serialized_rows: serialized_rows.into(),
      execution_finished: execution_finished.into(),
      merge_type: merge_type.into(),
      sharded: sharded.into(),
      row_desc: row_desc.into(),
      node_id: node_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<serialized_result_set::TSerializedRows> = None;
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<TMergeType> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_6: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = serialized_result_set::TSerializedRows::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TMergeType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStepResult {
      serialized_rows: f_1,
      execution_finished: f_2,
      merge_type: f_3,
      sharded: f_4,
      row_desc: f_5,
      node_id: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.serialized_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_rows", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_finished {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_finished", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.merge_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sharded {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharded", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.node_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStepResult {
  fn default() -> Self {
    TStepResult{
      serialized_rows: None,
      execution_finished: Some(false),
      merge_type: None,
      sharded: Some(false),
      row_desc: Some(Vec::new()),
      node_id: Some(0),
    }
  }
}

//
// TRowSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRowSet {
  pub row_desc: Option<TRowDescriptor>,
  pub rows: Option<Vec<TRow>>,
  pub columns: Option<Vec<TColumn>>,
  pub is_columnar: Option<bool>,
}

impl TRowSet {
  pub fn new<F1, F2, F3, F4>(row_desc: F1, rows: F2, columns: F3, is_columnar: F4) -> TRowSet where F1: Into<Option<TRowDescriptor>>, F2: Into<Option<Vec<TRow>>>, F3: Into<Option<Vec<TColumn>>>, F4: Into<Option<bool>> {
    TRowSet {
      row_desc: row_desc.into(),
      rows: rows.into(),
      columns: columns.into(),
      is_columnar: is_columnar.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRowSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_2: Option<Vec<TRow>> = Some(Vec::new());
    let mut f_3: Option<Vec<TColumn>> = Some(Vec::new());
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRowSet {
      row_desc: f_1,
      rows: f_2,
      columns: f_3,
      is_columnar: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRowSet");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_columnar {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_columnar", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRowSet {
  fn default() -> Self {
    TRowSet{
      row_desc: Some(Vec::new()),
      rows: Some(Vec::new()),
      columns: Some(Vec::new()),
      is_columnar: Some(false),
    }
  }
}

//
// TQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryResult {
  pub row_set: Option<TRowSet>,
  pub execution_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
  pub nonce: Option<String>,
  pub debug: Option<String>,
  pub success: Option<bool>,
  pub query_type: Option<TQueryType>,
}

impl TQueryResult {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(row_set: F1, execution_time_ms: F2, total_time_ms: F3, nonce: F4, debug: F5, success: F6, query_type: F7) -> TQueryResult where F1: Into<Option<TRowSet>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<bool>>, F7: Into<Option<TQueryType>> {
    TQueryResult {
      row_set: row_set.into(),
      execution_time_ms: execution_time_ms.into(),
      total_time_ms: total_time_ms.into(),
      nonce: nonce.into(),
      debug: debug.into(),
      success: success.into(),
      query_type: query_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowSet> = None;
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<TQueryType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = TQueryType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TQueryResult {
      row_set: f_1,
      execution_time_ms: f_2,
      total_time_ms: f_3,
      nonce: f_4,
      debug: f_5,
      success: f_6,
      query_type: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.debug {
      o_prot.write_field_begin(&TFieldIdentifier::new("debug", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_type", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TQueryResult {
  fn default() -> Self {
    TQueryResult{
      row_set: None,
      execution_time_ms: Some(0),
      total_time_ms: Some(0),
      nonce: Some("".to_owned()),
      debug: Some("".to_owned()),
      success: Some(false),
      query_type: None,
    }
  }
}

//
// TDataFrame
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataFrame {
  pub sm_handle: Option<Vec<u8>>,
  pub sm_size: Option<i64>,
  pub df_handle: Option<Vec<u8>>,
  pub df_size: Option<i64>,
  pub execution_time_ms: Option<i64>,
  pub arrow_conversion_time_ms: Option<i64>,
  pub df_buffer: Option<Vec<u8>>,
}

impl TDataFrame {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(sm_handle: F1, sm_size: F2, df_handle: F3, df_size: F4, execution_time_ms: F5, arrow_conversion_time_ms: F6, df_buffer: F7) -> TDataFrame where F1: Into<Option<Vec<u8>>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<Vec<u8>>> {
    TDataFrame {
      sm_handle: sm_handle.into(),
      sm_size: sm_size.into(),
      df_handle: df_handle.into(),
      df_size: df_size.into(),
      execution_time_ms: execution_time_ms.into(),
      arrow_conversion_time_ms: arrow_conversion_time_ms.into(),
      df_buffer: df_buffer.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataFrame> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bytes()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDataFrame {
      sm_handle: f_1,
      sm_size: f_2,
      df_handle: f_3,
      df_size: f_4,
      execution_time_ms: f_5,
      arrow_conversion_time_ms: f_6,
      df_buffer: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataFrame");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.sm_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("sm_handle", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sm_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("sm_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.df_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_handle", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.df_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_size", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.arrow_conversion_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("arrow_conversion_time_ms", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.df_buffer {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_buffer", TType::String, 7))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDataFrame {
  fn default() -> Self {
    TDataFrame{
      sm_handle: Some(Vec::new()),
      sm_size: Some(0),
      df_handle: Some(Vec::new()),
      df_size: Some(0),
      execution_time_ms: Some(0),
      arrow_conversion_time_ms: Some(0),
      df_buffer: Some(Vec::new()),
    }
  }
}

//
// TDBInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBInfo {
  pub db_name: Option<String>,
  pub db_owner: Option<String>,
}

impl TDBInfo {
  pub fn new<F1, F2>(db_name: F1, db_owner: F2) -> TDBInfo where F1: Into<Option<String>>, F2: Into<Option<String>> {
    TDBInfo {
      db_name: db_name.into(),
      db_owner: db_owner.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBInfo {
      db_name: f_1,
      db_owner: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_owner", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBInfo {
  fn default() -> Self {
    TDBInfo{
      db_name: Some("".to_owned()),
      db_owner: Some("".to_owned()),
    }
  }
}

//
// TDBException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBException {
  pub error_msg: Option<String>,
}

impl TDBException {
  pub fn new<F1>(error_msg: F1) -> TDBException where F1: Into<Option<String>> {
    TDBException {
      error_msg: error_msg.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBException {
      error_msg: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.error_msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("error_msg", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBException {
  fn default() -> Self {
    TDBException{
      error_msg: Some("".to_owned()),
    }
  }
}

impl Error for TDBException {}

impl From<TDBException> for thrift::Error {
  fn from(e: TDBException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TDBException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw TDBException")
  }
}

//
// TCopyParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCopyParams {
  pub delimiter: Option<String>,
  pub null_str: Option<String>,
  pub has_header: Option<TImportHeaderRow>,
  pub quoted: Option<bool>,
  pub quote: Option<String>,
  pub escape: Option<String>,
  pub line_delim: Option<String>,
  pub array_delim: Option<String>,
  pub array_begin: Option<String>,
  pub array_end: Option<String>,
  pub threads: Option<i32>,
  pub source_type: Option<TSourceType>,
  pub s3_access_key: Option<String>,
  pub s3_secret_key: Option<String>,
  pub s3_region: Option<String>,
  pub geo_coords_encoding: Option<common::TEncodingType>,
  pub geo_coords_comp_param: Option<i32>,
  pub geo_coords_type: Option<common::TDatumType>,
  pub geo_coords_srid: Option<i32>,
  pub sanitize_column_names: Option<bool>,
  pub geo_layer_name: Option<String>,
  pub s3_endpoint: Option<String>,
  pub geo_assign_render_groups: Option<bool>,
  pub geo_explode_collections: Option<bool>,
  pub source_srid: Option<i32>,
  pub s3_session_token: Option<String>,
  pub raster_point_type: Option<TRasterPointType>,
  pub raster_import_bands: Option<String>,
  pub raster_scanlines_per_thread: Option<i32>,
  pub raster_point_transform: Option<TRasterPointTransform>,
  pub raster_point_compute_angle: Option<bool>,
  pub raster_import_dimensions: Option<String>,
  pub odbc_dsn: Option<String>,
  pub odbc_connection_string: Option<String>,
  pub odbc_sql_select: Option<String>,
  pub odbc_sql_order_by: Option<String>,
  pub odbc_username: Option<String>,
  pub odbc_password: Option<String>,
  pub odbc_credential_string: Option<String>,
  pub add_metadata_columns: Option<String>,
}

impl TCopyParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28, F29, F30, F31, F32, F33, F34, F35, F36, F37, F38, F39, F40>(delimiter: F1, null_str: F2, has_header: F3, quoted: F4, quote: F5, escape: F6, line_delim: F7, array_delim: F8, array_begin: F9, array_end: F10, threads: F11, source_type: F12, s3_access_key: F13, s3_secret_key: F14, s3_region: F15, geo_coords_encoding: F16, geo_coords_comp_param: F17, geo_coords_type: F18, geo_coords_srid: F19, sanitize_column_names: F20, geo_layer_name: F21, s3_endpoint: F22, geo_assign_render_groups: F23, geo_explode_collections: F24, source_srid: F25, s3_session_token: F26, raster_point_type: F27, raster_import_bands: F28, raster_scanlines_per_thread: F29, raster_point_transform: F30, raster_point_compute_angle: F31, raster_import_dimensions: F32, odbc_dsn: F33, odbc_connection_string: F34, odbc_sql_select: F35, odbc_sql_order_by: F36, odbc_username: F37, odbc_password: F38, odbc_credential_string: F39, add_metadata_columns: F40) -> TCopyParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<TImportHeaderRow>>, F4: Into<Option<bool>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<i32>>, F12: Into<Option<TSourceType>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<String>>, F16: Into<Option<common::TEncodingType>>, F17: Into<Option<i32>>, F18: Into<Option<common::TDatumType>>, F19: Into<Option<i32>>, F20: Into<Option<bool>>, F21: Into<Option<String>>, F22: Into<Option<String>>, F23: Into<Option<bool>>, F24: Into<Option<bool>>, F25: Into<Option<i32>>, F26: Into<Option<String>>, F27: Into<Option<TRasterPointType>>, F28: Into<Option<String>>, F29: Into<Option<i32>>, F30: Into<Option<TRasterPointTransform>>, F31: Into<Option<bool>>, F32: Into<Option<String>>, F33: Into<Option<String>>, F34: Into<Option<String>>, F35: Into<Option<String>>, F36: Into<Option<String>>, F37: Into<Option<String>>, F38: Into<Option<String>>, F39: Into<Option<String>>, F40: Into<Option<String>> {
    TCopyParams {
      delimiter: delimiter.into(),
      null_str: null_str.into(),
      has_header: has_header.into(),
      quoted: quoted.into(),
      quote: quote.into(),
      escape: escape.into(),
      line_delim: line_delim.into(),
      array_delim: array_delim.into(),
      array_begin: array_begin.into(),
      array_end: array_end.into(),
      threads: threads.into(),
      source_type: source_type.into(),
      s3_access_key: s3_access_key.into(),
      s3_secret_key: s3_secret_key.into(),
      s3_region: s3_region.into(),
      geo_coords_encoding: geo_coords_encoding.into(),
      geo_coords_comp_param: geo_coords_comp_param.into(),
      geo_coords_type: geo_coords_type.into(),
      geo_coords_srid: geo_coords_srid.into(),
      sanitize_column_names: sanitize_column_names.into(),
      geo_layer_name: geo_layer_name.into(),
      s3_endpoint: s3_endpoint.into(),
      geo_assign_render_groups: geo_assign_render_groups.into(),
      geo_explode_collections: geo_explode_collections.into(),
      source_srid: source_srid.into(),
      s3_session_token: s3_session_token.into(),
      raster_point_type: raster_point_type.into(),
      raster_import_bands: raster_import_bands.into(),
      raster_scanlines_per_thread: raster_scanlines_per_thread.into(),
      raster_point_transform: raster_point_transform.into(),
      raster_point_compute_angle: raster_point_compute_angle.into(),
      raster_import_dimensions: raster_import_dimensions.into(),
      odbc_dsn: odbc_dsn.into(),
      odbc_connection_string: odbc_connection_string.into(),
      odbc_sql_select: odbc_sql_select.into(),
      odbc_sql_order_by: odbc_sql_order_by.into(),
      odbc_username: odbc_username.into(),
      odbc_password: odbc_password.into(),
      odbc_credential_string: odbc_credential_string.into(),
      add_metadata_columns: add_metadata_columns.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCopyParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<TImportHeaderRow> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<i32> = Some(0);
    let mut f_12: Option<TSourceType> = None;
    let mut f_13: Option<String> = Some("".to_owned());
    let mut f_14: Option<String> = Some("".to_owned());
    let mut f_15: Option<String> = Some("".to_owned());
    let mut f_16: Option<common::TEncodingType> = None;
    let mut f_17: Option<i32> = Some(0);
    let mut f_18: Option<common::TDatumType> = None;
    let mut f_19: Option<i32> = Some(0);
    let mut f_20: Option<bool> = Some(false);
    let mut f_21: Option<String> = Some("".to_owned());
    let mut f_22: Option<String> = Some("".to_owned());
    let mut f_23: Option<bool> = Some(false);
    let mut f_24: Option<bool> = Some(false);
    let mut f_25: Option<i32> = Some(0);
    let mut f_26: Option<String> = Some("".to_owned());
    let mut f_27: Option<TRasterPointType> = None;
    let mut f_28: Option<String> = Some("".to_owned());
    let mut f_29: Option<i32> = Some(0);
    let mut f_30: Option<TRasterPointTransform> = None;
    let mut f_31: Option<bool> = Some(false);
    let mut f_32: Option<String> = Some("".to_owned());
    let mut f_33: Option<String> = Some("".to_owned());
    let mut f_34: Option<String> = Some("".to_owned());
    let mut f_35: Option<String> = Some("".to_owned());
    let mut f_36: Option<String> = Some("".to_owned());
    let mut f_37: Option<String> = Some("".to_owned());
    let mut f_38: Option<String> = Some("".to_owned());
    let mut f_39: Option<String> = Some("".to_owned());
    let mut f_40: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TImportHeaderRow::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TSourceType::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let val = common::TEncodingType::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = common::TDatumType::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i32()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_bool()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_i32()?;
          f_25 = Some(val);
        },
        26 => {
          let val = i_prot.read_string()?;
          f_26 = Some(val);
        },
        27 => {
          let val = TRasterPointType::read_from_in_protocol(i_prot)?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_string()?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_i32()?;
          f_29 = Some(val);
        },
        30 => {
          let val = TRasterPointTransform::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_string()?;
          f_32 = Some(val);
        },
        33 => {
          let val = i_prot.read_string()?;
          f_33 = Some(val);
        },
        34 => {
          let val = i_prot.read_string()?;
          f_34 = Some(val);
        },
        35 => {
          let val = i_prot.read_string()?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_string()?;
          f_36 = Some(val);
        },
        37 => {
          let val = i_prot.read_string()?;
          f_37 = Some(val);
        },
        38 => {
          let val = i_prot.read_string()?;
          f_38 = Some(val);
        },
        39 => {
          let val = i_prot.read_string()?;
          f_39 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCopyParams {
      delimiter: f_1,
      null_str: f_2,
      has_header: f_3,
      quoted: f_4,
      quote: f_5,
      escape: f_6,
      line_delim: f_7,
      array_delim: f_8,
      array_begin: f_9,
      array_end: f_10,
      threads: f_11,
      source_type: f_12,
      s3_access_key: f_13,
      s3_secret_key: f_14,
      s3_region: f_15,
      geo_coords_encoding: f_16,
      geo_coords_comp_param: f_17,
      geo_coords_type: f_18,
      geo_coords_srid: f_19,
      sanitize_column_names: f_20,
      geo_layer_name: f_21,
      s3_endpoint: f_22,
      geo_assign_render_groups: f_23,
      geo_explode_collections: f_24,
      source_srid: f_25,
      s3_session_token: f_26,
      raster_point_type: f_27,
      raster_import_bands: f_28,
      raster_scanlines_per_thread: f_29,
      raster_point_transform: f_30,
      raster_point_compute_angle: f_31,
      raster_import_dimensions: f_32,
      odbc_dsn: f_33,
      odbc_connection_string: f_34,
      odbc_sql_select: f_35,
      odbc_sql_order_by: f_36,
      odbc_username: f_37,
      odbc_password: f_38,
      odbc_credential_string: f_39,
      add_metadata_columns: f_40,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCopyParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("delimiter", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.null_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_str", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.has_header {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_header", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.quoted {
      o_prot.write_field_begin(&TFieldIdentifier::new("quoted", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.quote {
      o_prot.write_field_begin(&TFieldIdentifier::new("quote", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.escape {
      o_prot.write_field_begin(&TFieldIdentifier::new("escape", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.line_delim {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delim", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.array_delim {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_delim", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.array_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_begin", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.array_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_end", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.threads {
      o_prot.write_field_begin(&TFieldIdentifier::new("threads", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("source_type", TType::I32, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.s3_access_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_access_key", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.s3_secret_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_secret_key", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.s3_region {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_region", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.geo_coords_encoding {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_encoding", TType::I32, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.geo_coords_comp_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_comp_param", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.geo_coords_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_type", TType::I32, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.geo_coords_srid {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_srid", TType::I32, 19))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sanitize_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("sanitize_column_names", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.geo_layer_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_layer_name", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.s3_endpoint {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_endpoint", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.geo_assign_render_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_assign_render_groups", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.geo_explode_collections {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_explode_collections", TType::Bool, 24))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.source_srid {
      o_prot.write_field_begin(&TFieldIdentifier::new("source_srid", TType::I32, 25))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.s3_session_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_session_token", TType::String, 26))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raster_point_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("raster_point_type", TType::I32, 27))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raster_import_bands {
      o_prot.write_field_begin(&TFieldIdentifier::new("raster_import_bands", TType::String, 28))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.raster_scanlines_per_thread {
      o_prot.write_field_begin(&TFieldIdentifier::new("raster_scanlines_per_thread", TType::I32, 29))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raster_point_transform {
      o_prot.write_field_begin(&TFieldIdentifier::new("raster_point_transform", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.raster_point_compute_angle {
      o_prot.write_field_begin(&TFieldIdentifier::new("raster_point_compute_angle", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raster_import_dimensions {
      o_prot.write_field_begin(&TFieldIdentifier::new("raster_import_dimensions", TType::String, 32))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_dsn {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_dsn", TType::String, 33))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_connection_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_connection_string", TType::String, 34))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_sql_select {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_sql_select", TType::String, 35))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_sql_order_by {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_sql_order_by", TType::String, 36))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_username {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_username", TType::String, 37))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_password {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_password", TType::String, 38))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_credential_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_credential_string", TType::String, 39))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.add_metadata_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("add_metadata_columns", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCopyParams {
  fn default() -> Self {
    TCopyParams{
      delimiter: Some("".to_owned()),
      null_str: Some("".to_owned()),
      has_header: None,
      quoted: Some(false),
      quote: Some("".to_owned()),
      escape: Some("".to_owned()),
      line_delim: Some("".to_owned()),
      array_delim: Some("".to_owned()),
      array_begin: Some("".to_owned()),
      array_end: Some("".to_owned()),
      threads: Some(0),
      source_type: None,
      s3_access_key: Some("".to_owned()),
      s3_secret_key: Some("".to_owned()),
      s3_region: Some("".to_owned()),
      geo_coords_encoding: None,
      geo_coords_comp_param: Some(0),
      geo_coords_type: None,
      geo_coords_srid: Some(0),
      sanitize_column_names: Some(false),
      geo_layer_name: Some("".to_owned()),
      s3_endpoint: Some("".to_owned()),
      geo_assign_render_groups: Some(false),
      geo_explode_collections: Some(false),
      source_srid: Some(0),
      s3_session_token: Some("".to_owned()),
      raster_point_type: None,
      raster_import_bands: Some("".to_owned()),
      raster_scanlines_per_thread: Some(0),
      raster_point_transform: None,
      raster_point_compute_angle: Some(false),
      raster_import_dimensions: Some("".to_owned()),
      odbc_dsn: Some("".to_owned()),
      odbc_connection_string: Some("".to_owned()),
      odbc_sql_select: Some("".to_owned()),
      odbc_sql_order_by: Some("".to_owned()),
      odbc_username: Some("".to_owned()),
      odbc_password: Some("".to_owned()),
      odbc_credential_string: Some("".to_owned()),
      add_metadata_columns: Some("".to_owned()),
    }
  }
}

//
// TCreateParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCreateParams {
  pub is_replicated: Option<bool>,
}

impl TCreateParams {
  pub fn new<F1>(is_replicated: F1) -> TCreateParams where F1: Into<Option<bool>> {
    TCreateParams {
      is_replicated: is_replicated.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCreateParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCreateParams {
      is_replicated: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCreateParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_replicated {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_replicated", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCreateParams {
  fn default() -> Self {
    TCreateParams{
      is_replicated: Some(false),
    }
  }
}

//
// TDetectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDetectResult {
  pub row_set: Option<TRowSet>,
  pub copy_params: Option<TCopyParams>,
}

impl TDetectResult {
  pub fn new<F1, F2>(row_set: F1, copy_params: F2) -> TDetectResult where F1: Into<Option<TRowSet>>, F2: Into<Option<TCopyParams>> {
    TDetectResult {
      row_set: row_set.into(),
      copy_params: copy_params.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDetectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowSet> = None;
    let mut f_2: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDetectResult {
      row_set: f_1,
      copy_params: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDetectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.copy_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDetectResult {
  fn default() -> Self {
    TDetectResult{
      row_set: None,
      copy_params: None,
    }
  }
}

//
// TImportStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TImportStatus {
  pub elapsed: Option<i64>,
  pub rows_completed: Option<i64>,
  pub rows_estimated: Option<i64>,
  pub rows_rejected: Option<i64>,
}

impl TImportStatus {
  pub fn new<F1, F2, F3, F4>(elapsed: F1, rows_completed: F2, rows_estimated: F3, rows_rejected: F4) -> TImportStatus where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    TImportStatus {
      elapsed: elapsed.into(),
      rows_completed: rows_completed.into(),
      rows_estimated: rows_estimated.into(),
      rows_rejected: rows_rejected.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TImportStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TImportStatus {
      elapsed: f_1,
      rows_completed: f_2,
      rows_estimated: f_3,
      rows_rejected: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TImportStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.elapsed {
      o_prot.write_field_begin(&TFieldIdentifier::new("elapsed", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rows_completed {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_completed", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rows_estimated {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_estimated", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rows_rejected {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_rejected", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TImportStatus {
  fn default() -> Self {
    TImportStatus{
      elapsed: Some(0),
      rows_completed: Some(0),
      rows_estimated: Some(0),
      rows_rejected: Some(0),
    }
  }
}

//
// TFrontendView
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFrontendView {
  pub view_name: Option<String>,
  pub view_state: Option<String>,
  pub image_hash: Option<String>,
  pub update_time: Option<String>,
  pub view_metadata: Option<String>,
}

impl TFrontendView {
  pub fn new<F1, F2, F3, F4, F5>(view_name: F1, view_state: F2, image_hash: F3, update_time: F4, view_metadata: F5) -> TFrontendView where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    TFrontendView {
      view_name: view_name.into(),
      view_state: view_state.into(),
      image_hash: image_hash.into(),
      update_time: update_time.into(),
      view_metadata: view_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFrontendView> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFrontendView {
      view_name: f_1,
      view_state: f_2,
      image_hash: f_3,
      update_time: f_4,
      view_metadata: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFrontendView");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.view_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.view_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_state", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.image_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_time", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.view_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_metadata", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TFrontendView {
  fn default() -> Self {
    TFrontendView{
      view_name: Some("".to_owned()),
      view_state: Some("".to_owned()),
      image_hash: Some("".to_owned()),
      update_time: Some("".to_owned()),
      view_metadata: Some("".to_owned()),
    }
  }
}

//
// TServerStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TServerStatus {
  pub read_only: Option<bool>,
  pub version: Option<String>,
  pub rendering_enabled: Option<bool>,
  pub start_time: Option<i64>,
  pub edition: Option<String>,
  pub host_name: Option<String>,
  pub poly_rendering_enabled: Option<bool>,
  pub role: Option<TRole>,
  pub renderer_status_json: Option<String>,
}

impl TServerStatus {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(read_only: F1, version: F2, rendering_enabled: F3, start_time: F4, edition: F5, host_name: F6, poly_rendering_enabled: F7, role: F8, renderer_status_json: F9) -> TServerStatus where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<bool>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<TRole>>, F9: Into<Option<String>> {
    TServerStatus {
      read_only: read_only.into(),
      version: version.into(),
      rendering_enabled: rendering_enabled.into(),
      start_time: start_time.into(),
      edition: edition.into(),
      host_name: host_name.into(),
      poly_rendering_enabled: poly_rendering_enabled.into(),
      role: role.into(),
      renderer_status_json: renderer_status_json.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TServerStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<TRole> = None;
    let mut f_9: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = TRole::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TServerStatus {
      read_only: f_1,
      version: f_2,
      rendering_enabled: f_3,
      start_time: f_4,
      edition: f_5,
      host_name: f_6,
      poly_rendering_enabled: f_7,
      role: f_8,
      renderer_status_json: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TServerStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_only", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rendering_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("rendering_enabled", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_time", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.edition {
      o_prot.write_field_begin(&TFieldIdentifier::new("edition", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.poly_rendering_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("poly_rendering_enabled", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.role {
      o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.renderer_status_json {
      o_prot.write_field_begin(&TFieldIdentifier::new("renderer_status_json", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TServerStatus {
  fn default() -> Self {
    TServerStatus{
      read_only: Some(false),
      version: Some("".to_owned()),
      rendering_enabled: Some(false),
      start_time: Some(0),
      edition: Some("".to_owned()),
      host_name: Some("".to_owned()),
      poly_rendering_enabled: Some(false),
      role: None,
      renderer_status_json: Some("".to_owned()),
    }
  }
}

//
// TPixel
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPixel {
  pub x: Option<i64>,
  pub y: Option<i64>,
}

impl TPixel {
  pub fn new<F1, F2>(x: F1, y: F2) -> TPixel where F1: Into<Option<i64>>, F2: Into<Option<i64>> {
    TPixel {
      x: x.into(),
      y: y.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPixel> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPixel {
      x: f_1,
      y: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPixel");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.x {
      o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.y {
      o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPixel {
  fn default() -> Self {
    TPixel{
      x: Some(0),
      y: Some(0),
    }
  }
}

//
// TPixelTableRowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPixelTableRowResult {
  pub pixel: Option<TPixel>,
  pub vega_table_name: Option<String>,
  pub table_id: Option<Vec<i64>>,
  pub row_id: Option<Vec<i64>>,
  pub row_set: Option<TRowSet>,
  pub nonce: Option<String>,
}

impl TPixelTableRowResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(pixel: F1, vega_table_name: F2, table_id: F3, row_id: F4, row_set: F5, nonce: F6) -> TPixelTableRowResult where F1: Into<Option<TPixel>>, F2: Into<Option<String>>, F3: Into<Option<Vec<i64>>>, F4: Into<Option<Vec<i64>>>, F5: Into<Option<TRowSet>>, F6: Into<Option<String>> {
    TPixelTableRowResult {
      pixel: pixel.into(),
      vega_table_name: vega_table_name.into(),
      table_id: table_id.into(),
      row_id: row_id.into(),
      row_set: row_set.into(),
      nonce: nonce.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPixelTableRowResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPixel> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Vec<i64>> = Some(Vec::new());
    let mut f_4: Option<Vec<i64>> = Some(Vec::new());
    let mut f_5: Option<TRowSet> = None;
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPixel::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_i64()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = i_prot.read_i64()?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPixelTableRowResult {
      pixel: f_1,
      vega_table_name: f_2,
      table_id: f_3,
      row_id: f_4,
      row_set: f_5,
      nonce: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPixelTableRowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pixel {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixel", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vega_table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("vega_table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.row_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_id", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPixelTableRowResult {
  fn default() -> Self {
    TPixelTableRowResult{
      pixel: None,
      vega_table_name: Some("".to_owned()),
      table_id: Some(Vec::new()),
      row_id: Some(Vec::new()),
      row_set: None,
      nonce: Some("".to_owned()),
    }
  }
}

//
// TRenderResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderResult {
  pub image: Option<Vec<u8>>,
  pub nonce: Option<String>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
  pub vega_metadata: Option<String>,
}

impl TRenderResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(image: F1, nonce: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5, vega_metadata: F6) -> TRenderResult where F1: Into<Option<Vec<u8>>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<String>> {
    TRenderResult {
      image: image.into(),
      nonce: nonce.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
      vega_metadata: vega_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderResult {
      image: f_1,
      nonce: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
      vega_metadata: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.image {
      o_prot.write_field_begin(&TFieldIdentifier::new("image", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vega_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("vega_metadata", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderResult {
  fn default() -> Self {
    TRenderResult{
      image: Some(Vec::new()),
      nonce: Some("".to_owned()),
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
      vega_metadata: Some("".to_owned()),
    }
  }
}

//
// TGpuSpecification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGpuSpecification {
  pub num_sm: Option<i32>,
  pub clock_frequency_k_hz: Option<i64>,
  pub memory: Option<i64>,
  pub compute_capability_major: Option<i16>,
  pub compute_capability_minor: Option<i16>,
}

impl TGpuSpecification {
  pub fn new<F1, F2, F3, F4, F5>(num_sm: F1, clock_frequency_k_hz: F2, memory: F3, compute_capability_major: F4, compute_capability_minor: F5) -> TGpuSpecification where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i16>>, F5: Into<Option<i16>> {
    TGpuSpecification {
      num_sm: num_sm.into(),
      clock_frequency_k_hz: clock_frequency_k_hz.into(),
      memory: memory.into(),
      compute_capability_major: compute_capability_major.into(),
      compute_capability_minor: compute_capability_minor.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGpuSpecification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i16> = Some(0);
    let mut f_5: Option<i16> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i16()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGpuSpecification {
      num_sm: f_1,
      clock_frequency_k_hz: f_2,
      memory: f_3,
      compute_capability_major: f_4,
      compute_capability_minor: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGpuSpecification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_sm {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_sm", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.clock_frequency_k_hz {
      o_prot.write_field_begin(&TFieldIdentifier::new("clock_frequency_kHz", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.memory {
      o_prot.write_field_begin(&TFieldIdentifier::new("memory", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.compute_capability_major {
      o_prot.write_field_begin(&TFieldIdentifier::new("compute_capability_major", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.compute_capability_minor {
      o_prot.write_field_begin(&TFieldIdentifier::new("compute_capability_minor", TType::I16, 5))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TGpuSpecification {
  fn default() -> Self {
    TGpuSpecification{
      num_sm: Some(0),
      clock_frequency_k_hz: Some(0),
      memory: Some(0),
      compute_capability_major: Some(0),
      compute_capability_minor: Some(0),
    }
  }
}

//
// THardwareInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THardwareInfo {
  pub num_gpu_hw: Option<i16>,
  pub num_cpu_hw: Option<i16>,
  pub num_gpu_allocated: Option<i16>,
  pub start_gpu: Option<i16>,
  pub host_name: Option<String>,
  pub gpu_info: Option<Vec<TGpuSpecification>>,
}

impl THardwareInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(num_gpu_hw: F1, num_cpu_hw: F2, num_gpu_allocated: F3, start_gpu: F4, host_name: F5, gpu_info: F6) -> THardwareInfo where F1: Into<Option<i16>>, F2: Into<Option<i16>>, F3: Into<Option<i16>>, F4: Into<Option<i16>>, F5: Into<Option<String>>, F6: Into<Option<Vec<TGpuSpecification>>> {
    THardwareInfo {
      num_gpu_hw: num_gpu_hw.into(),
      num_cpu_hw: num_cpu_hw.into(),
      num_gpu_allocated: num_gpu_allocated.into(),
      start_gpu: start_gpu.into(),
      host_name: host_name.into(),
      gpu_info: gpu_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THardwareInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i16> = Some(0);
    let mut f_2: Option<i16> = Some(0);
    let mut f_3: Option<i16> = Some(0);
    let mut f_4: Option<i16> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<Vec<TGpuSpecification>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i16()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TGpuSpecification> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = TGpuSpecification::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THardwareInfo {
      num_gpu_hw: f_1,
      num_cpu_hw: f_2,
      num_gpu_allocated: f_3,
      start_gpu: f_4,
      host_name: f_5,
      gpu_info: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THardwareInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_gpu_hw {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_gpu_hw", TType::I16, 1))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_cpu_hw {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_cpu_hw", TType::I16, 2))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_gpu_allocated {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_gpu_allocated", TType::I16, 3))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_gpu {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_gpu", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gpu_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("gpu_info", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for THardwareInfo {
  fn default() -> Self {
    THardwareInfo{
      num_gpu_hw: Some(0),
      num_cpu_hw: Some(0),
      num_gpu_allocated: Some(0),
      start_gpu: Some(0),
      host_name: Some("".to_owned()),
      gpu_info: Some(Vec::new()),
    }
  }
}

//
// TClusterHardwareInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TClusterHardwareInfo {
  pub hardware_info: Option<Vec<THardwareInfo>>,
}

impl TClusterHardwareInfo {
  pub fn new<F1>(hardware_info: F1) -> TClusterHardwareInfo where F1: Into<Option<Vec<THardwareInfo>>> {
    TClusterHardwareInfo {
      hardware_info: hardware_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TClusterHardwareInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<THardwareInfo>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<THardwareInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = THardwareInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TClusterHardwareInfo {
      hardware_info: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TClusterHardwareInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hardware_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("hardware_info", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TClusterHardwareInfo {
  fn default() -> Self {
    TClusterHardwareInfo{
      hardware_info: Some(Vec::new()),
    }
  }
}

//
// TMemoryData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMemoryData {
  pub slab: Option<i64>,
  pub start_page: Option<i32>,
  pub num_pages: Option<i64>,
  pub touch: Option<i32>,
  pub chunk_key: Option<Vec<i64>>,
  pub buffer_epoch: Option<i32>,
  pub is_free: Option<bool>,
}

impl TMemoryData {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(slab: F1, start_page: F2, num_pages: F3, touch: F4, chunk_key: F5, buffer_epoch: F6, is_free: F7) -> TMemoryData where F1: Into<Option<i64>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<i32>>, F5: Into<Option<Vec<i64>>>, F6: Into<Option<i32>>, F7: Into<Option<bool>> {
    TMemoryData {
      slab: slab.into(),
      start_page: start_page.into(),
      num_pages: num_pages.into(),
      touch: touch.into(),
      chunk_key: chunk_key.into(),
      buffer_epoch: buffer_epoch.into(),
      is_free: is_free.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMemoryData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<Vec<i64>> = Some(Vec::new());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_i64()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMemoryData {
      slab: f_1,
      start_page: f_2,
      num_pages: f_3,
      touch: f_4,
      chunk_key: f_5,
      buffer_epoch: f_6,
      is_free: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMemoryData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.slab {
      o_prot.write_field_begin(&TFieldIdentifier::new("slab", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_page {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_page", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_pages {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pages", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.touch {
      o_prot.write_field_begin(&TFieldIdentifier::new("touch", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.chunk_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("chunk_key", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.buffer_epoch {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffer_epoch", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_free {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_free", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMemoryData {
  fn default() -> Self {
    TMemoryData{
      slab: Some(0),
      start_page: Some(0),
      num_pages: Some(0),
      touch: Some(0),
      chunk_key: Some(Vec::new()),
      buffer_epoch: Some(0),
      is_free: Some(false),
    }
  }
}

//
// TNodeMemoryInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeMemoryInfo {
  pub host_name: Option<String>,
  pub page_size: Option<i64>,
  pub max_num_pages: Option<i64>,
  pub num_pages_allocated: Option<i64>,
  pub is_allocation_capped: Option<bool>,
  pub node_memory_data: Option<Vec<TMemoryData>>,
}

impl TNodeMemoryInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(host_name: F1, page_size: F2, max_num_pages: F3, num_pages_allocated: F4, is_allocation_capped: F5, node_memory_data: F6) -> TNodeMemoryInfo where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<bool>>, F6: Into<Option<Vec<TMemoryData>>> {
    TNodeMemoryInfo {
      host_name: host_name.into(),
      page_size: page_size.into(),
      max_num_pages: max_num_pages.into(),
      num_pages_allocated: num_pages_allocated.into(),
      is_allocation_capped: is_allocation_capped.into(),
      node_memory_data: node_memory_data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeMemoryInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<Vec<TMemoryData>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TMemoryData> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = TMemoryData::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TNodeMemoryInfo {
      host_name: f_1,
      page_size: f_2,
      max_num_pages: f_3,
      num_pages_allocated: f_4,
      is_allocation_capped: f_5,
      node_memory_data: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeMemoryInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("page_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_num_pages {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_num_pages", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_pages_allocated {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pages_allocated", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_allocation_capped {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_allocation_capped", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.node_memory_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_memory_data", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TNodeMemoryInfo {
  fn default() -> Self {
    TNodeMemoryInfo{
      host_name: Some("".to_owned()),
      page_size: Some(0),
      max_num_pages: Some(0),
      num_pages_allocated: Some(0),
      is_allocation_capped: Some(false),
      node_memory_data: Some(Vec::new()),
    }
  }
}

//
// TTableMeta
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableMeta {
  pub table_name: Option<String>,
  pub num_cols: Option<i64>,
  pub is_view: Option<bool>,
  pub is_replicated: Option<bool>,
  pub shard_count: Option<i64>,
  pub max_rows: Option<i64>,
  pub table_id: Option<i64>,
  pub max_table_id: Option<i64>,
  pub col_types: Option<Vec<common::TTypeInfo>>,
  pub col_names: Option<Vec<String>>,
}

impl TTableMeta {
  pub fn new<F1, F2, F4, F5, F6, F7, F8, F9, F10, F11>(table_name: F1, num_cols: F2, is_view: F4, is_replicated: F5, shard_count: F6, max_rows: F7, table_id: F8, max_table_id: F9, col_types: F10, col_names: F11) -> TTableMeta where F1: Into<Option<String>>, F2: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<i64>>, F10: Into<Option<Vec<common::TTypeInfo>>>, F11: Into<Option<Vec<String>>> {
    TTableMeta {
      table_name: table_name.into(),
      num_cols: num_cols.into(),
      is_view: is_view.into(),
      is_replicated: is_replicated.into(),
      shard_count: shard_count.into(),
      max_rows: max_rows.into(),
      table_id: table_id.into(),
      max_table_id: max_table_id.into(),
      col_types: col_types.into(),
      col_names: col_names.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableMeta> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<i64> = Some(0);
    let mut f_9: Option<i64> = Some(0);
    let mut f_10: Option<Vec<common::TTypeInfo>> = Some(Vec::new());
    let mut f_11: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common::TTypeInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = common::TTypeInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableMeta {
      table_name: f_1,
      num_cols: f_2,
      is_view: f_4,
      is_replicated: f_5,
      shard_count: f_6,
      max_rows: f_7,
      table_id: f_8,
      max_table_id: f_9,
      col_types: f_10,
      col_names: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableMeta");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_cols", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_view {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_view", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_replicated {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_replicated", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("shard_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_rows", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_table_id", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_types", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_names", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableMeta {
  fn default() -> Self {
    TTableMeta{
      table_name: Some("".to_owned()),
      num_cols: Some(0),
      is_view: Some(false),
      is_replicated: Some(false),
      shard_count: Some(0),
      max_rows: Some(0),
      table_id: Some(0),
      max_table_id: Some(0),
      col_types: Some(Vec::new()),
      col_names: Some(Vec::new()),
    }
  }
}

//
// TTableRefreshInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableRefreshInfo {
  pub update_type: Option<TTableRefreshUpdateType>,
  pub timing_type: Option<TTableRefreshTimingType>,
  pub start_date_time: Option<String>,
  pub interval_type: Option<TTableRefreshIntervalType>,
  pub interval_count: Option<i64>,
  pub last_refresh_time: Option<String>,
  pub next_refresh_time: Option<String>,
}

impl TTableRefreshInfo {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(update_type: F1, timing_type: F2, start_date_time: F3, interval_type: F4, interval_count: F5, last_refresh_time: F6, next_refresh_time: F7) -> TTableRefreshInfo where F1: Into<Option<TTableRefreshUpdateType>>, F2: Into<Option<TTableRefreshTimingType>>, F3: Into<Option<String>>, F4: Into<Option<TTableRefreshIntervalType>>, F5: Into<Option<i64>>, F6: Into<Option<String>>, F7: Into<Option<String>> {
    TTableRefreshInfo {
      update_type: update_type.into(),
      timing_type: timing_type.into(),
      start_date_time: start_date_time.into(),
      interval_type: interval_type.into(),
      interval_count: interval_count.into(),
      last_refresh_time: last_refresh_time.into(),
      next_refresh_time: next_refresh_time.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableRefreshInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTableRefreshUpdateType> = None;
    let mut f_2: Option<TTableRefreshTimingType> = None;
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<TTableRefreshIntervalType> = None;
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TTableRefreshUpdateType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TTableRefreshTimingType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TTableRefreshIntervalType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableRefreshInfo {
      update_type: f_1,
      timing_type: f_2,
      start_date_time: f_3,
      interval_type: f_4,
      interval_count: f_5,
      last_refresh_time: f_6,
      next_refresh_time: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableRefreshInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.update_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timing_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("timing_type", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_date_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_date_time", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.interval_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("interval_type", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.interval_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("interval_count", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_refresh_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("last_refresh_time", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_refresh_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("next_refresh_time", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableRefreshInfo {
  fn default() -> Self {
    TTableRefreshInfo{
      update_type: None,
      timing_type: None,
      start_date_time: Some("".to_owned()),
      interval_type: None,
      interval_count: Some(0),
      last_refresh_time: Some("".to_owned()),
      next_refresh_time: Some("".to_owned()),
    }
  }
}

//
// TTableDetails
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableDetails {
  pub row_desc: Option<TRowDescriptor>,
  pub fragment_size: Option<i64>,
  pub page_size: Option<i64>,
  pub max_rows: Option<i64>,
  pub view_sql: Option<String>,
  pub shard_count: Option<i64>,
  pub key_metainfo: Option<String>,
  pub is_temporary: Option<bool>,
  pub partition_detail: Option<TPartitionDetail>,
  pub table_type: Option<TTableType>,
  pub refresh_info: Option<TTableRefreshInfo>,
}

impl TTableDetails {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(row_desc: F1, fragment_size: F2, page_size: F3, max_rows: F4, view_sql: F5, shard_count: F6, key_metainfo: F7, is_temporary: F8, partition_detail: F9, table_type: F10, refresh_info: F11) -> TTableDetails where F1: Into<Option<TRowDescriptor>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<i64>>, F7: Into<Option<String>>, F8: Into<Option<bool>>, F9: Into<Option<TPartitionDetail>>, F10: Into<Option<TTableType>>, F11: Into<Option<TTableRefreshInfo>> {
    TTableDetails {
      row_desc: row_desc.into(),
      fragment_size: fragment_size.into(),
      page_size: page_size.into(),
      max_rows: max_rows.into(),
      view_sql: view_sql.into(),
      shard_count: shard_count.into(),
      key_metainfo: key_metainfo.into(),
      is_temporary: is_temporary.into(),
      partition_detail: partition_detail.into(),
      table_type: table_type.into(),
      refresh_info: refresh_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableDetails> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<TPartitionDetail> = None;
    let mut f_10: Option<TTableType> = None;
    let mut f_11: Option<TTableRefreshInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TPartitionDetail::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = TTableType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = TTableRefreshInfo::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableDetails {
      row_desc: f_1,
      fragment_size: f_2,
      page_size: f_3,
      max_rows: f_4,
      view_sql: f_5,
      shard_count: f_6,
      key_metainfo: f_7,
      is_temporary: f_8,
      partition_detail: f_9,
      table_type: f_10,
      refresh_info: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableDetails");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fragment_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("page_size", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_rows", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.view_sql {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_sql", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("shard_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.key_metainfo {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_metainfo", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_temporary {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_temporary", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_detail {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_detail", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_type", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.refresh_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("refresh_info", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableDetails {
  fn default() -> Self {
    TTableDetails{
      row_desc: Some(Vec::new()),
      fragment_size: Some(0),
      page_size: Some(0),
      max_rows: Some(0),
      view_sql: Some("".to_owned()),
      shard_count: Some(0),
      key_metainfo: Some("".to_owned()),
      is_temporary: Some(false),
      partition_detail: None,
      table_type: None,
      refresh_info: None,
    }
  }
}

//
// TColumnRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnRange {
  pub type_: Option<TExpressionRangeType>,
  pub col_id: Option<i32>,
  pub table_id: Option<i32>,
  pub has_nulls: Option<bool>,
  pub int_min: Option<i64>,
  pub int_max: Option<i64>,
  pub bucket: Option<i64>,
  pub fp_min: Option<OrderedFloat<f64>>,
  pub fp_max: Option<OrderedFloat<f64>>,
}

impl TColumnRange {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(type_: F1, col_id: F2, table_id: F3, has_nulls: F4, int_min: F5, int_max: F6, bucket: F7, fp_min: F8, fp_max: F9) -> TColumnRange where F1: Into<Option<TExpressionRangeType>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<bool>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<OrderedFloat<f64>>>, F9: Into<Option<OrderedFloat<f64>>> {
    TColumnRange {
      type_: type_.into(),
      col_id: col_id.into(),
      table_id: table_id.into(),
      has_nulls: has_nulls.into(),
      int_min: int_min.into(),
      int_max: int_max.into(),
      bucket: bucket.into(),
      fp_min: fp_min.into(),
      fp_max: fp_max.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TExpressionRangeType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_9: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TExpressionRangeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_8 = Some(val);
        },
        9 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnRange {
      type_: f_1,
      col_id: f_2,
      table_id: f_3,
      has_nulls: f_4,
      int_min: f_5,
      int_max: f_6,
      bucket: f_7,
      fp_min: f_8,
      fp_max: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.col_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.has_nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_nulls", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.int_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_min", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.int_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_max", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.bucket {
      o_prot.write_field_begin(&TFieldIdentifier::new("bucket", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fp_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("fp_min", TType::Double, 8))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fp_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("fp_max", TType::Double, 9))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnRange {
  fn default() -> Self {
    TColumnRange{
      type_: None,
      col_id: Some(0),
      table_id: Some(0),
      has_nulls: Some(false),
      int_min: Some(0),
      int_max: Some(0),
      bucket: Some(0),
      fp_min: Some(OrderedFloat::from(0.0)),
      fp_max: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// TDictionaryGeneration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDictionaryGeneration {
  pub dict_id: Option<i32>,
  pub entry_count: Option<i64>,
}

impl TDictionaryGeneration {
  pub fn new<F1, F2>(dict_id: F1, entry_count: F2) -> TDictionaryGeneration where F1: Into<Option<i32>>, F2: Into<Option<i64>> {
    TDictionaryGeneration {
      dict_id: dict_id.into(),
      entry_count: entry_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDictionaryGeneration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDictionaryGeneration {
      dict_id: f_1,
      entry_count: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDictionaryGeneration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.dict_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dict_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.entry_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("entry_count", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDictionaryGeneration {
  fn default() -> Self {
    TDictionaryGeneration{
      dict_id: Some(0),
      entry_count: Some(0),
    }
  }
}

//
// TTableGeneration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableGeneration {
  pub table_id: Option<i32>,
  pub tuple_count: Option<i64>,
  pub start_rowid: Option<i64>,
}

impl TTableGeneration {
  pub fn new<F1, F2, F3>(table_id: F1, tuple_count: F2, start_rowid: F3) -> TTableGeneration where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TTableGeneration {
      table_id: table_id.into(),
      tuple_count: tuple_count.into(),
      start_rowid: start_rowid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableGeneration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableGeneration {
      table_id: f_1,
      tuple_count: f_2,
      start_rowid: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableGeneration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.tuple_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_count", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_rowid {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_rowid", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableGeneration {
  fn default() -> Self {
    TTableGeneration{
      table_id: Some(0),
      tuple_count: Some(0),
      start_rowid: Some(0),
    }
  }
}

//
// TPendingQuery
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPendingQuery {
  pub id: Option<TQueryId>,
  pub column_ranges: Option<Vec<TColumnRange>>,
  pub dictionary_generations: Option<Vec<TDictionaryGeneration>>,
  pub table_generations: Option<Vec<TTableGeneration>>,
  pub parent_session_id: Option<TSessionId>,
}

impl TPendingQuery {
  pub fn new<F1, F2, F3, F4, F5>(id: F1, column_ranges: F2, dictionary_generations: F3, table_generations: F4, parent_session_id: F5) -> TPendingQuery where F1: Into<Option<TQueryId>>, F2: Into<Option<Vec<TColumnRange>>>, F3: Into<Option<Vec<TDictionaryGeneration>>>, F4: Into<Option<Vec<TTableGeneration>>>, F5: Into<Option<TSessionId>> {
    TPendingQuery {
      id: id.into(),
      column_ranges: column_ranges.into(),
      dictionary_generations: dictionary_generations.into(),
      table_generations: table_generations.into(),
      parent_session_id: parent_session_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPendingQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TQueryId> = Some(0);
    let mut f_2: Option<Vec<TColumnRange>> = Some(Vec::new());
    let mut f_3: Option<Vec<TDictionaryGeneration>> = Some(Vec::new());
    let mut f_4: Option<Vec<TTableGeneration>> = Some(Vec::new());
    let mut f_5: Option<TSessionId> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnRange> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = TColumnRange::read_from_in_protocol(i_prot)?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDictionaryGeneration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = TDictionaryGeneration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableGeneration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = TTableGeneration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPendingQuery {
      id: f_1,
      column_ranges: f_2,
      dictionary_generations: f_3,
      table_generations: f_4,
      parent_session_id: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPendingQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_ranges {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ranges", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dictionary_generations {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionary_generations", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_generations {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_generations", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("parent_session_id", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPendingQuery {
  fn default() -> Self {
    TPendingQuery{
      id: Some(0),
      column_ranges: Some(Vec::new()),
      dictionary_generations: Some(Vec::new()),
      table_generations: Some(Vec::new()),
      parent_session_id: Some("".to_owned()),
    }
  }
}

//
// TVarLen
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TVarLen {
  pub payload: Option<Vec<u8>>,
  pub is_null: Option<bool>,
}

impl TVarLen {
  pub fn new<F1, F2>(payload: F1, is_null: F2) -> TVarLen where F1: Into<Option<Vec<u8>>>, F2: Into<Option<bool>> {
    TVarLen {
      payload: payload.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TVarLen> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TVarLen {
      payload: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TVarLen");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.payload {
      o_prot.write_field_begin(&TFieldIdentifier::new("payload", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TVarLen {
  fn default() -> Self {
    TVarLen{
      payload: Some(Vec::new()),
      is_null: Some(false),
    }
  }
}

//
// TDataBlockPtr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDataBlockPtr {
  FixedLenData(Vec<u8>),
  VarLenData(Vec<TVarLen>),
}

impl TDataBlockPtr {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataBlockPtr> {
    let mut ret: Option<TDataBlockPtr> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TDataBlockPtr::FixedLenData(val));
          }
          received_field_count += 1;
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TVarLen> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = TVarLen::read_from_in_protocol(i_prot)?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          if ret.is_none() {
            ret = Some(TDataBlockPtr::VarLenData(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TDataBlockPtr"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TDataBlockPtr"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataBlockPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TDataBlockPtr::FixedLenData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("fixed_len_data", TType::String, 1))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TDataBlockPtr::VarLenData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("var_len_data", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, f.len() as i32))?;
        for e in f {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TInsertData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInsertData {
  pub db_id: Option<i32>,
  pub table_id: Option<i32>,
  pub column_ids: Option<Vec<i32>>,
  pub data: Option<Vec<TDataBlockPtr>>,
  pub num_rows: Option<i64>,
  pub is_default: Option<Vec<bool>>,
}

impl TInsertData {
  pub fn new<F1, F2, F3, F4, F5, F6>(db_id: F1, table_id: F2, column_ids: F3, data: F4, num_rows: F5, is_default: F6) -> TInsertData where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<i32>>>, F4: Into<Option<Vec<TDataBlockPtr>>>, F5: Into<Option<i64>>, F6: Into<Option<Vec<bool>>> {
    TInsertData {
      db_id: db_id.into(),
      table_id: table_id.into(),
      column_ids: column_ids.into(),
      data: data.into(),
      num_rows: num_rows.into(),
      is_default: is_default.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInsertData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<i32>> = Some(Vec::new());
    let mut f_4: Option<Vec<TDataBlockPtr>> = Some(Vec::new());
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<Vec<bool>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_i32()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDataBlockPtr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = TDataBlockPtr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = i_prot.read_bool()?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TInsertData {
      db_id: f_1,
      table_id: f_2,
      column_ids: f_3,
      data: f_4,
      num_rows: f_5,
      is_default: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TInsertData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ids", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.is_default {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_default", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TInsertData {
  fn default() -> Self {
    TInsertData{
      db_id: Some(0),
      table_id: Some(0),
      column_ids: Some(Vec::new()),
      data: Some(Vec::new()),
      num_rows: Some(0),
      is_default: Some(Vec::new()),
    }
  }
}

//
// TChunkData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TChunkData {
  DataBuffer(Vec<u8>),
  IndexBuffer(Vec<u8>),
}

impl TChunkData {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TChunkData> {
    let mut ret: Option<TChunkData> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TChunkData::DataBuffer(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TChunkData::IndexBuffer(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TChunkData"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TChunkData"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TChunkData");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TChunkData::DataBuffer(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("data_buffer", TType::String, 1))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TChunkData::IndexBuffer(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("index_buffer", TType::String, 2))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TInsertChunks
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInsertChunks {
  pub db_id: Option<i32>,
  pub table_id: Option<i32>,
  pub data: Option<Vec<TChunkData>>,
  pub valid_indices: Option<Vec<i64>>,
  pub num_rows: Option<i64>,
}

impl TInsertChunks {
  pub fn new<F1, F2, F3, F4, F5>(db_id: F1, table_id: F2, data: F3, valid_indices: F4, num_rows: F5) -> TInsertChunks where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<TChunkData>>>, F4: Into<Option<Vec<i64>>>, F5: Into<Option<i64>> {
    TInsertChunks {
      db_id: db_id.into(),
      table_id: table_id.into(),
      data: data.into(),
      valid_indices: valid_indices.into(),
      num_rows: num_rows.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInsertChunks> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<TChunkData>> = Some(Vec::new());
    let mut f_4: Option<Vec<i64>> = Some(Vec::new());
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TChunkData> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = TChunkData::read_from_in_protocol(i_prot)?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = i_prot.read_i64()?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TInsertChunks {
      db_id: f_1,
      table_id: f_2,
      data: f_3,
      valid_indices: f_4,
      num_rows: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TInsertChunks");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.valid_indices {
      o_prot.write_field_begin(&TFieldIdentifier::new("valid_indices", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TInsertChunks {
  fn default() -> Self {
    TInsertChunks{
      db_id: Some(0),
      table_id: Some(0),
      data: Some(Vec::new()),
      valid_indices: Some(Vec::new()),
      num_rows: Some(0),
    }
  }
}

//
// TPendingRenderQuery
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPendingRenderQuery {
  pub id: Option<TQueryId>,
}

impl TPendingRenderQuery {
  pub fn new<F1>(id: F1) -> TPendingRenderQuery where F1: Into<Option<TQueryId>> {
    TPendingRenderQuery {
      id: id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPendingRenderQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TQueryId> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPendingRenderQuery {
      id: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPendingRenderQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPendingRenderQuery {
  fn default() -> Self {
    TPendingRenderQuery{
      id: Some(0),
    }
  }
}

//
// TRenderParseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderParseResult {
  pub merge_type: Option<TMergeType>,
  pub node_id: Option<i32>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
}

impl TRenderParseResult {
  pub fn new<F1, F2, F3, F4, F5>(merge_type: F1, node_id: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5) -> TRenderParseResult where F1: Into<Option<TMergeType>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    TRenderParseResult {
      merge_type: merge_type.into(),
      node_id: node_id.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderParseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMergeType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMergeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderParseResult {
      merge_type: f_1,
      node_id: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderParseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.merge_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.node_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderParseResult {
  fn default() -> Self {
    TRenderParseResult{
      merge_type: None,
      node_id: Some(0),
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
    }
  }
}

//
// TRawRenderPassDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRawRenderPassDataResult {
  pub num_pixel_channels: Option<i32>,
  pub num_pixel_samples: Option<i32>,
  pub pixels: Option<Vec<u8>>,
  pub row_ids_a: Option<Vec<u8>>,
  pub row_ids_b: Option<Vec<u8>>,
  pub table_ids: Option<Vec<u8>>,
  pub accum_data: Option<Vec<u8>>,
  pub accum_depth: Option<i32>,
}

impl TRawRenderPassDataResult {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(num_pixel_channels: F1, num_pixel_samples: F2, pixels: F3, row_ids_a: F4, row_ids_b: F5, table_ids: F6, accum_data: F7, accum_depth: F8) -> TRawRenderPassDataResult where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<Vec<u8>>>, F7: Into<Option<Vec<u8>>>, F8: Into<Option<i32>> {
    TRawRenderPassDataResult {
      num_pixel_channels: num_pixel_channels.into(),
      num_pixel_samples: num_pixel_samples.into(),
      pixels: pixels.into(),
      row_ids_a: row_ids_a.into(),
      row_ids_b: row_ids_b.into(),
      table_ids: table_ids.into(),
      accum_data: accum_data.into(),
      accum_depth: accum_depth.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRawRenderPassDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<Vec<u8>> = Some(Vec::new());
    let mut f_7: Option<Vec<u8>> = Some(Vec::new());
    let mut f_8: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bytes()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRawRenderPassDataResult {
      num_pixel_channels: f_1,
      num_pixel_samples: f_2,
      pixels: f_3,
      row_ids_a: f_4,
      row_ids_b: f_5,
      table_ids: f_6,
      accum_data: f_7,
      accum_depth: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRawRenderPassDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_pixel_channels {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pixel_channels", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_pixel_samples {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pixel_samples", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pixels {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixels", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.row_ids_a {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_ids_A", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.row_ids_b {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_ids_B", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_ids", TType::String, 6))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.accum_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("accum_data", TType::String, 7))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.accum_depth {
      o_prot.write_field_begin(&TFieldIdentifier::new("accum_depth", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRawRenderPassDataResult {
  fn default() -> Self {
    TRawRenderPassDataResult{
      num_pixel_channels: Some(0),
      num_pixel_samples: Some(0),
      pixels: Some(Vec::new()),
      row_ids_a: Some(Vec::new()),
      row_ids_b: Some(Vec::new()),
      table_ids: Some(Vec::new()),
      accum_data: Some(Vec::new()),
      accum_depth: Some(0),
    }
  }
}

//
// TRawPixelData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRawPixelData {
  pub width: Option<i32>,
  pub height: Option<i32>,
  pub render_pass_map: Option<TRenderPassMap>,
}

impl TRawPixelData {
  pub fn new<F1, F2, F3>(width: F1, height: F2, render_pass_map: F3) -> TRawPixelData where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<TRenderPassMap>> {
    TRawPixelData {
      width: width.into(),
      height: height.into(),
      render_pass_map: render_pass_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRawPixelData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<TRenderPassMap> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, TRawRenderPassDataResult> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_30 = i_prot.read_i32()?;
            let map_val_31 = TRawRenderPassDataResult::read_from_in_protocol(i_prot)?;
            val.insert(map_key_30, map_val_31);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRawPixelData {
      width: f_1,
      height: f_2,
      render_pass_map: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRawPixelData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.width {
      o_prot.write_field_begin(&TFieldIdentifier::new("width", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.height {
      o_prot.write_field_begin(&TFieldIdentifier::new("height", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.render_pass_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_pass_map", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRawPixelData {
  fn default() -> Self {
    TRawPixelData{
      width: Some(0),
      height: Some(0),
      render_pass_map: Some(BTreeMap::new()),
    }
  }
}

//
// TRenderDatum
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderDatum {
  pub type_: Option<common::TDatumType>,
  pub cnt: Option<i32>,
  pub value: Option<Vec<u8>>,
}

impl TRenderDatum {
  pub fn new<F1, F2, F3>(type_: F1, cnt: F2, value: F3) -> TRenderDatum where F1: Into<Option<common::TDatumType>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>> {
    TRenderDatum {
      type_: type_.into(),
      cnt: cnt.into(),
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderDatum> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TDatumType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TDatumType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderDatum {
      type_: f_1,
      cnt: f_2,
      value: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderDatum");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cnt {
      o_prot.write_field_begin(&TFieldIdentifier::new("cnt", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderDatum {
  fn default() -> Self {
    TRenderDatum{
      type_: None,
      cnt: Some(0),
      value: Some(Vec::new()),
    }
  }
}

//
// TRenderStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderStepResult {
  pub merge_data: Option<TRenderAggDataMap>,
  pub raw_pixel_data: Option<TRawPixelData>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
}

impl TRenderStepResult {
  pub fn new<F1, F2, F3, F4, F5>(merge_data: F1, raw_pixel_data: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5) -> TRenderStepResult where F1: Into<Option<TRenderAggDataMap>>, F2: Into<Option<TRawPixelData>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    TRenderStepResult {
      merge_data: merge_data.into(),
      raw_pixel_data: raw_pixel_data.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRenderAggDataMap> = Some(BTreeMap::new());
    let mut f_2: Option<TRawPixelData> = None;
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_32 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_33: BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_34 = i_prot.read_string()?;
              let map_ident = i_prot.read_map_begin()?;
              let mut map_val_35: BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>> = BTreeMap::new();
              for _ in 0..map_ident.size {
                let map_key_36 = i_prot.read_string()?;
                let map_ident = i_prot.read_map_begin()?;
                let mut map_val_37: BTreeMap<String, Vec<TRenderDatum>> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_38 = i_prot.read_string()?;
                  let list_ident = i_prot.read_list_begin()?;
                  let mut map_val_39: Vec<TRenderDatum> = Vec::with_capacity(list_ident.size as usize);
                  for _ in 0..list_ident.size {
                    let list_elem_40 = TRenderDatum::read_from_in_protocol(i_prot)?;
                    map_val_39.push(list_elem_40);
                  }
                  i_prot.read_list_end()?;
                  map_val_37.insert(map_key_38, map_val_39);
                }
                i_prot.read_map_end()?;
                map_val_35.insert(map_key_36, map_val_37);
              }
              i_prot.read_map_end()?;
              map_val_33.insert(map_key_34, map_val_35);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_32, map_val_33);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TRawPixelData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderStepResult {
      merge_data: f_1,
      raw_pixel_data: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.merge_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_data", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
        for (k, v) in v {
          o_prot.write_string(k)?;
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
          for (k, v) in v {
            o_prot.write_string(k)?;
            o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
            for (k, v) in v {
              o_prot.write_string(k)?;
              o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
              for e in v {
                e.write_to_out_protocol(o_prot)?;
              }
              o_prot.write_list_end()?;
            }
            o_prot.write_map_end()?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raw_pixel_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("raw_pixel_data", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderStepResult {
  fn default() -> Self {
    TRenderStepResult{
      merge_data: Some(BTreeMap::new()),
      raw_pixel_data: None,
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
    }
  }
}

//
// TDatabasePermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatabasePermissions {
  pub create_: Option<bool>,
  pub delete_: Option<bool>,
  pub view_sql_editor_: Option<bool>,
  pub access_: Option<bool>,
}

impl TDatabasePermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, delete_: F2, view_sql_editor_: F3, access_: F4) -> TDatabasePermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TDatabasePermissions {
      create_: create_.into(),
      delete_: delete_.into(),
      view_sql_editor_: view_sql_editor_.into(),
      access_: access_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatabasePermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatabasePermissions {
      create_: f_1,
      delete_: f_2,
      view_sql_editor_: f_3,
      access_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatabasePermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.view_sql_editor_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_sql_editor_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.access_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("access_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatabasePermissions {
  fn default() -> Self {
    TDatabasePermissions{
      create_: Some(false),
      delete_: Some(false),
      view_sql_editor_: Some(false),
      access_: Some(false),
    }
  }
}

//
// TTablePermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTablePermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub select_: Option<bool>,
  pub insert_: Option<bool>,
  pub update_: Option<bool>,
  pub delete_: Option<bool>,
  pub truncate_: Option<bool>,
  pub alter_: Option<bool>,
}

impl TTablePermissions {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(create_: F1, drop_: F2, select_: F3, insert_: F4, update_: F5, delete_: F6, truncate_: F7, alter_: F8) -> TTablePermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    TTablePermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      select_: select_.into(),
      insert_: insert_.into(),
      update_: update_.into(),
      delete_: delete_.into(),
      truncate_: truncate_.into(),
      alter_: alter_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTablePermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTablePermissions {
      create_: f_1,
      drop_: f_2,
      select_: f_3,
      insert_: f_4,
      update_: f_5,
      delete_: f_6,
      truncate_: f_7,
      alter_: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTablePermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.select_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("select_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.insert_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.truncate_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("truncate_", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.alter_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("alter_", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTablePermissions {
  fn default() -> Self {
    TTablePermissions{
      create_: Some(false),
      drop_: Some(false),
      select_: Some(false),
      insert_: Some(false),
      update_: Some(false),
      delete_: Some(false),
      truncate_: Some(false),
      alter_: Some(false),
    }
  }
}

//
// TDashboardPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboardPermissions {
  pub create_: Option<bool>,
  pub delete_: Option<bool>,
  pub view_: Option<bool>,
  pub edit_: Option<bool>,
}

impl TDashboardPermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, delete_: F2, view_: F3, edit_: F4) -> TDashboardPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TDashboardPermissions {
      create_: create_.into(),
      delete_: delete_.into(),
      view_: view_.into(),
      edit_: edit_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboardPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboardPermissions {
      create_: f_1,
      delete_: f_2,
      view_: f_3,
      edit_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboardPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.view_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.edit_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("edit_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboardPermissions {
  fn default() -> Self {
    TDashboardPermissions{
      create_: Some(false),
      delete_: Some(false),
      view_: Some(false),
      edit_: Some(false),
    }
  }
}

//
// TViewPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TViewPermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub select_: Option<bool>,
  pub insert_: Option<bool>,
  pub update_: Option<bool>,
  pub delete_: Option<bool>,
}

impl TViewPermissions {
  pub fn new<F1, F2, F3, F4, F5, F6>(create_: F1, drop_: F2, select_: F3, insert_: F4, update_: F5, delete_: F6) -> TViewPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>> {
    TViewPermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      select_: select_.into(),
      insert_: insert_.into(),
      update_: update_.into(),
      delete_: delete_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TViewPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TViewPermissions {
      create_: f_1,
      drop_: f_2,
      select_: f_3,
      insert_: f_4,
      update_: f_5,
      delete_: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TViewPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.select_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("select_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.insert_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TViewPermissions {
  fn default() -> Self {
    TViewPermissions{
      create_: Some(false),
      drop_: Some(false),
      select_: Some(false),
      insert_: Some(false),
      update_: Some(false),
      delete_: Some(false),
    }
  }
}

//
// TServerPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TServerPermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub alter_: Option<bool>,
  pub usage_: Option<bool>,
}

impl TServerPermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, drop_: F2, alter_: F3, usage_: F4) -> TServerPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TServerPermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      alter_: alter_.into(),
      usage_: usage_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TServerPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TServerPermissions {
      create_: f_1,
      drop_: f_2,
      alter_: f_3,
      usage_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TServerPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.alter_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("alter_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.usage_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("usage_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TServerPermissions {
  fn default() -> Self {
    TServerPermissions{
      create_: Some(false),
      drop_: Some(false),
      alter_: Some(false),
      usage_: Some(false),
    }
  }
}

//
// TDBObjectPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDBObjectPermissions {
  DatabasePermissions(TDatabasePermissions),
  TablePermissions(TTablePermissions),
  DashboardPermissions(TDashboardPermissions),
  ViewPermissions(TViewPermissions),
  ServerPermissions(TServerPermissions),
}

impl TDBObjectPermissions {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObjectPermissions> {
    let mut ret: Option<TDBObjectPermissions> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatabasePermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::DatabasePermissions(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TTablePermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::TablePermissions(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::DashboardPermissions(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TViewPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::ViewPermissions(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = TServerPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::ServerPermissions(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TDBObjectPermissions"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TDBObjectPermissions"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBObjectPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TDBObjectPermissions::DatabasePermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("database_permissions_", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::TablePermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("table_permissions_", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::DashboardPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_permissions_", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::ViewPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("view_permissions_", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::ServerPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("server_permissions_", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDBObject
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBObject {
  pub object_name: Option<String>,
  pub object_type: Option<TDBObjectType>,
  pub privs: Option<Vec<bool>>,
  pub grantee: Option<String>,
  pub privilege_object_type: Option<TDBObjectType>,
  pub object_id: Option<i32>,
}

impl TDBObject {
  pub fn new<F1, F2, F3, F4, F5, F6>(object_name: F1, object_type: F2, privs: F3, grantee: F4, privilege_object_type: F5, object_id: F6) -> TDBObject where F1: Into<Option<String>>, F2: Into<Option<TDBObjectType>>, F3: Into<Option<Vec<bool>>>, F4: Into<Option<String>>, F5: Into<Option<TDBObjectType>>, F6: Into<Option<i32>> {
    TDBObject {
      object_name: object_name.into(),
      object_type: object_type.into(),
      privs: privs.into(),
      grantee: grantee.into(),
      privilege_object_type: privilege_object_type.into(),
      object_id: object_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObject> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TDBObjectType> = None;
    let mut f_3: Option<Vec<bool>> = Some(Vec::new());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<TDBObjectType> = None;
    let mut f_6: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = i_prot.read_bool()?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBObject {
      object_name: f_1,
      object_type: f_2,
      privs: f_3,
      grantee: f_4,
      privilege_object_type: f_5,
      object_id: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBObject");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.object_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privs {
      o_prot.write_field_begin(&TFieldIdentifier::new("privs", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantee {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantee", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege_object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilegeObjectType", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.object_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectId", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBObject {
  fn default() -> Self {
    TDBObject{
      object_name: Some("".to_owned()),
      object_type: None,
      privs: Some(Vec::new()),
      grantee: Some("".to_owned()),
      privilege_object_type: None,
      object_id: Some(0),
    }
  }
}

//
// TDashboardGrantees
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboardGrantees {
  pub name: Option<String>,
  pub is_user: Option<bool>,
  pub permissions: Option<TDashboardPermissions>,
}

impl TDashboardGrantees {
  pub fn new<F1, F2, F3>(name: F1, is_user: F2, permissions: F3) -> TDashboardGrantees where F1: Into<Option<String>>, F2: Into<Option<bool>>, F3: Into<Option<TDashboardPermissions>> {
    TDashboardGrantees {
      name: name.into(),
      is_user: is_user.into(),
      permissions: permissions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboardGrantees> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboardGrantees {
      name: f_1,
      is_user: f_2,
      permissions: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboardGrantees");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_user {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_user", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.permissions {
      o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboardGrantees {
  fn default() -> Self {
    TDashboardGrantees{
      name: Some("".to_owned()),
      is_user: Some(false),
      permissions: None,
    }
  }
}

//
// TDashboard
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboard {
  pub dashboard_name: Option<String>,
  pub dashboard_state: Option<String>,
  pub image_hash: Option<String>,
  pub update_time: Option<String>,
  pub dashboard_metadata: Option<String>,
  pub dashboard_id: Option<i32>,
  pub dashboard_owner: Option<String>,
  pub is_dash_shared: Option<bool>,
  pub dashboard_permissions: Option<TDashboardPermissions>,
}

impl TDashboard {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(dashboard_name: F1, dashboard_state: F2, image_hash: F3, update_time: F4, dashboard_metadata: F5, dashboard_id: F6, dashboard_owner: F7, is_dash_shared: F8, dashboard_permissions: F9) -> TDashboard where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<String>>, F8: Into<Option<bool>>, F9: Into<Option<TDashboardPermissions>> {
    TDashboard {
      dashboard_name: dashboard_name.into(),
      dashboard_state: dashboard_state.into(),
      image_hash: image_hash.into(),
      update_time: update_time.into(),
      dashboard_metadata: dashboard_metadata.into(),
      dashboard_id: dashboard_id.into(),
      dashboard_owner: dashboard_owner.into(),
      is_dash_shared: is_dash_shared.into(),
      dashboard_permissions: dashboard_permissions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboard> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboard {
      dashboard_name: f_1,
      dashboard_state: f_2,
      image_hash: f_3,
      update_time: f_4,
      dashboard_metadata: f_5,
      dashboard_id: f_6,
      dashboard_owner: f_7,
      is_dash_shared: f_8,
      dashboard_permissions: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboard");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dashboard_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dashboard_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.image_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_time", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dashboard_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.dashboard_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dashboard_owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_owner", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_dash_shared {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_dash_shared", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dashboard_permissions {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_permissions", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboard {
  fn default() -> Self {
    TDashboard{
      dashboard_name: Some("".to_owned()),
      dashboard_state: Some("".to_owned()),
      image_hash: Some("".to_owned()),
      update_time: Some("".to_owned()),
      dashboard_metadata: Some("".to_owned()),
      dashboard_id: Some(0),
      dashboard_owner: Some("".to_owned()),
      is_dash_shared: Some(false),
      dashboard_permissions: None,
    }
  }
}

//
// TLicenseInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLicenseInfo {
  pub claims: Option<Vec<String>>,
}

impl TLicenseInfo {
  pub fn new<F1>(claims: F1) -> TLicenseInfo where F1: Into<Option<Vec<String>>> {
    TLicenseInfo {
      claims: claims.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLicenseInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_string()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TLicenseInfo {
      claims: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLicenseInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.claims {
      o_prot.write_field_begin(&TFieldIdentifier::new("claims", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TLicenseInfo {
  fn default() -> Self {
    TLicenseInfo{
      claims: Some(Vec::new()),
    }
  }
}

//
// TSessionInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSessionInfo {
  pub user: Option<String>,
  pub database: Option<String>,
  pub start_time: Option<i64>,
  pub is_super: Option<bool>,
}

impl TSessionInfo {
  pub fn new<F1, F2, F3, F4>(user: F1, database: F2, start_time: F3, is_super: F4) -> TSessionInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<bool>> {
    TSessionInfo {
      user: user.into(),
      database: database.into(),
      start_time: start_time.into(),
      is_super: is_super.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSessionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSessionInfo {
      user: f_1,
      database: f_2,
      start_time: f_3,
      is_super: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSessionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_time", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_super {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_super", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSessionInfo {
  fn default() -> Self {
    TSessionInfo{
      user: Some("".to_owned()),
      database: Some("".to_owned()),
      start_time: Some(0),
      is_super: Some(false),
    }
  }
}

//
// TGeoFileLayerInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGeoFileLayerInfo {
  pub name: Option<String>,
  pub contents: Option<TGeoFileLayerContents>,
}

impl TGeoFileLayerInfo {
  pub fn new<F1, F2>(name: F1, contents: F2) -> TGeoFileLayerInfo where F1: Into<Option<String>>, F2: Into<Option<TGeoFileLayerContents>> {
    TGeoFileLayerInfo {
      name: name.into(),
      contents: contents.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGeoFileLayerInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TGeoFileLayerContents> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TGeoFileLayerContents::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGeoFileLayerInfo {
      name: f_1,
      contents: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGeoFileLayerInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.contents {
      o_prot.write_field_begin(&TFieldIdentifier::new("contents", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TGeoFileLayerInfo {
  fn default() -> Self {
    TGeoFileLayerInfo{
      name: Some("".to_owned()),
      contents: None,
    }
  }
}

//
// TTableEpochInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableEpochInfo {
  pub table_id: Option<i32>,
  pub table_epoch: Option<i32>,
  pub leaf_index: Option<i32>,
}

impl TTableEpochInfo {
  pub fn new<F1, F2, F3>(table_id: F1, table_epoch: F2, leaf_index: F3) -> TTableEpochInfo where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<i32>> {
    TTableEpochInfo {
      table_id: table_id.into(),
      table_epoch: table_epoch.into(),
      leaf_index: leaf_index.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableEpochInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableEpochInfo {
      table_id: f_1,
      table_epoch: f_2,
      leaf_index: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableEpochInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.table_epoch {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_epoch", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.leaf_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("leaf_index", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableEpochInfo {
  fn default() -> Self {
    TTableEpochInfo{
      table_id: Some(0),
      table_epoch: Some(0),
      leaf_index: Some(0),
    }
  }
}

//
// TCustomExpression
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCustomExpression {
  pub id: Option<i32>,
  pub name: Option<String>,
  pub expression_json: Option<String>,
  pub data_source_type: Option<TDataSourceType>,
  pub data_source_id: Option<i32>,
  pub is_deleted: Option<bool>,
  pub data_source_name: Option<String>,
}

impl TCustomExpression {
  pub fn new<F1, F2, F4, F5, F6, F7, F8>(id: F1, name: F2, expression_json: F4, data_source_type: F5, data_source_id: F6, is_deleted: F7, data_source_name: F8) -> TCustomExpression where F1: Into<Option<i32>>, F2: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<TDataSourceType>>, F6: Into<Option<i32>>, F7: Into<Option<bool>>, F8: Into<Option<String>> {
    TCustomExpression {
      id: id.into(),
      name: name.into(),
      expression_json: expression_json.into(),
      data_source_type: data_source_type.into(),
      data_source_id: data_source_id.into(),
      is_deleted: is_deleted.into(),
      data_source_name: data_source_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCustomExpression> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<TDataSourceType> = None;
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDataSourceType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCustomExpression {
      id: f_1,
      name: f_2,
      expression_json: f_4,
      data_source_type: f_5,
      data_source_id: f_6,
      is_deleted: f_7,
      data_source_name: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCustomExpression");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expression_json {
      o_prot.write_field_begin(&TFieldIdentifier::new("expression_json", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_source_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_source_type", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.data_source_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_source_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_deleted {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_deleted", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_source_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_source_name", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCustomExpression {
  fn default() -> Self {
    TCustomExpression{
      id: Some(0),
      name: Some("".to_owned()),
      expression_json: Some("".to_owned()),
      data_source_type: None,
      data_source_id: Some(0),
      is_deleted: Some(false),
      data_source_name: Some("".to_owned()),
    }
  }
}

//
// TQueryInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryInfo {
  pub query_session_id: Option<String>,
  pub query_public_session_id: Option<String>,
  pub current_status: Option<String>,
  pub executor_id: Option<i32>,
  pub submitted: Option<String>,
  pub query_str: Option<String>,
  pub login_name: Option<String>,
  pub client_address: Option<String>,
  pub db_name: Option<String>,
  pub exec_device_type: Option<String>,
}

impl TQueryInfo {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(query_session_id: F1, query_public_session_id: F2, current_status: F3, executor_id: F4, submitted: F5, query_str: F6, login_name: F7, client_address: F8, db_name: F9, exec_device_type: F10) -> TQueryInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>> {
    TQueryInfo {
      query_session_id: query_session_id.into(),
      query_public_session_id: query_public_session_id.into(),
      current_status: current_status.into(),
      executor_id: executor_id.into(),
      submitted: submitted.into(),
      query_str: query_str.into(),
      login_name: login_name.into(),
      client_address: client_address.into(),
      db_name: db_name.into(),
      exec_device_type: exec_device_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TQueryInfo {
      query_session_id: f_1,
      query_public_session_id: f_2,
      current_status: f_3,
      executor_id: f_4,
      submitted: f_5,
      query_str: f_6,
      login_name: f_7,
      client_address: f_8,
      db_name: f_9,
      exec_device_type: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueryInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.query_session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_session_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_public_session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_public_session_id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_status", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.executor_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("executor_id", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.submitted {
      o_prot.write_field_begin(&TFieldIdentifier::new("submitted", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_str", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.login_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("login_name", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("client_address", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.exec_device_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("exec_device_type", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TQueryInfo {
  fn default() -> Self {
    TQueryInfo{
      query_session_id: Some("".to_owned()),
      query_public_session_id: Some("".to_owned()),
      current_status: Some("".to_owned()),
      executor_id: Some(0),
      submitted: Some("".to_owned()),
      query_str: Some("".to_owned()),
      login_name: Some("".to_owned()),
      client_address: Some("".to_owned()),
      db_name: Some("".to_owned()),
      exec_device_type: Some("".to_owned()),
    }
  }
}

//
// TLeafInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLeafInfo {
  pub leaf_id: Option<i32>,
  pub num_leaves: Option<i32>,
}

impl TLeafInfo {
  pub fn new<F1, F2>(leaf_id: F1, num_leaves: F2) -> TLeafInfo where F1: Into<Option<i32>>, F2: Into<Option<i32>> {
    TLeafInfo {
      leaf_id: leaf_id.into(),
      num_leaves: num_leaves.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLeafInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TLeafInfo {
      leaf_id: f_1,
      num_leaves: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLeafInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.leaf_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("leaf_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_leaves {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_leaves", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TLeafInfo {
  fn default() -> Self {
    TLeafInfo{
      leaf_id: Some(0),
      num_leaves: Some(0),
    }
  }
}

//
// Heavy service client
//

pub trait THeavySyncClient {
  fn connect(&mut self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId>;
  fn krb5_connect(&mut self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session>;
  fn disconnect(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn switch_database(&mut self, session: TSessionId, dbname: String) -> thrift::Result<()>;
  fn clone_session(&mut self, session: TSessionId) -> thrift::Result<TSessionId>;
  fn get_server_status(&mut self, session: TSessionId) -> thrift::Result<TServerStatus>;
  fn get_status(&mut self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>>;
  fn get_hardware_info(&mut self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo>;
  fn get_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_tables_for_database(&mut self, session: TSessionId, database_name: String) -> thrift::Result<Vec<String>>;
  fn get_physical_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_views(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_tables_meta(&mut self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>>;
  fn get_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn get_table_details_for_database(&mut self, session: TSessionId, table_name: String, database_name: String) -> thrift::Result<TTableDetails>;
  fn get_internal_table_details(&mut self, session: TSessionId, table_name: String, include_system_columns: bool) -> thrift::Result<TTableDetails>;
  fn get_internal_table_details_for_database(&mut self, session: TSessionId, table_name: String, database_name: String) -> thrift::Result<TTableDetails>;
  fn get_users(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_databases(&mut self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>>;
  fn get_version(&mut self) -> thrift::Result<String>;
  fn start_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn stop_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn get_heap_profile(&mut self, session: TSessionId) -> thrift::Result<String>;
  fn get_memory(&mut self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>>;
  fn clear_cpu_memory(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn clear_gpu_memory(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn set_cur_session(&mut self, parent_session: TSessionId, leaf_session: TSessionId, start_time_str: String, label: String, for_running_query_kernel: bool) -> thrift::Result<()>;
  fn invalidate_cur_session(&mut self, parent_session: TSessionId, leaf_session: TSessionId, start_time_str: String, label: String, for_running_query_kernel: bool) -> thrift::Result<()>;
  fn set_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()>;
  fn set_table_epoch_by_name(&mut self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()>;
  fn get_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32>;
  fn get_table_epoch_by_name(&mut self, session: TSessionId, table_name: String) -> thrift::Result<i32>;
  fn get_table_epochs(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<Vec<TTableEpochInfo>>;
  fn set_table_epochs(&mut self, session: TSessionId, db_id: i32, table_epochs: Vec<TTableEpochInfo>) -> thrift::Result<()>;
  fn get_session_info(&mut self, session: TSessionId) -> thrift::Result<TSessionInfo>;
  fn get_queries_info(&mut self, session: TSessionId) -> thrift::Result<Vec<TQueryInfo>>;
  fn set_leaf_info(&mut self, session: TSessionId, leaf_info: TLeafInfo) -> thrift::Result<()>;
  fn sql_execute(&mut self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult>;
  fn sql_execute_df(&mut self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32, transport_method: TArrowTransport) -> thrift::Result<TDataFrame>;
  fn sql_execute_gdf(&mut self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn deallocate_df(&mut self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()>;
  fn interrupt(&mut self, query_session: TSessionId, interrupt_session: TSessionId) -> thrift::Result<()>;
  fn sql_validate(&mut self, session: TSessionId, query: String) -> thrift::Result<TRowDescriptor>;
  fn get_completion_hints(&mut self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>>;
  fn set_execution_mode(&mut self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()>;
  fn render_vega(&mut self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult>;
  fn get_result_row_for_pixel(&mut self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult>;
  fn create_custom_expression(&mut self, session: TSessionId, custom_expression: TCustomExpression) -> thrift::Result<i32>;
  fn get_custom_expressions(&mut self, session: TSessionId) -> thrift::Result<Vec<TCustomExpression>>;
  fn update_custom_expression(&mut self, session: TSessionId, id: i32, expression_json: String) -> thrift::Result<()>;
  fn delete_custom_expressions(&mut self, session: TSessionId, custom_expression_ids: Vec<i32>, do_soft_delete: bool) -> thrift::Result<()>;
  fn get_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard>;
  fn get_dashboards(&mut self, session: TSessionId) -> thrift::Result<Vec<TDashboard>>;
  fn create_dashboard(&mut self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32>;
  fn replace_dashboard(&mut self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()>;
  fn delete_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()>;
  fn share_dashboards(&mut self, session: TSessionId, dashboard_ids: Vec<i32>, groups: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn delete_dashboards(&mut self, session: TSessionId, dashboard_ids: Vec<i32>) -> thrift::Result<()>;
  fn share_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()>;
  fn unshare_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn unshare_dashboards(&mut self, session: TSessionId, dashboard_ids: Vec<i32>, groups: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn get_dashboard_grantees(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>>;
  fn get_link_view(&mut self, session: TSessionId, link: String) -> thrift::Result<TFrontendView>;
  fn create_link(&mut self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String>;
  fn load_table_binary(&mut self, session: TSessionId, table_name: String, rows: Vec<TRow>, column_names: Vec<String>) -> thrift::Result<()>;
  fn load_table_binary_columnar(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>, column_names: Vec<String>) -> thrift::Result<()>;
  fn load_table_binary_columnar_polys(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>, column_names: Vec<String>, assign_render_groups: bool) -> thrift::Result<()>;
  fn load_table_binary_arrow(&mut self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>, use_column_names: bool) -> thrift::Result<()>;
  fn load_table(&mut self, session: TSessionId, table_name: String, rows: Vec<TStringRow>, column_names: Vec<String>) -> thrift::Result<()>;
  fn detect_column_types(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult>;
  fn create_table(&mut self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn import_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()>;
  fn import_geo_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn import_table_status(&mut self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus>;
  fn get_first_geo_file_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String>;
  fn get_all_files_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>>;
  fn get_layers_in_geo_file(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>>;
  fn query_get_outer_fragment_count(&mut self, session: TSessionId, query: String) -> thrift::Result<i64>;
  fn check_table_consistency(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta>;
  fn start_query(&mut self, leaf_session: TSessionId, parent_session: TSessionId, query_ra: String, start_time_str: String, just_explain: bool, outer_fragment_indices: Vec<i64>) -> thrift::Result<TPendingQuery>;
  fn execute_query_step(&mut self, pending_query: TPendingQuery, subquery_id: TSubqueryId, start_time_str: String) -> thrift::Result<TStepResult>;
  fn broadcast_serialized_rows(&mut self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId, subquery_id: TSubqueryId, is_final_subquery_result: bool) -> thrift::Result<()>;
  fn start_render_query(&mut self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery>;
  fn execute_next_render_step(&mut self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult>;
  fn insert_data(&mut self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()>;
  fn insert_chunks(&mut self, session: TSessionId, insert_chunks: TInsertChunks) -> thrift::Result<()>;
  fn checkpoint(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<()>;
  fn get_roles(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_db_objects_for_grantee(&mut self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>>;
  fn get_db_object_privs(&mut self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>>;
  fn get_all_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn get_all_effective_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn has_role(&mut self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool>;
  fn has_object_privilege(&mut self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool>;
  fn set_license_key(&mut self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn get_license_claims(&mut self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn get_device_parameters(&mut self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>>;
  fn register_runtime_extension_functions(&mut self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn get_table_function_names(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_runtime_table_function_names(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_table_function_details(&mut self, session: TSessionId, udtf_names: Vec<String>) -> thrift::Result<Vec<extension_functions::TUserDefinedTableFunction>>;
}

pub trait THeavySyncClientMarker {}

pub struct HeavySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> HeavySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> HeavySyncClient<IP, OP> {
    HeavySyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for HeavySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> THeavySyncClientMarker for HeavySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + THeavySyncClientMarker> THeavySyncClient for C {
  fn connect(&mut self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connect", TMessageType::Call, self.sequence_number());
        let call_args = HeavyConnectArgs { user, passwd, dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyConnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn krb5_connect(&mut self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Call, self.sequence_number());
        let call_args = HeavyKrb5ConnectArgs { input_token, dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("krb5_connect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyKrb5ConnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn disconnect(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Call, self.sequence_number());
        let call_args = HeavyDisconnectArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("disconnect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyDisconnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn switch_database(&mut self, session: TSessionId, dbname: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Call, self.sequence_number());
        let call_args = HeavySwitchDatabaseArgs { session, dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("switch_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySwitchDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clone_session(&mut self, session: TSessionId) -> thrift::Result<TSessionId> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCloneSessionArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clone_session", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCloneSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_server_status(&mut self, session: TSessionId) -> thrift::Result<TServerStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetServerStatusArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_server_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetServerStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_status(&mut self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_status", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetStatusArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_hardware_info(&mut self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetHardwareInfoArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_hardware_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetHardwareInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTablesArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables_for_database(&mut self, session: TSessionId, database_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables_for_database", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTablesForDatabaseArgs { session, database_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables_for_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTablesForDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_physical_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetPhysicalTablesArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_physical_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetPhysicalTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_views(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_views", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetViewsArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_views", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetViewsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables_meta(&mut self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTablesMetaArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables_meta", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTablesMetaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableDetailsArgs { session, table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_details_for_database(&mut self, session: TSessionId, table_name: String, database_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_details_for_database", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableDetailsForDatabaseArgs { session, table_name, database_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_details_for_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableDetailsForDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_internal_table_details(&mut self, session: TSessionId, table_name: String, include_system_columns: bool) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetInternalTableDetailsArgs { session, table_name, include_system_columns };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_internal_table_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetInternalTableDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_internal_table_details_for_database(&mut self, session: TSessionId, table_name: String, database_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_internal_table_details_for_database", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetInternalTableDetailsForDatabaseArgs { session, table_name, database_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_internal_table_details_for_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetInternalTableDetailsForDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_users(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_users", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetUsersArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_users", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetUsersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_databases(&mut self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDatabasesArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_databases", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDatabasesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_version(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_version", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetVersionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = HeavyStartHeapProfileArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyStartHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn stop_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = HeavyStopHeapProfileArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("stop_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyStopHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_heap_profile(&mut self, session: TSessionId) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetHeapProfileArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_memory(&mut self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetMemoryArgs { session, memory_level };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_cpu_memory(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Call, self.sequence_number());
        let call_args = HeavyClearCpuMemoryArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_cpu_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyClearCpuMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_gpu_memory(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Call, self.sequence_number());
        let call_args = HeavyClearGpuMemoryArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_gpu_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyClearGpuMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_cur_session(&mut self, parent_session: TSessionId, leaf_session: TSessionId, start_time_str: String, label: String, for_running_query_kernel: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_cur_session", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetCurSessionArgs { parent_session, leaf_session, start_time_str, label, for_running_query_kernel };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_cur_session", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetCurSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invalidate_cur_session(&mut self, parent_session: TSessionId, leaf_session: TSessionId, start_time_str: String, label: String, for_running_query_kernel: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("invalidate_cur_session", TMessageType::Call, self.sequence_number());
        let call_args = HeavyInvalidateCurSessionArgs { parent_session, leaf_session, start_time_str, label, for_running_query_kernel };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("invalidate_cur_session", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyInvalidateCurSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetTableEpochArgs { session, db_id, table_id, new_epoch };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epoch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetTableEpochResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epoch_by_name(&mut self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetTableEpochByNameArgs { session, table_name, new_epoch };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epoch_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetTableEpochByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableEpochArgs { session, db_id, table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epoch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableEpochResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epoch_by_name(&mut self, session: TSessionId, table_name: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableEpochByNameArgs { session, table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epoch_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableEpochByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epochs(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<Vec<TTableEpochInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epochs", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableEpochsArgs { session, db_id, table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epochs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableEpochsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epochs(&mut self, session: TSessionId, db_id: i32, table_epochs: Vec<TTableEpochInfo>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epochs", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetTableEpochsArgs { session, db_id, table_epochs };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epochs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetTableEpochsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_session_info(&mut self, session: TSessionId) -> thrift::Result<TSessionInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetSessionInfoArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_session_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetSessionInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_queries_info(&mut self, session: TSessionId) -> thrift::Result<Vec<TQueryInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_queries_info", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetQueriesInfoArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_queries_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetQueriesInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_leaf_info(&mut self, session: TSessionId, leaf_info: TLeafInfo) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_leaf_info", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetLeafInfoArgs { session, leaf_info };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_leaf_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetLeafInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute(&mut self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Call, self.sequence_number());
        let call_args = HeavySqlExecuteArgs { session, query, column_format, nonce, first_n, at_most_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySqlExecuteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute_df(&mut self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32, transport_method: TArrowTransport) -> thrift::Result<TDataFrame> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Call, self.sequence_number());
        let call_args = HeavySqlExecuteDfArgs { session, query, device_type, device_id, first_n, transport_method };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute_df", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySqlExecuteDfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute_gdf(&mut self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Call, self.sequence_number());
        let call_args = HeavySqlExecuteGdfArgs { session, query, device_id, first_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute_gdf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySqlExecuteGdfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn deallocate_df(&mut self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Call, self.sequence_number());
        let call_args = HeavyDeallocateDfArgs { session, df, device_type, device_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deallocate_df", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyDeallocateDfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn interrupt(&mut self, query_session: TSessionId, interrupt_session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Call, self.sequence_number());
        let call_args = HeavyInterruptArgs { query_session, interrupt_session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("interrupt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyInterruptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_validate(&mut self, session: TSessionId, query: String) -> thrift::Result<TRowDescriptor> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Call, self.sequence_number());
        let call_args = HeavySqlValidateArgs { session, query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_validate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySqlValidateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_completion_hints(&mut self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetCompletionHintsArgs { session, sql, cursor };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_completion_hints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetCompletionHintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_execution_mode(&mut self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetExecutionModeArgs { session, mode };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_execution_mode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetExecutionModeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn render_vega(&mut self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Call, self.sequence_number());
        let call_args = HeavyRenderVegaArgs { session, widget_id, vega_json, compression_level, nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("render_vega", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyRenderVegaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_result_row_for_pixel(&mut self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetResultRowForPixelArgs { session, widget_id, pixel, table_col_names, column_format, pixel_radius, nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_result_row_for_pixel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetResultRowForPixelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_custom_expression(&mut self, session: TSessionId, custom_expression: TCustomExpression) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_custom_expression", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCreateCustomExpressionArgs { session, custom_expression };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_custom_expression", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCreateCustomExpressionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_custom_expressions(&mut self, session: TSessionId) -> thrift::Result<Vec<TCustomExpression>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_custom_expressions", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetCustomExpressionsArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_custom_expressions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetCustomExpressionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_custom_expression(&mut self, session: TSessionId, id: i32, expression_json: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_custom_expression", TMessageType::Call, self.sequence_number());
        let call_args = HeavyUpdateCustomExpressionArgs { session, id, expression_json };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_custom_expression", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyUpdateCustomExpressionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_custom_expressions(&mut self, session: TSessionId, custom_expression_ids: Vec<i32>, do_soft_delete: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_custom_expressions", TMessageType::Call, self.sequence_number());
        let call_args = HeavyDeleteCustomExpressionsArgs { session, custom_expression_ids, do_soft_delete };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_custom_expressions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyDeleteCustomExpressionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDashboardArgs { session, dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboards(&mut self, session: TSessionId) -> thrift::Result<Vec<TDashboard>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDashboardsArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDashboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_dashboard(&mut self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCreateDashboardArgs { session, dashboard_name, dashboard_state, image_hash, dashboard_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCreateDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn replace_dashboard(&mut self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = HeavyReplaceDashboardArgs { session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("replace_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyReplaceDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = HeavyDeleteDashboardArgs { session, dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyDeleteDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn share_dashboards(&mut self, session: TSessionId, dashboard_ids: Vec<i32>, groups: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("share_dashboards", TMessageType::Call, self.sequence_number());
        let call_args = HeavyShareDashboardsArgs { session, dashboard_ids, groups, permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("share_dashboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyShareDashboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_dashboards(&mut self, session: TSessionId, dashboard_ids: Vec<i32>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_dashboards", TMessageType::Call, self.sequence_number());
        let call_args = HeavyDeleteDashboardsArgs { session, dashboard_ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_dashboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyDeleteDashboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn share_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = HeavyShareDashboardArgs { session, dashboard_id, groups, objects, permissions, grant_role };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("share_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyShareDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unshare_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = HeavyUnshareDashboardArgs { session, dashboard_id, groups, objects, permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unshare_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyUnshareDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unshare_dashboards(&mut self, session: TSessionId, dashboard_ids: Vec<i32>, groups: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unshare_dashboards", TMessageType::Call, self.sequence_number());
        let call_args = HeavyUnshareDashboardsArgs { session, dashboard_ids, groups, permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unshare_dashboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyUnshareDashboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboard_grantees(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDashboardGranteesArgs { session, dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboard_grantees", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDashboardGranteesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_link_view(&mut self, session: TSessionId, link: String) -> thrift::Result<TFrontendView> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetLinkViewArgs { session, link };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_link_view", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetLinkViewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_link(&mut self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_link", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCreateLinkArgs { session, view_state, view_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_link", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCreateLinkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary(&mut self, session: TSessionId, table_name: String, rows: Vec<TRow>, column_names: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Call, self.sequence_number());
        let call_args = HeavyLoadTableBinaryArgs { session, table_name, rows, column_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyLoadTableBinaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_columnar(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>, column_names: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Call, self.sequence_number());
        let call_args = HeavyLoadTableBinaryColumnarArgs { session, table_name, cols, column_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_columnar", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyLoadTableBinaryColumnarResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_columnar_polys(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>, column_names: Vec<String>, assign_render_groups: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar_polys", TMessageType::Call, self.sequence_number());
        let call_args = HeavyLoadTableBinaryColumnarPolysArgs { session, table_name, cols, column_names, assign_render_groups };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_columnar_polys", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyLoadTableBinaryColumnarPolysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_arrow(&mut self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>, use_column_names: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Call, self.sequence_number());
        let call_args = HeavyLoadTableBinaryArrowArgs { session, table_name, arrow_stream, use_column_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_arrow", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyLoadTableBinaryArrowResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table(&mut self, session: TSessionId, table_name: String, rows: Vec<TStringRow>, column_names: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table", TMessageType::Call, self.sequence_number());
        let call_args = HeavyLoadTableArgs { session, table_name, rows, column_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyLoadTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn detect_column_types(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Call, self.sequence_number());
        let call_args = HeavyDetectColumnTypesArgs { session, file_name, copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("detect_column_types", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyDetectColumnTypesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_table(&mut self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCreateTableArgs { session, table_name, row_desc, create_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCreateTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_table", TMessageType::Call, self.sequence_number());
        let call_args = HeavyImportTableArgs { session, table_name, file_name, copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyImportTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_geo_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Call, self.sequence_number());
        let call_args = HeavyImportGeoTableArgs { session, table_name, file_name, copy_params, row_desc, create_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_geo_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyImportGeoTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_table_status(&mut self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Call, self.sequence_number());
        let call_args = HeavyImportTableStatusArgs { session, import_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_table_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyImportTableStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_first_geo_file_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetFirstGeoFileInArchiveArgs { session, archive_path, copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_first_geo_file_in_archive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetFirstGeoFileInArchiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_files_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetAllFilesInArchiveArgs { session, archive_path, copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_files_in_archive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetAllFilesInArchiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_layers_in_geo_file(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetLayersInGeoFileArgs { session, file_name, copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_layers_in_geo_file", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetLayersInGeoFileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn query_get_outer_fragment_count(&mut self, session: TSessionId, query: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Call, self.sequence_number());
        let call_args = HeavyQueryGetOuterFragmentCountArgs { session, query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("query_get_outer_fragment_count", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyQueryGetOuterFragmentCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_table_consistency(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCheckTableConsistencyArgs { session, table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("check_table_consistency", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCheckTableConsistencyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_query(&mut self, leaf_session: TSessionId, parent_session: TSessionId, query_ra: String, start_time_str: String, just_explain: bool, outer_fragment_indices: Vec<i64>) -> thrift::Result<TPendingQuery> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_query", TMessageType::Call, self.sequence_number());
        let call_args = HeavyStartQueryArgs { leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyStartQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_query_step(&mut self, pending_query: TPendingQuery, subquery_id: TSubqueryId, start_time_str: String) -> thrift::Result<TStepResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Call, self.sequence_number());
        let call_args = HeavyExecuteQueryStepArgs { pending_query, subquery_id, start_time_str };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("execute_query_step", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyExecuteQueryStepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn broadcast_serialized_rows(&mut self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId, subquery_id: TSubqueryId, is_final_subquery_result: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Call, self.sequence_number());
        let call_args = HeavyBroadcastSerializedRowsArgs { serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("broadcast_serialized_rows", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyBroadcastSerializedRowsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_render_query(&mut self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Call, self.sequence_number());
        let call_args = HeavyStartRenderQueryArgs { session, widget_id, node_idx, vega_json };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_render_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyStartRenderQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_next_render_step(&mut self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Call, self.sequence_number());
        let call_args = HeavyExecuteNextRenderStepArgs { pending_render, merged_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("execute_next_render_step", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyExecuteNextRenderStepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_data(&mut self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Call, self.sequence_number());
        let call_args = HeavyInsertDataArgs { session, insert_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insert_data", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyInsertDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_chunks(&mut self, session: TSessionId, insert_chunks: TInsertChunks) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insert_chunks", TMessageType::Call, self.sequence_number());
        let call_args = HeavyInsertChunksArgs { session, insert_chunks };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insert_chunks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyInsertChunksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn checkpoint(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Call, self.sequence_number());
        let call_args = HeavyCheckpointArgs { session, table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkpoint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyCheckpointResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_roles(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetRolesArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_roles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetRolesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_db_objects_for_grantee(&mut self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDbObjectsForGranteeArgs { session, role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_db_objects_for_grantee", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDbObjectsForGranteeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_db_object_privs(&mut self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDbObjectPrivsArgs { session, object_name, type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_db_object_privs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDbObjectPrivsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetAllRolesForUserArgs { session, user_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_roles_for_user", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetAllRolesForUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_effective_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_effective_roles_for_user", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetAllEffectiveRolesForUserArgs { session, user_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_effective_roles_for_user", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetAllEffectiveRolesForUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_role(&mut self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_role", TMessageType::Call, self.sequence_number());
        let call_args = HeavyHasRoleArgs { session, grantee_name, role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyHasRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_object_privilege(&mut self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Call, self.sequence_number());
        let call_args = HeavyHasObjectPrivilegeArgs { session, grantee_name, object_name, object_type, permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_object_privilege", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyHasObjectPrivilegeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_license_key(&mut self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Call, self.sequence_number());
        let call_args = HeavySetLicenseKeyArgs { session, key, nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_license_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavySetLicenseKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_license_claims(&mut self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetLicenseClaimsArgs { session, nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_license_claims", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetLicenseClaimsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_device_parameters(&mut self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetDeviceParametersArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_device_parameters", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetDeviceParametersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_runtime_extension_functions(&mut self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Call, self.sequence_number());
        let call_args = HeavyRegisterRuntimeExtensionFunctionsArgs { session, udfs, udtfs, device_ir_map };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("register_runtime_extension_functions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyRegisterRuntimeExtensionFunctionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_function_names(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_function_names", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableFunctionNamesArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_function_names", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableFunctionNamesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_runtime_table_function_names(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_runtime_table_function_names", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetRuntimeTableFunctionNamesArgs { session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_runtime_table_function_names", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetRuntimeTableFunctionNamesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_function_details(&mut self, session: TSessionId, udtf_names: Vec<String>) -> thrift::Result<Vec<extension_functions::TUserDefinedTableFunction>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_function_details", TMessageType::Call, self.sequence_number());
        let call_args = HeavyGetTableFunctionDetailsArgs { session, udtf_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_function_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = HeavyGetTableFunctionDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// Heavy service processor
//

pub trait HeavySyncHandler {
  fn handle_connect(&self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId>;
  fn handle_krb5_connect(&self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session>;
  fn handle_disconnect(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_switch_database(&self, session: TSessionId, dbname: String) -> thrift::Result<()>;
  fn handle_clone_session(&self, session: TSessionId) -> thrift::Result<TSessionId>;
  fn handle_get_server_status(&self, session: TSessionId) -> thrift::Result<TServerStatus>;
  fn handle_get_status(&self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>>;
  fn handle_get_hardware_info(&self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo>;
  fn handle_get_tables(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_tables_for_database(&self, session: TSessionId, database_name: String) -> thrift::Result<Vec<String>>;
  fn handle_get_physical_tables(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_views(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_tables_meta(&self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>>;
  fn handle_get_table_details(&self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_table_details_for_database(&self, session: TSessionId, table_name: String, database_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_internal_table_details(&self, session: TSessionId, table_name: String, include_system_columns: bool) -> thrift::Result<TTableDetails>;
  fn handle_get_internal_table_details_for_database(&self, session: TSessionId, table_name: String, database_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_users(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_databases(&self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>>;
  fn handle_get_version(&self) -> thrift::Result<String>;
  fn handle_start_heap_profile(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_stop_heap_profile(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_get_heap_profile(&self, session: TSessionId) -> thrift::Result<String>;
  fn handle_get_memory(&self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>>;
  fn handle_clear_cpu_memory(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_clear_gpu_memory(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_set_cur_session(&self, parent_session: TSessionId, leaf_session: TSessionId, start_time_str: String, label: String, for_running_query_kernel: bool) -> thrift::Result<()>;
  fn handle_invalidate_cur_session(&self, parent_session: TSessionId, leaf_session: TSessionId, start_time_str: String, label: String, for_running_query_kernel: bool) -> thrift::Result<()>;
  fn handle_set_table_epoch(&self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()>;
  fn handle_set_table_epoch_by_name(&self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()>;
  fn handle_get_table_epoch(&self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32>;
  fn handle_get_table_epoch_by_name(&self, session: TSessionId, table_name: String) -> thrift::Result<i32>;
  fn handle_get_table_epochs(&self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<Vec<TTableEpochInfo>>;
  fn handle_set_table_epochs(&self, session: TSessionId, db_id: i32, table_epochs: Vec<TTableEpochInfo>) -> thrift::Result<()>;
  fn handle_get_session_info(&self, session: TSessionId) -> thrift::Result<TSessionInfo>;
  fn handle_get_queries_info(&self, session: TSessionId) -> thrift::Result<Vec<TQueryInfo>>;
  fn handle_set_leaf_info(&self, session: TSessionId, leaf_info: TLeafInfo) -> thrift::Result<()>;
  fn handle_sql_execute(&self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult>;
  fn handle_sql_execute_df(&self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32, transport_method: TArrowTransport) -> thrift::Result<TDataFrame>;
  fn handle_sql_execute_gdf(&self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn handle_deallocate_df(&self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()>;
  fn handle_interrupt(&self, query_session: TSessionId, interrupt_session: TSessionId) -> thrift::Result<()>;
  fn handle_sql_validate(&self, session: TSessionId, query: String) -> thrift::Result<TRowDescriptor>;
  fn handle_get_completion_hints(&self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>>;
  fn handle_set_execution_mode(&self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()>;
  fn handle_render_vega(&self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult>;
  fn handle_get_result_row_for_pixel(&self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult>;
  fn handle_create_custom_expression(&self, session: TSessionId, custom_expression: TCustomExpression) -> thrift::Result<i32>;
  fn handle_get_custom_expressions(&self, session: TSessionId) -> thrift::Result<Vec<TCustomExpression>>;
  fn handle_update_custom_expression(&self, session: TSessionId, id: i32, expression_json: String) -> thrift::Result<()>;
  fn handle_delete_custom_expressions(&self, session: TSessionId, custom_expression_ids: Vec<i32>, do_soft_delete: bool) -> thrift::Result<()>;
  fn handle_get_dashboard(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard>;
  fn handle_get_dashboards(&self, session: TSessionId) -> thrift::Result<Vec<TDashboard>>;
  fn handle_create_dashboard(&self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32>;
  fn handle_replace_dashboard(&self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()>;
  fn handle_delete_dashboard(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()>;
  fn handle_share_dashboards(&self, session: TSessionId, dashboard_ids: Vec<i32>, groups: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn handle_delete_dashboards(&self, session: TSessionId, dashboard_ids: Vec<i32>) -> thrift::Result<()>;
  fn handle_share_dashboard(&self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()>;
  fn handle_unshare_dashboard(&self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn handle_unshare_dashboards(&self, session: TSessionId, dashboard_ids: Vec<i32>, groups: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn handle_get_dashboard_grantees(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>>;
  fn handle_get_link_view(&self, session: TSessionId, link: String) -> thrift::Result<TFrontendView>;
  fn handle_create_link(&self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String>;
  fn handle_load_table_binary(&self, session: TSessionId, table_name: String, rows: Vec<TRow>, column_names: Vec<String>) -> thrift::Result<()>;
  fn handle_load_table_binary_columnar(&self, session: TSessionId, table_name: String, cols: Vec<TColumn>, column_names: Vec<String>) -> thrift::Result<()>;
  fn handle_load_table_binary_columnar_polys(&self, session: TSessionId, table_name: String, cols: Vec<TColumn>, column_names: Vec<String>, assign_render_groups: bool) -> thrift::Result<()>;
  fn handle_load_table_binary_arrow(&self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>, use_column_names: bool) -> thrift::Result<()>;
  fn handle_load_table(&self, session: TSessionId, table_name: String, rows: Vec<TStringRow>, column_names: Vec<String>) -> thrift::Result<()>;
  fn handle_detect_column_types(&self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult>;
  fn handle_create_table(&self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn handle_import_table(&self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()>;
  fn handle_import_geo_table(&self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn handle_import_table_status(&self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus>;
  fn handle_get_first_geo_file_in_archive(&self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String>;
  fn handle_get_all_files_in_archive(&self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>>;
  fn handle_get_layers_in_geo_file(&self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>>;
  fn handle_query_get_outer_fragment_count(&self, session: TSessionId, query: String) -> thrift::Result<i64>;
  fn handle_check_table_consistency(&self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta>;
  fn handle_start_query(&self, leaf_session: TSessionId, parent_session: TSessionId, query_ra: String, start_time_str: String, just_explain: bool, outer_fragment_indices: Vec<i64>) -> thrift::Result<TPendingQuery>;
  fn handle_execute_query_step(&self, pending_query: TPendingQuery, subquery_id: TSubqueryId, start_time_str: String) -> thrift::Result<TStepResult>;
  fn handle_broadcast_serialized_rows(&self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId, subquery_id: TSubqueryId, is_final_subquery_result: bool) -> thrift::Result<()>;
  fn handle_start_render_query(&self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery>;
  fn handle_execute_next_render_step(&self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult>;
  fn handle_insert_data(&self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()>;
  fn handle_insert_chunks(&self, session: TSessionId, insert_chunks: TInsertChunks) -> thrift::Result<()>;
  fn handle_checkpoint(&self, session: TSessionId, table_id: i32) -> thrift::Result<()>;
  fn handle_get_roles(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_db_objects_for_grantee(&self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>>;
  fn handle_get_db_object_privs(&self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>>;
  fn handle_get_all_roles_for_user(&self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn handle_get_all_effective_roles_for_user(&self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn handle_has_role(&self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool>;
  fn handle_has_object_privilege(&self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool>;
  fn handle_set_license_key(&self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn handle_get_license_claims(&self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn handle_get_device_parameters(&self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_register_runtime_extension_functions(&self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()>;
  fn handle_get_table_function_names(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_runtime_table_function_names(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_table_function_details(&self, session: TSessionId, udtf_names: Vec<String>) -> thrift::Result<Vec<extension_functions::TUserDefinedTableFunction>>;
}

pub struct HeavySyncProcessor<H: HeavySyncHandler> {
  handler: H,
}

impl <H: HeavySyncHandler> HeavySyncProcessor<H> {
  pub fn new(handler: H) -> HeavySyncProcessor<H> {
    HeavySyncProcessor {
      handler,
    }
  }
  fn process_connect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_connect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_krb5_connect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_krb5_connect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_disconnect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_disconnect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_switch_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_switch_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clone_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_clone_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_server_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_server_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_hardware_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_hardware_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables_for_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_tables_for_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_physical_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_physical_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_views(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_views(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables_meta(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_tables_meta(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_details_for_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_details_for_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_internal_table_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_internal_table_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_internal_table_details_for_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_internal_table_details_for_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_users(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_users(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_databases(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_databases(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_start_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_stop_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_stop_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_cpu_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_clear_cpu_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_gpu_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_clear_gpu_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_cur_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_cur_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invalidate_cur_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_invalidate_cur_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epoch(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_table_epoch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epoch_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_table_epoch_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epoch(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_epoch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epoch_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_epoch_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epochs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_epochs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epochs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_table_epochs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_session_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_session_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_queries_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_queries_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_leaf_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_leaf_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_sql_execute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute_df(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_sql_execute_df(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute_gdf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_sql_execute_gdf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_deallocate_df(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_deallocate_df(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_interrupt(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_interrupt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_validate(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_sql_validate(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_completion_hints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_completion_hints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_execution_mode(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_execution_mode(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_render_vega(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_render_vega(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_result_row_for_pixel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_result_row_for_pixel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_custom_expression(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_create_custom_expression(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_custom_expressions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_custom_expressions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_custom_expression(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_update_custom_expression(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_custom_expressions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_delete_custom_expressions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboards(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_dashboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_create_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_replace_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_replace_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_delete_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_share_dashboards(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_share_dashboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_dashboards(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_delete_dashboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_share_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_share_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unshare_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_unshare_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unshare_dashboards(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_unshare_dashboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboard_grantees(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_dashboard_grantees(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_link_view(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_link_view(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_link(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_create_link(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_load_table_binary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_columnar(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_load_table_binary_columnar(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_columnar_polys(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_load_table_binary_columnar_polys(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_arrow(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_load_table_binary_arrow(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_load_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_detect_column_types(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_detect_column_types(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_create_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_import_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_geo_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_import_geo_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_table_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_import_table_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_first_geo_file_in_archive(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_first_geo_file_in_archive(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_files_in_archive(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_all_files_in_archive(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_layers_in_geo_file(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_layers_in_geo_file(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_query_get_outer_fragment_count(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_query_get_outer_fragment_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_table_consistency(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_check_table_consistency(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_start_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_query_step(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_execute_query_step(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_broadcast_serialized_rows(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_broadcast_serialized_rows(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_render_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_start_render_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_next_render_step(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_execute_next_render_step(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_insert_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_chunks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_insert_chunks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_checkpoint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_checkpoint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_roles(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_roles(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_db_objects_for_grantee(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_db_objects_for_grantee(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_db_object_privs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_db_object_privs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_roles_for_user(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_all_roles_for_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_effective_roles_for_user(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_all_effective_roles_for_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_has_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_object_privilege(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_has_object_privilege(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_license_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_set_license_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_license_claims(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_license_claims(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_device_parameters(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_device_parameters(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_runtime_extension_functions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_register_runtime_extension_functions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_function_names(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_function_names(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_runtime_table_function_names(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_runtime_table_function_names(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_function_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    THeavyProcessFunctions::process_get_table_function_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct THeavyProcessFunctions;

impl THeavyProcessFunctions {
  pub fn process_connect<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyConnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connect(args.user, args.passwd, args.dbname) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyConnectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyConnectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_krb5_connect<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyKrb5ConnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_krb5_connect(args.input_token, args.dbname) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyKrb5ConnectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyKrb5ConnectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_disconnect<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyDisconnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_disconnect(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyDisconnectResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyDisconnectResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_switch_database<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySwitchDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_switch_database(args.session, args.dbname) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySwitchDatabaseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySwitchDatabaseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clone_session<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCloneSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clone_session(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCloneSessionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCloneSessionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_server_status<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetServerStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_server_status(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetServerStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetServerStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_status<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_status(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_hardware_info<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetHardwareInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_hardware_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetHardwareInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetHardwareInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTablesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTablesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables_for_database<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTablesForDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables_for_database(args.session, args.database_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables_for_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTablesForDatabaseResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTablesForDatabaseResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables_for_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables_for_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables_for_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables_for_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_physical_tables<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetPhysicalTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_physical_tables(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetPhysicalTablesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetPhysicalTablesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_views<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetViewsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_views(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_views", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetViewsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetViewsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_views", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables_meta<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTablesMetaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables_meta(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTablesMetaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTablesMetaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_details<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_details(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTableDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_details_for_database<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableDetailsForDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_details_for_database(args.session, args.table_name, args.database_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_details_for_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableDetailsForDatabaseResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTableDetailsForDatabaseResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_details_for_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_details_for_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_details_for_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_details_for_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_internal_table_details<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetInternalTableDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_internal_table_details(args.session, args.table_name, args.include_system_columns) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetInternalTableDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetInternalTableDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_internal_table_details_for_database<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetInternalTableDetailsForDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_internal_table_details_for_database(args.session, args.table_name, args.database_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_internal_table_details_for_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetInternalTableDetailsForDatabaseResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetInternalTableDetailsForDatabaseResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_internal_table_details_for_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_internal_table_details_for_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_internal_table_details_for_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_internal_table_details_for_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_users<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetUsersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_users(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_users", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetUsersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetUsersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_users", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_databases<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDatabasesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_databases(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDatabasesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDatabasesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_version<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = HeavyGetVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_version() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetVersionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetVersionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_heap_profile<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyStartHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_heap_profile(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyStartHeapProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyStartHeapProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_stop_heap_profile<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyStopHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_stop_heap_profile(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyStopHeapProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyStopHeapProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_heap_profile<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_heap_profile(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetHeapProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetHeapProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_memory<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_memory(args.session, args.memory_level) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetMemoryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetMemoryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_cpu_memory<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyClearCpuMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_cpu_memory(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyClearCpuMemoryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyClearCpuMemoryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_gpu_memory<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyClearGpuMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_gpu_memory(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyClearGpuMemoryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyClearGpuMemoryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_cur_session<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetCurSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_cur_session", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetCurSessionResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySetCurSessionResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_cur_session", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_cur_session", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_cur_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_cur_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invalidate_cur_session<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyInvalidateCurSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invalidate_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("invalidate_cur_session", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyInvalidateCurSessionResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyInvalidateCurSessionResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("invalidate_cur_session", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("invalidate_cur_session", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("invalidate_cur_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("invalidate_cur_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epoch<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetTableEpochArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetTableEpochResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySetTableEpochResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epoch_by_name<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetTableEpochByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epoch_by_name(args.session, args.table_name, args.new_epoch) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetTableEpochByNameResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySetTableEpochByNameResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epoch<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableEpochArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epoch(args.session, args.db_id, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableEpochResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epoch_by_name<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableEpochByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epoch_by_name(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableEpochByNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epochs<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableEpochsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epochs(args.session, args.db_id, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epochs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableEpochsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epochs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epochs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epochs<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetTableEpochsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epochs(args.session, args.db_id, args.table_epochs) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epochs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetTableEpochsResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epochs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epochs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_session_info<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetSessionInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_session_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetSessionInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetSessionInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_queries_info<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetQueriesInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_queries_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_queries_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetQueriesInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetQueriesInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_queries_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_queries_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_queries_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_queries_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_leaf_info<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetLeafInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_leaf_info(args.session, args.leaf_info) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_leaf_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetLeafInfoResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySetLeafInfoResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_leaf_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_leaf_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_leaf_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_leaf_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySqlExecuteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n, args.at_most_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySqlExecuteResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySqlExecuteResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute_df<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySqlExecuteDfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n, args.transport_method) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySqlExecuteDfResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySqlExecuteDfResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute_gdf<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySqlExecuteGdfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute_gdf(args.session, args.query, args.device_id, args.first_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySqlExecuteGdfResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySqlExecuteGdfResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_deallocate_df<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyDeallocateDfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_deallocate_df(args.session, args.df, args.device_type, args.device_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyDeallocateDfResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyDeallocateDfResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_interrupt<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyInterruptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_interrupt(args.query_session, args.interrupt_session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyInterruptResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyInterruptResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_validate<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySqlValidateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_validate(args.session, args.query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySqlValidateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySqlValidateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_completion_hints<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetCompletionHintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_completion_hints(args.session, args.sql, args.cursor) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetCompletionHintsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetCompletionHintsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_execution_mode<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetExecutionModeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_execution_mode(args.session, args.mode) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetExecutionModeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySetExecutionModeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_render_vega<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyRenderVegaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyRenderVegaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyRenderVegaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_result_row_for_pixel<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetResultRowForPixelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixel_radius, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetResultRowForPixelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetResultRowForPixelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_custom_expression<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCreateCustomExpressionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_custom_expression(args.session, args.custom_expression) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_custom_expression", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCreateCustomExpressionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCreateCustomExpressionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_custom_expression", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_custom_expression", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_custom_expression", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_custom_expression", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_custom_expressions<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetCustomExpressionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_custom_expressions(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_custom_expressions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetCustomExpressionsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetCustomExpressionsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_custom_expressions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_custom_expressions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_custom_expressions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_custom_expressions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_custom_expression<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyUpdateCustomExpressionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_custom_expression(args.session, args.id, args.expression_json) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_custom_expression", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyUpdateCustomExpressionResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyUpdateCustomExpressionResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_custom_expression", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_custom_expression", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_custom_expression", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_custom_expression", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_custom_expressions<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyDeleteCustomExpressionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_custom_expressions(args.session, args.custom_expression_ids, args.do_soft_delete) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("delete_custom_expressions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyDeleteCustomExpressionsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyDeleteCustomExpressionsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_custom_expressions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_custom_expressions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_custom_expressions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_custom_expressions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboard<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboard(args.session, args.dashboard_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDashboardResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDashboardResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboards<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDashboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboards(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDashboardsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDashboardsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_dashboard<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCreateDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_dashboard(args.session, args.dashboard_name, args.dashboard_state, args.image_hash, args.dashboard_metadata) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCreateDashboardResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCreateDashboardResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_replace_dashboard<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyReplaceDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_replace_dashboard(args.session, args.dashboard_id, args.dashboard_name, args.dashboard_owner, args.dashboard_state, args.image_hash, args.dashboard_metadata) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyReplaceDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyReplaceDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_dashboard<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyDeleteDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_dashboard(args.session, args.dashboard_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyDeleteDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyDeleteDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_share_dashboards<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyShareDashboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_share_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("share_dashboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyShareDashboardsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyShareDashboardsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("share_dashboards", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("share_dashboards", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("share_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("share_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_dashboards<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyDeleteDashboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_dashboards(args.session, args.dashboard_ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("delete_dashboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyDeleteDashboardsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyDeleteDashboardsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_dashboards", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_dashboards", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_share_dashboard<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyShareDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_share_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, args.grant_role) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyShareDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyShareDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unshare_dashboard<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyUnshareDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unshare_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyUnshareDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyUnshareDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unshare_dashboards<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyUnshareDashboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unshare_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unshare_dashboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyUnshareDashboardsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyUnshareDashboardsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unshare_dashboards", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("unshare_dashboards", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unshare_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unshare_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboard_grantees<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDashboardGranteesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboard_grantees(args.session, args.dashboard_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDashboardGranteesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDashboardGranteesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_link_view<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetLinkViewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_link_view(args.session, args.link) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetLinkViewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetLinkViewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_link<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCreateLinkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_link(args.session, args.view_state, args.view_metadata) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_link", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCreateLinkResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCreateLinkResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_link", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyLoadTableBinaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary(args.session, args.table_name, args.rows, args.column_names) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyLoadTableBinaryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyLoadTableBinaryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_columnar<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyLoadTableBinaryColumnarArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_columnar(args.session, args.table_name, args.cols, args.column_names) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyLoadTableBinaryColumnarResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyLoadTableBinaryColumnarResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_columnar_polys<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyLoadTableBinaryColumnarPolysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_columnar_polys(args.session, args.table_name, args.cols, args.column_names, args.assign_render_groups) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar_polys", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyLoadTableBinaryColumnarPolysResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyLoadTableBinaryColumnarPolysResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar_polys", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar_polys", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar_polys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar_polys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_arrow<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyLoadTableBinaryArrowArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_arrow(args.session, args.table_name, args.arrow_stream, args.use_column_names) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyLoadTableBinaryArrowResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyLoadTableBinaryArrowResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyLoadTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table(args.session, args.table_name, args.rows, args.column_names) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyLoadTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyLoadTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_detect_column_types<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyDetectColumnTypesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_detect_column_types(args.session, args.file_name, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyDetectColumnTypesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyDetectColumnTypesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_table<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCreateTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_table(args.session, args.table_name, args.row_desc, args.create_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCreateTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCreateTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_table<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyImportTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_table(args.session, args.table_name, args.file_name, args.copy_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("import_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyImportTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyImportTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_geo_table<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyImportGeoTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc, args.create_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyImportGeoTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyImportGeoTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_table_status<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyImportTableStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_table_status(args.session, args.import_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyImportTableStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyImportTableStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_first_geo_file_in_archive<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetFirstGeoFileInArchiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_first_geo_file_in_archive(args.session, args.archive_path, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetFirstGeoFileInArchiveResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetFirstGeoFileInArchiveResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_files_in_archive<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetAllFilesInArchiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_files_in_archive(args.session, args.archive_path, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetAllFilesInArchiveResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetAllFilesInArchiveResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_layers_in_geo_file<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetLayersInGeoFileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_layers_in_geo_file(args.session, args.file_name, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetLayersInGeoFileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetLayersInGeoFileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_query_get_outer_fragment_count<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyQueryGetOuterFragmentCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_query_get_outer_fragment_count(args.session, args.query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyQueryGetOuterFragmentCountResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyQueryGetOuterFragmentCountResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_table_consistency<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCheckTableConsistencyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_table_consistency(args.session, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCheckTableConsistencyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCheckTableConsistencyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_query<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyStartQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_query(args.leaf_session, args.parent_session, args.query_ra, args.start_time_str, args.just_explain, args.outer_fragment_indices) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("start_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyStartQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyStartQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_query_step<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyExecuteQueryStepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_query_step(args.pending_query, args.subquery_id, args.start_time_str) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyExecuteQueryStepResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyExecuteQueryStepResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_broadcast_serialized_rows<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyBroadcastSerializedRowsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id, args.subquery_id, args.is_final_subquery_result) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyBroadcastSerializedRowsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyBroadcastSerializedRowsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_render_query<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyStartRenderQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_render_query(args.session, args.widget_id, args.node_idx, args.vega_json) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyStartRenderQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyStartRenderQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_next_render_step<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyExecuteNextRenderStepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_next_render_step(args.pending_render, args.merged_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyExecuteNextRenderStepResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyExecuteNextRenderStepResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_data<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyInsertDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_data(args.session, args.insert_data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyInsertDataResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyInsertDataResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_chunks<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyInsertChunksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_chunks(args.session, args.insert_chunks) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("insert_chunks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyInsertChunksResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyInsertChunksResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("insert_chunks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("insert_chunks", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insert_chunks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insert_chunks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_checkpoint<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyCheckpointArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_checkpoint(args.session, args.table_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyCheckpointResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyCheckpointResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_roles<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetRolesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_roles(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetRolesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetRolesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_db_objects_for_grantee<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDbObjectsForGranteeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_db_objects_for_grantee(args.session, args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDbObjectsForGranteeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDbObjectsForGranteeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_db_object_privs<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDbObjectPrivsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_db_object_privs(args.session, args.object_name, args.type_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDbObjectPrivsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDbObjectPrivsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_roles_for_user<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetAllRolesForUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_roles_for_user(args.session, args.user_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetAllRolesForUserResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetAllRolesForUserResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_effective_roles_for_user<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetAllEffectiveRolesForUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_effective_roles_for_user(args.session, args.user_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_effective_roles_for_user", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetAllEffectiveRolesForUserResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetAllEffectiveRolesForUserResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_effective_roles_for_user", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_effective_roles_for_user", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_effective_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_effective_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_role<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyHasRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_role(args.session, args.grantee_name, args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyHasRoleResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyHasRoleResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("has_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_object_privilege<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyHasObjectPrivilegeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_object_privilege(args.session, args.grantee_name, args.object_name, args.object_type, args.permissions) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyHasObjectPrivilegeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyHasObjectPrivilegeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_license_key<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavySetLicenseKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_license_key(args.session, args.key, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavySetLicenseKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavySetLicenseKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_license_claims<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetLicenseClaimsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_license_claims(args.session, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetLicenseClaimsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetLicenseClaimsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_device_parameters<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetDeviceParametersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_device_parameters(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetDeviceParametersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetDeviceParametersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_runtime_extension_functions<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyRegisterRuntimeExtensionFunctionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_runtime_extension_functions(args.session, args.udfs, args.udtfs, args.device_ir_map) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyRegisterRuntimeExtensionFunctionsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyRegisterRuntimeExtensionFunctionsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_function_names<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableFunctionNamesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_function_names(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_function_names", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableFunctionNamesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTableFunctionNamesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_function_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_function_names", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_function_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_function_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_runtime_table_function_names<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetRuntimeTableFunctionNamesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_runtime_table_function_names(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_runtime_table_function_names", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetRuntimeTableFunctionNamesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetRuntimeTableFunctionNamesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_runtime_table_function_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_runtime_table_function_names", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_runtime_table_function_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_runtime_table_function_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_function_details<H: HeavySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = HeavyGetTableFunctionDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_function_details(args.session, args.udtf_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_function_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = HeavyGetTableFunctionDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TDBException>().is_some() {
              let err = usr_err.downcast::<TDBException>().expect("downcast already checked");
              let ret_err = HeavyGetTableFunctionDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_function_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_function_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_function_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_function_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: HeavySyncHandler> TProcessor for HeavySyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "connect" => {
        self.process_connect(message_ident.sequence_number, i_prot, o_prot)
      },
      "krb5_connect" => {
        self.process_krb5_connect(message_ident.sequence_number, i_prot, o_prot)
      },
      "disconnect" => {
        self.process_disconnect(message_ident.sequence_number, i_prot, o_prot)
      },
      "switch_database" => {
        self.process_switch_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "clone_session" => {
        self.process_clone_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_server_status" => {
        self.process_get_server_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_status" => {
        self.process_get_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_hardware_info" => {
        self.process_get_hardware_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables" => {
        self.process_get_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables_for_database" => {
        self.process_get_tables_for_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_physical_tables" => {
        self.process_get_physical_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_views" => {
        self.process_get_views(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables_meta" => {
        self.process_get_tables_meta(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_details" => {
        self.process_get_table_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_details_for_database" => {
        self.process_get_table_details_for_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_internal_table_details" => {
        self.process_get_internal_table_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_internal_table_details_for_database" => {
        self.process_get_internal_table_details_for_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_users" => {
        self.process_get_users(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_databases" => {
        self.process_get_databases(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_version" => {
        self.process_get_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_heap_profile" => {
        self.process_start_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "stop_heap_profile" => {
        self.process_stop_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_heap_profile" => {
        self.process_get_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_memory" => {
        self.process_get_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_cpu_memory" => {
        self.process_clear_cpu_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_gpu_memory" => {
        self.process_clear_gpu_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_cur_session" => {
        self.process_set_cur_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "invalidate_cur_session" => {
        self.process_invalidate_cur_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epoch" => {
        self.process_set_table_epoch(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epoch_by_name" => {
        self.process_set_table_epoch_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epoch" => {
        self.process_get_table_epoch(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epoch_by_name" => {
        self.process_get_table_epoch_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epochs" => {
        self.process_get_table_epochs(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epochs" => {
        self.process_set_table_epochs(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_session_info" => {
        self.process_get_session_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_queries_info" => {
        self.process_get_queries_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_leaf_info" => {
        self.process_set_leaf_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute" => {
        self.process_sql_execute(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute_df" => {
        self.process_sql_execute_df(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute_gdf" => {
        self.process_sql_execute_gdf(message_ident.sequence_number, i_prot, o_prot)
      },
      "deallocate_df" => {
        self.process_deallocate_df(message_ident.sequence_number, i_prot, o_prot)
      },
      "interrupt" => {
        self.process_interrupt(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_validate" => {
        self.process_sql_validate(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_completion_hints" => {
        self.process_get_completion_hints(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_execution_mode" => {
        self.process_set_execution_mode(message_ident.sequence_number, i_prot, o_prot)
      },
      "render_vega" => {
        self.process_render_vega(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_result_row_for_pixel" => {
        self.process_get_result_row_for_pixel(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_custom_expression" => {
        self.process_create_custom_expression(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_custom_expressions" => {
        self.process_get_custom_expressions(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_custom_expression" => {
        self.process_update_custom_expression(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_custom_expressions" => {
        self.process_delete_custom_expressions(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboard" => {
        self.process_get_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboards" => {
        self.process_get_dashboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_dashboard" => {
        self.process_create_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "replace_dashboard" => {
        self.process_replace_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_dashboard" => {
        self.process_delete_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "share_dashboards" => {
        self.process_share_dashboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_dashboards" => {
        self.process_delete_dashboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "share_dashboard" => {
        self.process_share_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "unshare_dashboard" => {
        self.process_unshare_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "unshare_dashboards" => {
        self.process_unshare_dashboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboard_grantees" => {
        self.process_get_dashboard_grantees(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_link_view" => {
        self.process_get_link_view(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_link" => {
        self.process_create_link(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary" => {
        self.process_load_table_binary(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_columnar" => {
        self.process_load_table_binary_columnar(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_columnar_polys" => {
        self.process_load_table_binary_columnar_polys(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_arrow" => {
        self.process_load_table_binary_arrow(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table" => {
        self.process_load_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "detect_column_types" => {
        self.process_detect_column_types(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_table" => {
        self.process_create_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_table" => {
        self.process_import_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_geo_table" => {
        self.process_import_geo_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_table_status" => {
        self.process_import_table_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_first_geo_file_in_archive" => {
        self.process_get_first_geo_file_in_archive(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_files_in_archive" => {
        self.process_get_all_files_in_archive(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_layers_in_geo_file" => {
        self.process_get_layers_in_geo_file(message_ident.sequence_number, i_prot, o_prot)
      },
      "query_get_outer_fragment_count" => {
        self.process_query_get_outer_fragment_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "check_table_consistency" => {
        self.process_check_table_consistency(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_query" => {
        self.process_start_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "execute_query_step" => {
        self.process_execute_query_step(message_ident.sequence_number, i_prot, o_prot)
      },
      "broadcast_serialized_rows" => {
        self.process_broadcast_serialized_rows(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_render_query" => {
        self.process_start_render_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "execute_next_render_step" => {
        self.process_execute_next_render_step(message_ident.sequence_number, i_prot, o_prot)
      },
      "insert_data" => {
        self.process_insert_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "insert_chunks" => {
        self.process_insert_chunks(message_ident.sequence_number, i_prot, o_prot)
      },
      "checkpoint" => {
        self.process_checkpoint(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_roles" => {
        self.process_get_roles(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_db_objects_for_grantee" => {
        self.process_get_db_objects_for_grantee(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_db_object_privs" => {
        self.process_get_db_object_privs(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_roles_for_user" => {
        self.process_get_all_roles_for_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_effective_roles_for_user" => {
        self.process_get_all_effective_roles_for_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_role" => {
        self.process_has_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_object_privilege" => {
        self.process_has_object_privilege(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_license_key" => {
        self.process_set_license_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_license_claims" => {
        self.process_get_license_claims(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_device_parameters" => {
        self.process_get_device_parameters(message_ident.sequence_number, i_prot, o_prot)
      },
      "register_runtime_extension_functions" => {
        self.process_register_runtime_extension_functions(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_function_names" => {
        self.process_get_table_function_names(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_runtime_table_function_names" => {
        self.process_get_runtime_table_function_names(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_function_details" => {
        self.process_get_table_function_details(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// HeavyConnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyConnectArgs {
  user: String,
  passwd: String,
  dbname: String,
}

impl HeavyConnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyConnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyConnectArgs.user", &f_1)?;
    verify_required_field_exists("HeavyConnectArgs.passwd", &f_2)?;
    verify_required_field_exists("HeavyConnectArgs.dbname", &f_3)?;
    let ret = HeavyConnectArgs {
      user: f_1.expect("auto-generated code should have checked for presence of required fields"),
      passwd: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("passwd", TType::String, 2))?;
    o_prot.write_string(&self.passwd)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 3))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyConnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyConnectResult {
  result_value: Option<TSessionId>,
  e: Option<TDBException>,
}

impl HeavyConnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyConnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionId> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyConnectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyConnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionId> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyConnect"
          )
        )
      )
    }
  }
}

//
// HeavyKrb5ConnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyKrb5ConnectArgs {
  input_token: String,
  dbname: String,
}

impl HeavyKrb5ConnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyKrb5ConnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyKrb5ConnectArgs.input_token", &f_1)?;
    verify_required_field_exists("HeavyKrb5ConnectArgs.dbname", &f_2)?;
    let ret = HeavyKrb5ConnectArgs {
      input_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("krb5_connect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("inputToken", TType::String, 1))?;
    o_prot.write_string(&self.input_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyKrb5ConnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyKrb5ConnectResult {
  result_value: Option<TKrb5Session>,
  e: Option<TDBException>,
}

impl HeavyKrb5ConnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyKrb5ConnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TKrb5Session> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TKrb5Session::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyKrb5ConnectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyKrb5ConnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TKrb5Session> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyKrb5Connect"
          )
        )
      )
    }
  }
}

//
// HeavyDisconnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDisconnectArgs {
  session: TSessionId,
}

impl HeavyDisconnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDisconnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyDisconnectArgs.session", &f_1)?;
    let ret = HeavyDisconnectArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("disconnect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyDisconnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDisconnectResult {
  e: Option<TDBException>,
}

impl HeavyDisconnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDisconnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyDisconnectResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyDisconnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavySwitchDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySwitchDatabaseArgs {
  session: TSessionId,
  dbname: String,
}

impl HeavySwitchDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySwitchDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySwitchDatabaseArgs.session", &f_1)?;
    verify_required_field_exists("HeavySwitchDatabaseArgs.dbname", &f_2)?;
    let ret = HeavySwitchDatabaseArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("switch_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySwitchDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySwitchDatabaseResult {
  e: Option<TDBException>,
}

impl HeavySwitchDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySwitchDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySwitchDatabaseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySwitchDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyCloneSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCloneSessionArgs {
  session: TSessionId,
}

impl HeavyCloneSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCloneSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCloneSessionArgs.session", &f_1)?;
    let ret = HeavyCloneSessionArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clone_session_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCloneSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCloneSessionResult {
  result_value: Option<TSessionId>,
  e: Option<TDBException>,
}

impl HeavyCloneSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCloneSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionId> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCloneSessionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCloneSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionId> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyCloneSession"
          )
        )
      )
    }
  }
}

//
// HeavyGetServerStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetServerStatusArgs {
  session: TSessionId,
}

impl HeavyGetServerStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetServerStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetServerStatusArgs.session", &f_1)?;
    let ret = HeavyGetServerStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_server_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetServerStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetServerStatusResult {
  result_value: Option<TServerStatus>,
  e: Option<TDBException>,
}

impl HeavyGetServerStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetServerStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TServerStatus> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TServerStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetServerStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetServerStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TServerStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetServerStatus"
          )
        )
      )
    }
  }
}

//
// HeavyGetStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetStatusArgs {
  session: TSessionId,
}

impl HeavyGetStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetStatusArgs.session", &f_1)?;
    let ret = HeavyGetStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetStatusResult {
  result_value: Option<Vec<TServerStatus>>,
  e: Option<TDBException>,
}

impl HeavyGetStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TServerStatus>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TServerStatus> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = TServerStatus::read_from_in_protocol(i_prot)?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TServerStatus>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetStatus"
          )
        )
      )
    }
  }
}

//
// HeavyGetHardwareInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetHardwareInfoArgs {
  session: TSessionId,
}

impl HeavyGetHardwareInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetHardwareInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetHardwareInfoArgs.session", &f_1)?;
    let ret = HeavyGetHardwareInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_hardware_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetHardwareInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetHardwareInfoResult {
  result_value: Option<TClusterHardwareInfo>,
  e: Option<TDBException>,
}

impl HeavyGetHardwareInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetHardwareInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TClusterHardwareInfo> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TClusterHardwareInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetHardwareInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetHardwareInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TClusterHardwareInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetHardwareInfo"
          )
        )
      )
    }
  }
}

//
// HeavyGetTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTablesArgs {
  session: TSessionId,
}

impl HeavyGetTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTablesArgs.session", &f_1)?;
    let ret = HeavyGetTablesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTablesResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = i_prot.read_string()?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTablesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTables"
          )
        )
      )
    }
  }
}

//
// HeavyGetTablesForDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTablesForDatabaseArgs {
  session: TSessionId,
  database_name: String,
}

impl HeavyGetTablesForDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTablesForDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTablesForDatabaseArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTablesForDatabaseArgs.database_name", &f_2)?;
    let ret = HeavyGetTablesForDatabaseArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      database_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_for_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("database_name", TType::String, 2))?;
    o_prot.write_string(&self.database_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTablesForDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTablesForDatabaseResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetTablesForDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTablesForDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = i_prot.read_string()?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTablesForDatabaseResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTablesForDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTablesForDatabase"
          )
        )
      )
    }
  }
}

//
// HeavyGetPhysicalTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetPhysicalTablesArgs {
  session: TSessionId,
}

impl HeavyGetPhysicalTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetPhysicalTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetPhysicalTablesArgs.session", &f_1)?;
    let ret = HeavyGetPhysicalTablesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_physical_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetPhysicalTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetPhysicalTablesResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetPhysicalTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetPhysicalTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = i_prot.read_string()?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetPhysicalTablesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetPhysicalTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetPhysicalTables"
          )
        )
      )
    }
  }
}

//
// HeavyGetViewsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetViewsArgs {
  session: TSessionId,
}

impl HeavyGetViewsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetViewsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetViewsArgs.session", &f_1)?;
    let ret = HeavyGetViewsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_views_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetViewsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetViewsResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetViewsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetViewsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = i_prot.read_string()?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetViewsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetViewsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetViews"
          )
        )
      )
    }
  }
}

//
// HeavyGetTablesMetaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTablesMetaArgs {
  session: TSessionId,
}

impl HeavyGetTablesMetaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTablesMetaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTablesMetaArgs.session", &f_1)?;
    let ret = HeavyGetTablesMetaArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_meta_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTablesMetaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTablesMetaResult {
  result_value: Option<Vec<TTableMeta>>,
  e: Option<TDBException>,
}

impl HeavyGetTablesMetaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTablesMetaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TTableMeta>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableMeta> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = TTableMeta::read_from_in_protocol(i_prot)?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTablesMetaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTablesMetaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TTableMeta>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTablesMeta"
          )
        )
      )
    }
  }
}

//
// HeavyGetTableDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableDetailsArgs {
  session: TSessionId,
  table_name: String,
}

impl HeavyGetTableDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableDetailsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTableDetailsArgs.table_name", &f_2)?;
    let ret = HeavyGetTableDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableDetailsResult {
  result_value: Option<TTableDetails>,
  e: Option<TDBException>,
}

impl HeavyGetTableDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableDetails"
          )
        )
      )
    }
  }
}

//
// HeavyGetTableDetailsForDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableDetailsForDatabaseArgs {
  session: TSessionId,
  table_name: String,
  database_name: String,
}

impl HeavyGetTableDetailsForDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableDetailsForDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableDetailsForDatabaseArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTableDetailsForDatabaseArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyGetTableDetailsForDatabaseArgs.database_name", &f_3)?;
    let ret = HeavyGetTableDetailsForDatabaseArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      database_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_details_for_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("database_name", TType::String, 3))?;
    o_prot.write_string(&self.database_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableDetailsForDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableDetailsForDatabaseResult {
  result_value: Option<TTableDetails>,
  e: Option<TDBException>,
}

impl HeavyGetTableDetailsForDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableDetailsForDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableDetailsForDatabaseResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableDetailsForDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableDetailsForDatabase"
          )
        )
      )
    }
  }
}

//
// HeavyGetInternalTableDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetInternalTableDetailsArgs {
  session: TSessionId,
  table_name: String,
  include_system_columns: bool,
}

impl HeavyGetInternalTableDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetInternalTableDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetInternalTableDetailsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetInternalTableDetailsArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyGetInternalTableDetailsArgs.include_system_columns", &f_3)?;
    let ret = HeavyGetInternalTableDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      include_system_columns: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_internal_table_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("include_system_columns", TType::Bool, 3))?;
    o_prot.write_bool(self.include_system_columns)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetInternalTableDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetInternalTableDetailsResult {
  result_value: Option<TTableDetails>,
  e: Option<TDBException>,
}

impl HeavyGetInternalTableDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetInternalTableDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetInternalTableDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetInternalTableDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetInternalTableDetails"
          )
        )
      )
    }
  }
}

//
// HeavyGetInternalTableDetailsForDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetInternalTableDetailsForDatabaseArgs {
  session: TSessionId,
  table_name: String,
  database_name: String,
}

impl HeavyGetInternalTableDetailsForDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetInternalTableDetailsForDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetInternalTableDetailsForDatabaseArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetInternalTableDetailsForDatabaseArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyGetInternalTableDetailsForDatabaseArgs.database_name", &f_3)?;
    let ret = HeavyGetInternalTableDetailsForDatabaseArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      database_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_internal_table_details_for_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("database_name", TType::String, 3))?;
    o_prot.write_string(&self.database_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetInternalTableDetailsForDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetInternalTableDetailsForDatabaseResult {
  result_value: Option<TTableDetails>,
  e: Option<TDBException>,
}

impl HeavyGetInternalTableDetailsForDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetInternalTableDetailsForDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetInternalTableDetailsForDatabaseResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetInternalTableDetailsForDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetInternalTableDetailsForDatabase"
          )
        )
      )
    }
  }
}

//
// HeavyGetUsersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetUsersArgs {
  session: TSessionId,
}

impl HeavyGetUsersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetUsersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetUsersArgs.session", &f_1)?;
    let ret = HeavyGetUsersArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_users_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetUsersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetUsersResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetUsersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetUsersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = i_prot.read_string()?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetUsersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetUsersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetUsers"
          )
        )
      )
    }
  }
}

//
// HeavyGetDatabasesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDatabasesArgs {
  session: TSessionId,
}

impl HeavyGetDatabasesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDatabasesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDatabasesArgs.session", &f_1)?;
    let ret = HeavyGetDatabasesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_databases_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDatabasesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDatabasesResult {
  result_value: Option<Vec<TDBInfo>>,
  e: Option<TDBException>,
}

impl HeavyGetDatabasesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDatabasesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBInfo>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = TDBInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDatabasesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDatabasesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDatabases"
          )
        )
      )
    }
  }
}

//
// HeavyGetVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetVersionArgs {
}

impl HeavyGetVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetVersionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetVersionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetVersionResult {
  result_value: Option<String>,
  e: Option<TDBException>,
}

impl HeavyGetVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetVersionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetVersion"
          )
        )
      )
    }
  }
}

//
// HeavyStartHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStartHeapProfileArgs {
  session: TSessionId,
}

impl HeavyStartHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStartHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyStartHeapProfileArgs.session", &f_1)?;
    let ret = HeavyStartHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyStartHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStartHeapProfileResult {
  e: Option<TDBException>,
}

impl HeavyStartHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStartHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyStartHeapProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyStartHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyStopHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStopHeapProfileArgs {
  session: TSessionId,
}

impl HeavyStopHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStopHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyStopHeapProfileArgs.session", &f_1)?;
    let ret = HeavyStopHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("stop_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyStopHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStopHeapProfileResult {
  e: Option<TDBException>,
}

impl HeavyStopHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStopHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyStopHeapProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyStopHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyGetHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetHeapProfileArgs {
  session: TSessionId,
}

impl HeavyGetHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetHeapProfileArgs.session", &f_1)?;
    let ret = HeavyGetHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetHeapProfileResult {
  result_value: Option<String>,
  e: Option<TDBException>,
}

impl HeavyGetHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetHeapProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetHeapProfile"
          )
        )
      )
    }
  }
}

//
// HeavyGetMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetMemoryArgs {
  session: TSessionId,
  memory_level: String,
}

impl HeavyGetMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetMemoryArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetMemoryArgs.memory_level", &f_2)?;
    let ret = HeavyGetMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      memory_level: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("memory_level", TType::String, 2))?;
    o_prot.write_string(&self.memory_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetMemoryResult {
  result_value: Option<Vec<TNodeMemoryInfo>>,
  e: Option<TDBException>,
}

impl HeavyGetMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TNodeMemoryInfo>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TNodeMemoryInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = TNodeMemoryInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetMemoryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TNodeMemoryInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetMemory"
          )
        )
      )
    }
  }
}

//
// HeavyClearCpuMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyClearCpuMemoryArgs {
  session: TSessionId,
}

impl HeavyClearCpuMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyClearCpuMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyClearCpuMemoryArgs.session", &f_1)?;
    let ret = HeavyClearCpuMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_cpu_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyClearCpuMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyClearCpuMemoryResult {
  e: Option<TDBException>,
}

impl HeavyClearCpuMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyClearCpuMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyClearCpuMemoryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyClearCpuMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyClearGpuMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyClearGpuMemoryArgs {
  session: TSessionId,
}

impl HeavyClearGpuMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyClearGpuMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyClearGpuMemoryArgs.session", &f_1)?;
    let ret = HeavyClearGpuMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_gpu_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyClearGpuMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyClearGpuMemoryResult {
  e: Option<TDBException>,
}

impl HeavyClearGpuMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyClearGpuMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyClearGpuMemoryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyClearGpuMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavySetCurSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetCurSessionArgs {
  parent_session: TSessionId,
  leaf_session: TSessionId,
  start_time_str: String,
  label: String,
  for_running_query_kernel: bool,
}

impl HeavySetCurSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetCurSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TSessionId> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetCurSessionArgs.parent_session", &f_1)?;
    verify_required_field_exists("HeavySetCurSessionArgs.leaf_session", &f_2)?;
    verify_required_field_exists("HeavySetCurSessionArgs.start_time_str", &f_3)?;
    verify_required_field_exists("HeavySetCurSessionArgs.label", &f_4)?;
    verify_required_field_exists("HeavySetCurSessionArgs.for_running_query_kernel", &f_5)?;
    let ret = HeavySetCurSessionArgs {
      parent_session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      leaf_session: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_time_str: f_3.expect("auto-generated code should have checked for presence of required fields"),
      label: f_4.expect("auto-generated code should have checked for presence of required fields"),
      for_running_query_kernel: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_cur_session_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parent_session", TType::String, 1))?;
    o_prot.write_string(&self.parent_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaf_session", TType::String, 2))?;
    o_prot.write_string(&self.leaf_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_time_str", TType::String, 3))?;
    o_prot.write_string(&self.start_time_str)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("label", TType::String, 4))?;
    o_prot.write_string(&self.label)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("for_running_query_kernel", TType::Bool, 5))?;
    o_prot.write_bool(self.for_running_query_kernel)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetCurSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetCurSessionResult {
  e: Option<TDBException>,
}

impl HeavySetCurSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetCurSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetCurSessionResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetCurSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyInvalidateCurSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInvalidateCurSessionArgs {
  parent_session: TSessionId,
  leaf_session: TSessionId,
  start_time_str: String,
  label: String,
  for_running_query_kernel: bool,
}

impl HeavyInvalidateCurSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInvalidateCurSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TSessionId> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyInvalidateCurSessionArgs.parent_session", &f_1)?;
    verify_required_field_exists("HeavyInvalidateCurSessionArgs.leaf_session", &f_2)?;
    verify_required_field_exists("HeavyInvalidateCurSessionArgs.start_time_str", &f_3)?;
    verify_required_field_exists("HeavyInvalidateCurSessionArgs.label", &f_4)?;
    verify_required_field_exists("HeavyInvalidateCurSessionArgs.for_running_query_kernel", &f_5)?;
    let ret = HeavyInvalidateCurSessionArgs {
      parent_session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      leaf_session: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_time_str: f_3.expect("auto-generated code should have checked for presence of required fields"),
      label: f_4.expect("auto-generated code should have checked for presence of required fields"),
      for_running_query_kernel: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("invalidate_cur_session_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parent_session", TType::String, 1))?;
    o_prot.write_string(&self.parent_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaf_session", TType::String, 2))?;
    o_prot.write_string(&self.leaf_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_time_str", TType::String, 3))?;
    o_prot.write_string(&self.start_time_str)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("label", TType::String, 4))?;
    o_prot.write_string(&self.label)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("for_running_query_kernel", TType::Bool, 5))?;
    o_prot.write_bool(self.for_running_query_kernel)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyInvalidateCurSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInvalidateCurSessionResult {
  e: Option<TDBException>,
}

impl HeavyInvalidateCurSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInvalidateCurSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyInvalidateCurSessionResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyInvalidateCurSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavySetTableEpochArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetTableEpochArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
  new_epoch: i32,
}

impl HeavySetTableEpochArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetTableEpochArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetTableEpochArgs.session", &f_1)?;
    verify_required_field_exists("HeavySetTableEpochArgs.db_id", &f_2)?;
    verify_required_field_exists("HeavySetTableEpochArgs.table_id", &f_3)?;
    verify_required_field_exists("HeavySetTableEpochArgs.new_epoch", &f_4)?;
    let ret = HeavySetTableEpochArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      new_epoch: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epoch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_epoch", TType::I32, 4))?;
    o_prot.write_i32(self.new_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetTableEpochResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetTableEpochResult {
  e: Option<TDBException>,
}

impl HeavySetTableEpochResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetTableEpochResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetTableEpochResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetTableEpochResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavySetTableEpochByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetTableEpochByNameArgs {
  session: TSessionId,
  table_name: String,
  new_epoch: i32,
}

impl HeavySetTableEpochByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetTableEpochByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetTableEpochByNameArgs.session", &f_1)?;
    verify_required_field_exists("HeavySetTableEpochByNameArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavySetTableEpochByNameArgs.new_epoch", &f_3)?;
    let ret = HeavySetTableEpochByNameArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_epoch: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epoch_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_epoch", TType::I32, 3))?;
    o_prot.write_i32(self.new_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetTableEpochByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetTableEpochByNameResult {
  e: Option<TDBException>,
}

impl HeavySetTableEpochByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetTableEpochByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetTableEpochByNameResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetTableEpochByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyGetTableEpochArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableEpochArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
}

impl HeavyGetTableEpochArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableEpochArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableEpochArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTableEpochArgs.db_id", &f_2)?;
    verify_required_field_exists("HeavyGetTableEpochArgs.table_id", &f_3)?;
    let ret = HeavyGetTableEpochArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epoch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableEpochResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableEpochResult {
  result_value: Option<i32>,
}

impl HeavyGetTableEpochResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableEpochResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableEpochResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableEpochResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableEpoch"
          )
        )
      )
    }
  }
}

//
// HeavyGetTableEpochByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableEpochByNameArgs {
  session: TSessionId,
  table_name: String,
}

impl HeavyGetTableEpochByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableEpochByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableEpochByNameArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTableEpochByNameArgs.table_name", &f_2)?;
    let ret = HeavyGetTableEpochByNameArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epoch_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableEpochByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableEpochByNameResult {
  result_value: Option<i32>,
}

impl HeavyGetTableEpochByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableEpochByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableEpochByNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableEpochByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableEpochByName"
          )
        )
      )
    }
  }
}

//
// HeavyGetTableEpochsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableEpochsArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
}

impl HeavyGetTableEpochsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableEpochsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableEpochsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTableEpochsArgs.db_id", &f_2)?;
    verify_required_field_exists("HeavyGetTableEpochsArgs.table_id", &f_3)?;
    let ret = HeavyGetTableEpochsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epochs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableEpochsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableEpochsResult {
  result_value: Option<Vec<TTableEpochInfo>>,
}

impl HeavyGetTableEpochsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableEpochsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TTableEpochInfo>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableEpochInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = TTableEpochInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableEpochsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableEpochsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TTableEpochInfo>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableEpochs"
          )
        )
      )
    }
  }
}

//
// HeavySetTableEpochsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetTableEpochsArgs {
  session: TSessionId,
  db_id: i32,
  table_epochs: Vec<TTableEpochInfo>,
}

impl HeavySetTableEpochsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetTableEpochsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<TTableEpochInfo>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableEpochInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_53 = TTableEpochInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_53);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetTableEpochsArgs.session", &f_1)?;
    verify_required_field_exists("HeavySetTableEpochsArgs.db_id", &f_2)?;
    verify_required_field_exists("HeavySetTableEpochsArgs.table_epochs", &f_3)?;
    let ret = HeavySetTableEpochsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_epochs: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epochs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_epochs", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.table_epochs.len() as i32))?;
    for e in &self.table_epochs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetTableEpochsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetTableEpochsResult {
}

impl HeavySetTableEpochsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetTableEpochsResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetTableEpochsResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetTableEpochsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// HeavyGetSessionInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetSessionInfoArgs {
  session: TSessionId,
}

impl HeavyGetSessionInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetSessionInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetSessionInfoArgs.session", &f_1)?;
    let ret = HeavyGetSessionInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_session_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetSessionInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetSessionInfoResult {
  result_value: Option<TSessionInfo>,
  e: Option<TDBException>,
}

impl HeavyGetSessionInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetSessionInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionInfo> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSessionInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetSessionInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetSessionInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetSessionInfo"
          )
        )
      )
    }
  }
}

//
// HeavyGetQueriesInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetQueriesInfoArgs {
  session: TSessionId,
}

impl HeavyGetQueriesInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetQueriesInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetQueriesInfoArgs.session", &f_1)?;
    let ret = HeavyGetQueriesInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_queries_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetQueriesInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetQueriesInfoResult {
  result_value: Option<Vec<TQueryInfo>>,
  e: Option<TDBException>,
}

impl HeavyGetQueriesInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetQueriesInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TQueryInfo>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TQueryInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = TQueryInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetQueriesInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetQueriesInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TQueryInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetQueriesInfo"
          )
        )
      )
    }
  }
}

//
// HeavySetLeafInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetLeafInfoArgs {
  session: TSessionId,
  leaf_info: TLeafInfo,
}

impl HeavySetLeafInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetLeafInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TLeafInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TLeafInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetLeafInfoArgs.session", &f_1)?;
    verify_required_field_exists("HeavySetLeafInfoArgs.leaf_info", &f_2)?;
    let ret = HeavySetLeafInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      leaf_info: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_leaf_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaf_info", TType::Struct, 2))?;
    self.leaf_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetLeafInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetLeafInfoResult {
  e: Option<TDBException>,
}

impl HeavySetLeafInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetLeafInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetLeafInfoResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetLeafInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavySqlExecuteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlExecuteArgs {
  session: TSessionId,
  query: String,
  column_format: bool,
  nonce: String,
  first_n: i32,
  at_most_n: i32,
}

impl HeavySqlExecuteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlExecuteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySqlExecuteArgs.session", &f_1)?;
    verify_required_field_exists("HeavySqlExecuteArgs.query", &f_2)?;
    verify_required_field_exists("HeavySqlExecuteArgs.column_format", &f_3)?;
    verify_required_field_exists("HeavySqlExecuteArgs.nonce", &f_4)?;
    verify_required_field_exists("HeavySqlExecuteArgs.first_n", &f_5)?;
    verify_required_field_exists("HeavySqlExecuteArgs.at_most_n", &f_6)?;
    let ret = HeavySqlExecuteArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_format: f_3.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_4.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_5.expect("auto-generated code should have checked for presence of required fields"),
      at_most_n: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_format", TType::Bool, 3))?;
    o_prot.write_bool(self.column_format)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 4))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 5))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("at_most_n", TType::I32, 6))?;
    o_prot.write_i32(self.at_most_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySqlExecuteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlExecuteResult {
  result_value: Option<TQueryResult>,
  e: Option<TDBException>,
}

impl HeavySqlExecuteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlExecuteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TQueryResult> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TQueryResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySqlExecuteResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySqlExecuteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TQueryResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavySqlExecute"
          )
        )
      )
    }
  }
}

//
// HeavySqlExecuteDfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlExecuteDfArgs {
  session: TSessionId,
  query: String,
  device_type: common::TDeviceType,
  device_id: i32,
  first_n: i32,
  transport_method: TArrowTransport,
}

impl HeavySqlExecuteDfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlExecuteDfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<common::TDeviceType> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<TArrowTransport> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = TArrowTransport::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySqlExecuteDfArgs.session", &f_1)?;
    verify_required_field_exists("HeavySqlExecuteDfArgs.query", &f_2)?;
    verify_required_field_exists("HeavySqlExecuteDfArgs.device_type", &f_3)?;
    verify_required_field_exists("HeavySqlExecuteDfArgs.device_id", &f_4)?;
    verify_required_field_exists("HeavySqlExecuteDfArgs.first_n", &f_5)?;
    verify_required_field_exists("HeavySqlExecuteDfArgs.transport_method", &f_6)?;
    let ret = HeavySqlExecuteDfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_5.expect("auto-generated code should have checked for presence of required fields"),
      transport_method: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_df_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 3))?;
    self.device_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 4))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 5))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transport_method", TType::I32, 6))?;
    self.transport_method.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySqlExecuteDfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlExecuteDfResult {
  result_value: Option<TDataFrame>,
  e: Option<TDBException>,
}

impl HeavySqlExecuteDfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlExecuteDfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDataFrame> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySqlExecuteDfResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySqlExecuteDfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDataFrame> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavySqlExecuteDf"
          )
        )
      )
    }
  }
}

//
// HeavySqlExecuteGdfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlExecuteGdfArgs {
  session: TSessionId,
  query: String,
  device_id: i32,
  first_n: i32,
}

impl HeavySqlExecuteGdfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlExecuteGdfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySqlExecuteGdfArgs.session", &f_1)?;
    verify_required_field_exists("HeavySqlExecuteGdfArgs.query", &f_2)?;
    verify_required_field_exists("HeavySqlExecuteGdfArgs.device_id", &f_3)?;
    verify_required_field_exists("HeavySqlExecuteGdfArgs.first_n", &f_4)?;
    let ret = HeavySqlExecuteGdfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_gdf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 3))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 4))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySqlExecuteGdfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlExecuteGdfResult {
  result_value: Option<TDataFrame>,
  e: Option<TDBException>,
}

impl HeavySqlExecuteGdfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlExecuteGdfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDataFrame> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySqlExecuteGdfResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySqlExecuteGdfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDataFrame> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavySqlExecuteGdf"
          )
        )
      )
    }
  }
}

//
// HeavyDeallocateDfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeallocateDfArgs {
  session: TSessionId,
  df: TDataFrame,
  device_type: common::TDeviceType,
  device_id: i32,
}

impl HeavyDeallocateDfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeallocateDfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TDataFrame> = None;
    let mut f_3: Option<common::TDeviceType> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyDeallocateDfArgs.session", &f_1)?;
    verify_required_field_exists("HeavyDeallocateDfArgs.df", &f_2)?;
    verify_required_field_exists("HeavyDeallocateDfArgs.device_type", &f_3)?;
    verify_required_field_exists("HeavyDeallocateDfArgs.device_id", &f_4)?;
    let ret = HeavyDeallocateDfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      df: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deallocate_df_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("df", TType::Struct, 2))?;
    self.df.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 3))?;
    self.device_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 4))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyDeallocateDfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeallocateDfResult {
  e: Option<TDBException>,
}

impl HeavyDeallocateDfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeallocateDfResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyDeallocateDfResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyDeallocateDfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyInterruptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInterruptArgs {
  query_session: TSessionId,
  interrupt_session: TSessionId,
}

impl HeavyInterruptArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInterruptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyInterruptArgs.query_session", &f_1)?;
    verify_required_field_exists("HeavyInterruptArgs.interrupt_session", &f_2)?;
    let ret = HeavyInterruptArgs {
      query_session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      interrupt_session: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("interrupt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_session", TType::String, 1))?;
    o_prot.write_string(&self.query_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("interrupt_session", TType::String, 2))?;
    o_prot.write_string(&self.interrupt_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyInterruptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInterruptResult {
  e: Option<TDBException>,
}

impl HeavyInterruptResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInterruptResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyInterruptResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyInterruptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavySqlValidateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlValidateArgs {
  session: TSessionId,
  query: String,
}

impl HeavySqlValidateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlValidateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySqlValidateArgs.session", &f_1)?;
    verify_required_field_exists("HeavySqlValidateArgs.query", &f_2)?;
    let ret = HeavySqlValidateArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_validate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySqlValidateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySqlValidateResult {
  result_value: Option<TRowDescriptor>,
  e: Option<TDBException>,
}

impl HeavySqlValidateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySqlValidateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRowDescriptor> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySqlValidateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySqlValidateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRowDescriptor> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavySqlValidate"
          )
        )
      )
    }
  }
}

//
// HeavyGetCompletionHintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetCompletionHintsArgs {
  session: TSessionId,
  sql: String,
  cursor: i32,
}

impl HeavyGetCompletionHintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetCompletionHintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetCompletionHintsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetCompletionHintsArgs.sql", &f_2)?;
    verify_required_field_exists("HeavyGetCompletionHintsArgs.cursor", &f_3)?;
    let ret = HeavyGetCompletionHintsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sql: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cursor: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_completion_hints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 2))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cursor", TType::I32, 3))?;
    o_prot.write_i32(self.cursor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetCompletionHintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetCompletionHintsResult {
  result_value: Option<Vec<completion_hints::TCompletionHint>>,
  e: Option<TDBException>,
}

impl HeavyGetCompletionHintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetCompletionHintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<completion_hints::TCompletionHint>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<completion_hints::TCompletionHint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = completion_hints::TCompletionHint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetCompletionHintsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetCompletionHintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<completion_hints::TCompletionHint>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetCompletionHints"
          )
        )
      )
    }
  }
}

//
// HeavySetExecutionModeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetExecutionModeArgs {
  session: TSessionId,
  mode: TExecuteMode,
}

impl HeavySetExecutionModeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetExecutionModeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TExecuteMode> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TExecuteMode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetExecutionModeArgs.session", &f_1)?;
    verify_required_field_exists("HeavySetExecutionModeArgs.mode", &f_2)?;
    let ret = HeavySetExecutionModeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mode: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_execution_mode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mode", TType::I32, 2))?;
    self.mode.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetExecutionModeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetExecutionModeResult {
  e: Option<TDBException>,
}

impl HeavySetExecutionModeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetExecutionModeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetExecutionModeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetExecutionModeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyRenderVegaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyRenderVegaArgs {
  session: TSessionId,
  widget_id: i64,
  vega_json: String,
  compression_level: i32,
  nonce: String,
}

impl HeavyRenderVegaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyRenderVegaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyRenderVegaArgs.session", &f_1)?;
    verify_required_field_exists("HeavyRenderVegaArgs.widget_id", &f_2)?;
    verify_required_field_exists("HeavyRenderVegaArgs.vega_json", &f_3)?;
    verify_required_field_exists("HeavyRenderVegaArgs.compression_level", &f_4)?;
    verify_required_field_exists("HeavyRenderVegaArgs.nonce", &f_5)?;
    let ret = HeavyRenderVegaArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      vega_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      compression_level: f_4.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("render_vega_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("vega_json", TType::String, 3))?;
    o_prot.write_string(&self.vega_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compression_level", TType::I32, 4))?;
    o_prot.write_i32(self.compression_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 5))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyRenderVegaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyRenderVegaResult {
  result_value: Option<TRenderResult>,
  e: Option<TDBException>,
}

impl HeavyRenderVegaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyRenderVegaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenderResult> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenderResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyRenderVegaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyRenderVegaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenderResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyRenderVega"
          )
        )
      )
    }
  }
}

//
// HeavyGetResultRowForPixelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetResultRowForPixelArgs {
  session: TSessionId,
  widget_id: i64,
  pixel: TPixel,
  table_col_names: BTreeMap<String, Vec<String>>,
  column_format: bool,
  pixel_radius: i32,
  nonce: String,
}

impl HeavyGetResultRowForPixelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetResultRowForPixelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<TPixel> = None;
    let mut f_4: Option<BTreeMap<String, Vec<String>>> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TPixel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<String>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_57 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_58: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_59 = i_prot.read_string()?;
              map_val_58.push(list_elem_59);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_57, map_val_58);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.widget_id", &f_2)?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.pixel", &f_3)?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.table_col_names", &f_4)?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.column_format", &f_5)?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.pixel_radius", &f_6)?;
    verify_required_field_exists("HeavyGetResultRowForPixelArgs.nonce", &f_7)?;
    let ret = HeavyGetResultRowForPixelArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pixel: f_3.expect("auto-generated code should have checked for presence of required fields"),
      table_col_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
      column_format: f_5.expect("auto-generated code should have checked for presence of required fields"),
      pixel_radius: f_6.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_result_row_for_pixel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pixel", TType::Struct, 3))?;
    self.pixel.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_col_names", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, self.table_col_names.len() as i32))?;
    for (k, v) in &self.table_col_names {
      o_prot.write_string(k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, v.len() as i32))?;
      for e in v {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_format", TType::Bool, 5))?;
    o_prot.write_bool(self.column_format)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pixelRadius", TType::I32, 6))?;
    o_prot.write_i32(self.pixel_radius)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 7))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetResultRowForPixelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetResultRowForPixelResult {
  result_value: Option<TPixelTableRowResult>,
  e: Option<TDBException>,
}

impl HeavyGetResultRowForPixelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetResultRowForPixelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPixelTableRowResult> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPixelTableRowResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetResultRowForPixelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetResultRowForPixelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPixelTableRowResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetRowForPixelResult"
          )
        )
      )
    }
  }
}

//
// HeavyCreateCustomExpressionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateCustomExpressionArgs {
  session: TSessionId,
  custom_expression: TCustomExpression,
}

impl HeavyCreateCustomExpressionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateCustomExpressionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TCustomExpression> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TCustomExpression::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCreateCustomExpressionArgs.session", &f_1)?;
    verify_required_field_exists("HeavyCreateCustomExpressionArgs.custom_expression", &f_2)?;
    let ret = HeavyCreateCustomExpressionArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      custom_expression: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_custom_expression_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("custom_expression", TType::Struct, 2))?;
    self.custom_expression.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCreateCustomExpressionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateCustomExpressionResult {
  result_value: Option<i32>,
  e: Option<TDBException>,
}

impl HeavyCreateCustomExpressionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateCustomExpressionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCreateCustomExpressionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCreateCustomExpressionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyCreateCustomExpression"
          )
        )
      )
    }
  }
}

//
// HeavyGetCustomExpressionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetCustomExpressionsArgs {
  session: TSessionId,
}

impl HeavyGetCustomExpressionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetCustomExpressionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetCustomExpressionsArgs.session", &f_1)?;
    let ret = HeavyGetCustomExpressionsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_custom_expressions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetCustomExpressionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetCustomExpressionsResult {
  result_value: Option<Vec<TCustomExpression>>,
  e: Option<TDBException>,
}

impl HeavyGetCustomExpressionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetCustomExpressionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TCustomExpression>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TCustomExpression> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = TCustomExpression::read_from_in_protocol(i_prot)?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetCustomExpressionsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetCustomExpressionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TCustomExpression>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetCustomExpressions"
          )
        )
      )
    }
  }
}

//
// HeavyUpdateCustomExpressionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyUpdateCustomExpressionArgs {
  session: TSessionId,
  id: i32,
  expression_json: String,
}

impl HeavyUpdateCustomExpressionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyUpdateCustomExpressionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyUpdateCustomExpressionArgs.session", &f_1)?;
    verify_required_field_exists("HeavyUpdateCustomExpressionArgs.id", &f_2)?;
    verify_required_field_exists("HeavyUpdateCustomExpressionArgs.expression_json", &f_3)?;
    let ret = HeavyUpdateCustomExpressionArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      expression_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_custom_expression_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 2))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expression_json", TType::String, 3))?;
    o_prot.write_string(&self.expression_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyUpdateCustomExpressionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyUpdateCustomExpressionResult {
  e: Option<TDBException>,
}

impl HeavyUpdateCustomExpressionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyUpdateCustomExpressionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyUpdateCustomExpressionResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyUpdateCustomExpressionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyDeleteCustomExpressionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeleteCustomExpressionsArgs {
  session: TSessionId,
  custom_expression_ids: Vec<i32>,
  do_soft_delete: bool,
}

impl HeavyDeleteCustomExpressionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeleteCustomExpressionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<i32>> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = i_prot.read_i32()?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyDeleteCustomExpressionsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyDeleteCustomExpressionsArgs.custom_expression_ids", &f_2)?;
    verify_required_field_exists("HeavyDeleteCustomExpressionsArgs.do_soft_delete", &f_3)?;
    let ret = HeavyDeleteCustomExpressionsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      custom_expression_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
      do_soft_delete: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_custom_expressions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("custom_expression_ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.custom_expression_ids.len() as i32))?;
    for e in &self.custom_expression_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("do_soft_delete", TType::Bool, 3))?;
    o_prot.write_bool(self.do_soft_delete)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyDeleteCustomExpressionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeleteCustomExpressionsResult {
  e: Option<TDBException>,
}

impl HeavyDeleteCustomExpressionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeleteCustomExpressionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyDeleteCustomExpressionsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyDeleteCustomExpressionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyGetDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl HeavyGetDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDashboardArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetDashboardArgs.dashboard_id", &f_2)?;
    let ret = HeavyGetDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDashboardResult {
  result_value: Option<TDashboard>,
  e: Option<TDBException>,
}

impl HeavyGetDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDashboard> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDashboard::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDashboardResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDashboard> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDashboard"
          )
        )
      )
    }
  }
}

//
// HeavyGetDashboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDashboardsArgs {
  session: TSessionId,
}

impl HeavyGetDashboardsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDashboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDashboardsArgs.session", &f_1)?;
    let ret = HeavyGetDashboardsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDashboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDashboardsResult {
  result_value: Option<Vec<TDashboard>>,
  e: Option<TDBException>,
}

impl HeavyGetDashboardsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDashboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDashboard>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDashboard> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = TDashboard::read_from_in_protocol(i_prot)?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDashboardsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDashboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDashboard>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDashboards"
          )
        )
      )
    }
  }
}

//
// HeavyCreateDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateDashboardArgs {
  session: TSessionId,
  dashboard_name: String,
  dashboard_state: String,
  image_hash: String,
  dashboard_metadata: String,
}

impl HeavyCreateDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCreateDashboardArgs.session", &f_1)?;
    verify_required_field_exists("HeavyCreateDashboardArgs.dashboard_name", &f_2)?;
    verify_required_field_exists("HeavyCreateDashboardArgs.dashboard_state", &f_3)?;
    verify_required_field_exists("HeavyCreateDashboardArgs.image_hash", &f_4)?;
    verify_required_field_exists("HeavyCreateDashboardArgs.dashboard_metadata", &f_5)?;
    let ret = HeavyCreateDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_state: f_3.expect("auto-generated code should have checked for presence of required fields"),
      image_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_metadata: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 2))?;
    o_prot.write_string(&self.dashboard_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 3))?;
    o_prot.write_string(&self.dashboard_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 4))?;
    o_prot.write_string(&self.image_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 5))?;
    o_prot.write_string(&self.dashboard_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCreateDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateDashboardResult {
  result_value: Option<i32>,
  e: Option<TDBException>,
}

impl HeavyCreateDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCreateDashboardResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCreateDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyCreateDashboard"
          )
        )
      )
    }
  }
}

//
// HeavyReplaceDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyReplaceDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  dashboard_name: String,
  dashboard_owner: String,
  dashboard_state: String,
  image_hash: String,
  dashboard_metadata: String,
}

impl HeavyReplaceDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyReplaceDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.session", &f_1)?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.dashboard_name", &f_3)?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.dashboard_owner", &f_4)?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.dashboard_state", &f_5)?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.image_hash", &f_6)?;
    verify_required_field_exists("HeavyReplaceDashboardArgs.dashboard_metadata", &f_7)?;
    let ret = HeavyReplaceDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_owner: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_state: f_5.expect("auto-generated code should have checked for presence of required fields"),
      image_hash: f_6.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_metadata: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("replace_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 3))?;
    o_prot.write_string(&self.dashboard_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_owner", TType::String, 4))?;
    o_prot.write_string(&self.dashboard_owner)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 5))?;
    o_prot.write_string(&self.dashboard_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 6))?;
    o_prot.write_string(&self.image_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 7))?;
    o_prot.write_string(&self.dashboard_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyReplaceDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyReplaceDashboardResult {
  e: Option<TDBException>,
}

impl HeavyReplaceDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyReplaceDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyReplaceDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyReplaceDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyDeleteDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeleteDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl HeavyDeleteDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeleteDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyDeleteDashboardArgs.session", &f_1)?;
    verify_required_field_exists("HeavyDeleteDashboardArgs.dashboard_id", &f_2)?;
    let ret = HeavyDeleteDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyDeleteDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeleteDashboardResult {
  e: Option<TDBException>,
}

impl HeavyDeleteDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeleteDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyDeleteDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyDeleteDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyShareDashboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyShareDashboardsArgs {
  session: TSessionId,
  dashboard_ids: Vec<i32>,
  groups: Vec<String>,
  permissions: TDashboardPermissions,
}

impl HeavyShareDashboardsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyShareDashboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<i32>> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = i_prot.read_i32()?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_64 = i_prot.read_string()?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyShareDashboardsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyShareDashboardsArgs.dashboard_ids", &f_2)?;
    verify_required_field_exists("HeavyShareDashboardsArgs.groups", &f_3)?;
    verify_required_field_exists("HeavyShareDashboardsArgs.permissions", &f_4)?;
    let ret = HeavyShareDashboardsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("share_dashboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.dashboard_ids.len() as i32))?;
    for e in &self.dashboard_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 4))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyShareDashboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyShareDashboardsResult {
  e: Option<TDBException>,
}

impl HeavyShareDashboardsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyShareDashboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyShareDashboardsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyShareDashboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyDeleteDashboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeleteDashboardsArgs {
  session: TSessionId,
  dashboard_ids: Vec<i32>,
}

impl HeavyDeleteDashboardsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeleteDashboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_65 = i_prot.read_i32()?;
            val.push(list_elem_65);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyDeleteDashboardsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyDeleteDashboardsArgs.dashboard_ids", &f_2)?;
    let ret = HeavyDeleteDashboardsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_dashboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.dashboard_ids.len() as i32))?;
    for e in &self.dashboard_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyDeleteDashboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDeleteDashboardsResult {
  e: Option<TDBException>,
}

impl HeavyDeleteDashboardsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDeleteDashboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyDeleteDashboardsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyDeleteDashboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyShareDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyShareDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  groups: Vec<String>,
  objects: Vec<String>,
  permissions: TDashboardPermissions,
  grant_role: bool,
}

impl HeavyShareDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyShareDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<TDashboardPermissions> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = i_prot.read_string()?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = i_prot.read_string()?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyShareDashboardArgs.session", &f_1)?;
    verify_required_field_exists("HeavyShareDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("HeavyShareDashboardArgs.groups", &f_3)?;
    verify_required_field_exists("HeavyShareDashboardArgs.objects", &f_4)?;
    verify_required_field_exists("HeavyShareDashboardArgs.permissions", &f_5)?;
    verify_required_field_exists("HeavyShareDashboardArgs.grant_role", &f_6)?;
    let ret = HeavyShareDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      objects: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
      grant_role: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("share_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objects", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.objects.len() as i32))?;
    for e in &self.objects {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grant_role", TType::Bool, 6))?;
    o_prot.write_bool(self.grant_role)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyShareDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyShareDashboardResult {
  e: Option<TDBException>,
}

impl HeavyShareDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyShareDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyShareDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyShareDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyUnshareDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyUnshareDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  groups: Vec<String>,
  objects: Vec<String>,
  permissions: TDashboardPermissions,
}

impl HeavyUnshareDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyUnshareDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_68 = i_prot.read_string()?;
            val.push(list_elem_68);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_69 = i_prot.read_string()?;
            val.push(list_elem_69);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyUnshareDashboardArgs.session", &f_1)?;
    verify_required_field_exists("HeavyUnshareDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("HeavyUnshareDashboardArgs.groups", &f_3)?;
    verify_required_field_exists("HeavyUnshareDashboardArgs.objects", &f_4)?;
    verify_required_field_exists("HeavyUnshareDashboardArgs.permissions", &f_5)?;
    let ret = HeavyUnshareDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      objects: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unshare_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objects", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.objects.len() as i32))?;
    for e in &self.objects {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyUnshareDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyUnshareDashboardResult {
  e: Option<TDBException>,
}

impl HeavyUnshareDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyUnshareDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyUnshareDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyUnshareDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyUnshareDashboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyUnshareDashboardsArgs {
  session: TSessionId,
  dashboard_ids: Vec<i32>,
  groups: Vec<String>,
  permissions: TDashboardPermissions,
}

impl HeavyUnshareDashboardsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyUnshareDashboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<i32>> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_70 = i_prot.read_i32()?;
            val.push(list_elem_70);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = i_prot.read_string()?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyUnshareDashboardsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyUnshareDashboardsArgs.dashboard_ids", &f_2)?;
    verify_required_field_exists("HeavyUnshareDashboardsArgs.groups", &f_3)?;
    verify_required_field_exists("HeavyUnshareDashboardsArgs.permissions", &f_4)?;
    let ret = HeavyUnshareDashboardsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unshare_dashboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.dashboard_ids.len() as i32))?;
    for e in &self.dashboard_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 4))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyUnshareDashboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyUnshareDashboardsResult {
  e: Option<TDBException>,
}

impl HeavyUnshareDashboardsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyUnshareDashboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyUnshareDashboardsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyUnshareDashboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyGetDashboardGranteesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDashboardGranteesArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl HeavyGetDashboardGranteesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDashboardGranteesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDashboardGranteesArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetDashboardGranteesArgs.dashboard_id", &f_2)?;
    let ret = HeavyGetDashboardGranteesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboard_grantees_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDashboardGranteesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDashboardGranteesResult {
  result_value: Option<Vec<TDashboardGrantees>>,
  e: Option<TDBException>,
}

impl HeavyGetDashboardGranteesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDashboardGranteesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDashboardGrantees>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDashboardGrantees> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_72 = TDashboardGrantees::read_from_in_protocol(i_prot)?;
            val.push(list_elem_72);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDashboardGranteesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDashboardGranteesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDashboardGrantees>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDashboardGrantees"
          )
        )
      )
    }
  }
}

//
// HeavyGetLinkViewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetLinkViewArgs {
  session: TSessionId,
  link: String,
}

impl HeavyGetLinkViewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetLinkViewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetLinkViewArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetLinkViewArgs.link", &f_2)?;
    let ret = HeavyGetLinkViewArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      link: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_link_view_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("link", TType::String, 2))?;
    o_prot.write_string(&self.link)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetLinkViewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetLinkViewResult {
  result_value: Option<TFrontendView>,
  e: Option<TDBException>,
}

impl HeavyGetLinkViewResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetLinkViewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TFrontendView> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TFrontendView::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetLinkViewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetLinkViewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TFrontendView> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetLinkView"
          )
        )
      )
    }
  }
}

//
// HeavyCreateLinkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateLinkArgs {
  session: TSessionId,
  view_state: String,
  view_metadata: String,
}

impl HeavyCreateLinkArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateLinkArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCreateLinkArgs.session", &f_1)?;
    verify_required_field_exists("HeavyCreateLinkArgs.view_state", &f_2)?;
    verify_required_field_exists("HeavyCreateLinkArgs.view_metadata", &f_3)?;
    let ret = HeavyCreateLinkArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      view_state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      view_metadata: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_link_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("view_state", TType::String, 2))?;
    o_prot.write_string(&self.view_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("view_metadata", TType::String, 3))?;
    o_prot.write_string(&self.view_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCreateLinkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateLinkResult {
  result_value: Option<String>,
  e: Option<TDBException>,
}

impl HeavyCreateLinkResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateLinkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCreateLinkResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCreateLinkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyCreateLink"
          )
        )
      )
    }
  }
}

//
// HeavyLoadTableBinaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryArgs {
  session: TSessionId,
  table_name: String,
  rows: Vec<TRow>,
  column_names: Vec<String>,
}

impl HeavyLoadTableBinaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TRow>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = i_prot.read_string()?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyLoadTableBinaryArgs.session", &f_1)?;
    verify_required_field_exists("HeavyLoadTableBinaryArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyLoadTableBinaryArgs.rows", &f_3)?;
    verify_required_field_exists("HeavyLoadTableBinaryArgs.column_names", &f_4)?;
    let ret = HeavyLoadTableBinaryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_names", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.column_names.len() as i32))?;
    for e in &self.column_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyLoadTableBinaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryResult {
  e: Option<TDBException>,
}

impl HeavyLoadTableBinaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyLoadTableBinaryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyLoadTableBinaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyLoadTableBinaryColumnarArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryColumnarArgs {
  session: TSessionId,
  table_name: String,
  cols: Vec<TColumn>,
  column_names: Vec<String>,
}

impl HeavyLoadTableBinaryColumnarArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryColumnarArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TColumn>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_75 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_75);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_76 = i_prot.read_string()?;
            val.push(list_elem_76);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarArgs.session", &f_1)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarArgs.cols", &f_3)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarArgs.column_names", &f_4)?;
    let ret = HeavyLoadTableBinaryColumnarArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cols: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_columnar_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.cols.len() as i32))?;
    for e in &self.cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_names", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.column_names.len() as i32))?;
    for e in &self.column_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyLoadTableBinaryColumnarResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryColumnarResult {
  e: Option<TDBException>,
}

impl HeavyLoadTableBinaryColumnarResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryColumnarResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyLoadTableBinaryColumnarResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyLoadTableBinaryColumnarResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyLoadTableBinaryColumnarPolysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryColumnarPolysArgs {
  session: TSessionId,
  table_name: String,
  cols: Vec<TColumn>,
  column_names: Vec<String>,
  assign_render_groups: bool,
}

impl HeavyLoadTableBinaryColumnarPolysArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryColumnarPolysArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TColumn>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_77 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_77);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_78 = i_prot.read_string()?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarPolysArgs.session", &f_1)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarPolysArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarPolysArgs.cols", &f_3)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarPolysArgs.column_names", &f_4)?;
    verify_required_field_exists("HeavyLoadTableBinaryColumnarPolysArgs.assign_render_groups", &f_5)?;
    let ret = HeavyLoadTableBinaryColumnarPolysArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cols: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
      assign_render_groups: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_columnar_polys_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.cols.len() as i32))?;
    for e in &self.cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_names", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.column_names.len() as i32))?;
    for e in &self.column_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("assign_render_groups", TType::Bool, 5))?;
    o_prot.write_bool(self.assign_render_groups)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyLoadTableBinaryColumnarPolysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryColumnarPolysResult {
  e: Option<TDBException>,
}

impl HeavyLoadTableBinaryColumnarPolysResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryColumnarPolysResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyLoadTableBinaryColumnarPolysResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyLoadTableBinaryColumnarPolysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyLoadTableBinaryArrowArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryArrowArgs {
  session: TSessionId,
  table_name: String,
  arrow_stream: Vec<u8>,
  use_column_names: bool,
}

impl HeavyLoadTableBinaryArrowArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryArrowArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyLoadTableBinaryArrowArgs.session", &f_1)?;
    verify_required_field_exists("HeavyLoadTableBinaryArrowArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyLoadTableBinaryArrowArgs.arrow_stream", &f_3)?;
    verify_required_field_exists("HeavyLoadTableBinaryArrowArgs.use_column_names", &f_4)?;
    let ret = HeavyLoadTableBinaryArrowArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      arrow_stream: f_3.expect("auto-generated code should have checked for presence of required fields"),
      use_column_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_arrow_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("arrow_stream", TType::String, 3))?;
    o_prot.write_bytes(&self.arrow_stream)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("use_column_names", TType::Bool, 4))?;
    o_prot.write_bool(self.use_column_names)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyLoadTableBinaryArrowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableBinaryArrowResult {
  e: Option<TDBException>,
}

impl HeavyLoadTableBinaryArrowResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableBinaryArrowResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyLoadTableBinaryArrowResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyLoadTableBinaryArrowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyLoadTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableArgs {
  session: TSessionId,
  table_name: String,
  rows: Vec<TStringRow>,
  column_names: Vec<String>,
}

impl HeavyLoadTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TStringRow>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStringRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_79 = TStringRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_79);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_80 = i_prot.read_string()?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyLoadTableArgs.session", &f_1)?;
    verify_required_field_exists("HeavyLoadTableArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyLoadTableArgs.rows", &f_3)?;
    verify_required_field_exists("HeavyLoadTableArgs.column_names", &f_4)?;
    let ret = HeavyLoadTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_names", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.column_names.len() as i32))?;
    for e in &self.column_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyLoadTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyLoadTableResult {
  e: Option<TDBException>,
}

impl HeavyLoadTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyLoadTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyLoadTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyLoadTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyDetectColumnTypesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDetectColumnTypesArgs {
  session: TSessionId,
  file_name: String,
  copy_params: TCopyParams,
}

impl HeavyDetectColumnTypesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDetectColumnTypesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyDetectColumnTypesArgs.session", &f_1)?;
    verify_required_field_exists("HeavyDetectColumnTypesArgs.file_name", &f_2)?;
    verify_required_field_exists("HeavyDetectColumnTypesArgs.copy_params", &f_3)?;
    let ret = HeavyDetectColumnTypesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("detect_column_types_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 2))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyDetectColumnTypesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyDetectColumnTypesResult {
  result_value: Option<TDetectResult>,
  e: Option<TDBException>,
}

impl HeavyDetectColumnTypesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyDetectColumnTypesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDetectResult> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDetectResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyDetectColumnTypesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyDetectColumnTypesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDetectResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyDetectColumnTypes"
          )
        )
      )
    }
  }
}

//
// HeavyCreateTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateTableArgs {
  session: TSessionId,
  table_name: String,
  row_desc: TRowDescriptor,
  create_params: TCreateParams,
}

impl HeavyCreateTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TRowDescriptor> = None;
    let mut f_4: Option<TCreateParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_81 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_81);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCreateParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCreateTableArgs.session", &f_1)?;
    verify_required_field_exists("HeavyCreateTableArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyCreateTableArgs.row_desc", &f_3)?;
    verify_required_field_exists("HeavyCreateTableArgs.create_params", &f_4)?;
    let ret = HeavyCreateTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_3.expect("auto-generated code should have checked for presence of required fields"),
      create_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("create_params", TType::Struct, 4))?;
    self.create_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCreateTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCreateTableResult {
  e: Option<TDBException>,
}

impl HeavyCreateTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCreateTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCreateTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCreateTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyImportTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyImportTableArgs {
  session: TSessionId,
  table_name: String,
  file_name: String,
  copy_params: TCopyParams,
}

impl HeavyImportTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyImportTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyImportTableArgs.session", &f_1)?;
    verify_required_field_exists("HeavyImportTableArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyImportTableArgs.file_name", &f_3)?;
    verify_required_field_exists("HeavyImportTableArgs.copy_params", &f_4)?;
    let ret = HeavyImportTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 3))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 4))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyImportTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyImportTableResult {
  e: Option<TDBException>,
}

impl HeavyImportTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyImportTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyImportTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyImportTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyImportGeoTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyImportGeoTableArgs {
  session: TSessionId,
  table_name: String,
  file_name: String,
  copy_params: TCopyParams,
  row_desc: TRowDescriptor,
  create_params: TCreateParams,
}

impl HeavyImportGeoTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyImportGeoTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TCopyParams> = None;
    let mut f_5: Option<TRowDescriptor> = None;
    let mut f_6: Option<TCreateParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_82 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_82);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = TCreateParams::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyImportGeoTableArgs.session", &f_1)?;
    verify_required_field_exists("HeavyImportGeoTableArgs.table_name", &f_2)?;
    verify_required_field_exists("HeavyImportGeoTableArgs.file_name", &f_3)?;
    verify_required_field_exists("HeavyImportGeoTableArgs.copy_params", &f_4)?;
    verify_required_field_exists("HeavyImportGeoTableArgs.row_desc", &f_5)?;
    verify_required_field_exists("HeavyImportGeoTableArgs.create_params", &f_6)?;
    let ret = HeavyImportGeoTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_5.expect("auto-generated code should have checked for presence of required fields"),
      create_params: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_geo_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 3))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 4))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("create_params", TType::Struct, 6))?;
    self.create_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyImportGeoTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyImportGeoTableResult {
  e: Option<TDBException>,
}

impl HeavyImportGeoTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyImportGeoTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyImportGeoTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyImportGeoTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyImportTableStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyImportTableStatusArgs {
  session: TSessionId,
  import_id: String,
}

impl HeavyImportTableStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyImportTableStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyImportTableStatusArgs.session", &f_1)?;
    verify_required_field_exists("HeavyImportTableStatusArgs.import_id", &f_2)?;
    let ret = HeavyImportTableStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      import_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_table_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("import_id", TType::String, 2))?;
    o_prot.write_string(&self.import_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyImportTableStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyImportTableStatusResult {
  result_value: Option<TImportStatus>,
  e: Option<TDBException>,
}

impl HeavyImportTableStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyImportTableStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TImportStatus> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TImportStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyImportTableStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyImportTableStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TImportStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyImportTableStatus"
          )
        )
      )
    }
  }
}

//
// HeavyGetFirstGeoFileInArchiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetFirstGeoFileInArchiveArgs {
  session: TSessionId,
  archive_path: String,
  copy_params: TCopyParams,
}

impl HeavyGetFirstGeoFileInArchiveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetFirstGeoFileInArchiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetFirstGeoFileInArchiveArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetFirstGeoFileInArchiveArgs.archive_path", &f_2)?;
    verify_required_field_exists("HeavyGetFirstGeoFileInArchiveArgs.copy_params", &f_3)?;
    let ret = HeavyGetFirstGeoFileInArchiveArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      archive_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_first_geo_file_in_archive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("archive_path", TType::String, 2))?;
    o_prot.write_string(&self.archive_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetFirstGeoFileInArchiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetFirstGeoFileInArchiveResult {
  result_value: Option<String>,
  e: Option<TDBException>,
}

impl HeavyGetFirstGeoFileInArchiveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetFirstGeoFileInArchiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetFirstGeoFileInArchiveResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetFirstGeoFileInArchiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetFirstGeoFileInArchive"
          )
        )
      )
    }
  }
}

//
// HeavyGetAllFilesInArchiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetAllFilesInArchiveArgs {
  session: TSessionId,
  archive_path: String,
  copy_params: TCopyParams,
}

impl HeavyGetAllFilesInArchiveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetAllFilesInArchiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetAllFilesInArchiveArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetAllFilesInArchiveArgs.archive_path", &f_2)?;
    verify_required_field_exists("HeavyGetAllFilesInArchiveArgs.copy_params", &f_3)?;
    let ret = HeavyGetAllFilesInArchiveArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      archive_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_files_in_archive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("archive_path", TType::String, 2))?;
    o_prot.write_string(&self.archive_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetAllFilesInArchiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetAllFilesInArchiveResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetAllFilesInArchiveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetAllFilesInArchiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = i_prot.read_string()?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetAllFilesInArchiveResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetAllFilesInArchiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetAllFilesInArchive"
          )
        )
      )
    }
  }
}

//
// HeavyGetLayersInGeoFileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetLayersInGeoFileArgs {
  session: TSessionId,
  file_name: String,
  copy_params: TCopyParams,
}

impl HeavyGetLayersInGeoFileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetLayersInGeoFileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetLayersInGeoFileArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetLayersInGeoFileArgs.file_name", &f_2)?;
    verify_required_field_exists("HeavyGetLayersInGeoFileArgs.copy_params", &f_3)?;
    let ret = HeavyGetLayersInGeoFileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_layers_in_geo_file_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 2))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetLayersInGeoFileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetLayersInGeoFileResult {
  result_value: Option<Vec<TGeoFileLayerInfo>>,
  e: Option<TDBException>,
}

impl HeavyGetLayersInGeoFileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetLayersInGeoFileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TGeoFileLayerInfo>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TGeoFileLayerInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = TGeoFileLayerInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetLayersInGeoFileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetLayersInGeoFileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TGeoFileLayerInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetLayersInGeoFile"
          )
        )
      )
    }
  }
}

//
// HeavyQueryGetOuterFragmentCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyQueryGetOuterFragmentCountArgs {
  session: TSessionId,
  query: String,
}

impl HeavyQueryGetOuterFragmentCountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyQueryGetOuterFragmentCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyQueryGetOuterFragmentCountArgs.session", &f_1)?;
    verify_required_field_exists("HeavyQueryGetOuterFragmentCountArgs.query", &f_2)?;
    let ret = HeavyQueryGetOuterFragmentCountArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("query_get_outer_fragment_count_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyQueryGetOuterFragmentCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyQueryGetOuterFragmentCountResult {
  result_value: Option<i64>,
  e: Option<TDBException>,
}

impl HeavyQueryGetOuterFragmentCountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyQueryGetOuterFragmentCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyQueryGetOuterFragmentCountResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyQueryGetOuterFragmentCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyQueryGetOuterFragmentCount"
          )
        )
      )
    }
  }
}

//
// HeavyCheckTableConsistencyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCheckTableConsistencyArgs {
  session: TSessionId,
  table_id: i32,
}

impl HeavyCheckTableConsistencyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCheckTableConsistencyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCheckTableConsistencyArgs.session", &f_1)?;
    verify_required_field_exists("HeavyCheckTableConsistencyArgs.table_id", &f_2)?;
    let ret = HeavyCheckTableConsistencyArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("check_table_consistency_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCheckTableConsistencyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCheckTableConsistencyResult {
  result_value: Option<TTableMeta>,
  e: Option<TDBException>,
}

impl HeavyCheckTableConsistencyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCheckTableConsistencyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableMeta> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableMeta::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCheckTableConsistencyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCheckTableConsistencyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableMeta> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyCheckTableConsistency"
          )
        )
      )
    }
  }
}

//
// HeavyStartQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStartQueryArgs {
  leaf_session: TSessionId,
  parent_session: TSessionId,
  query_ra: String,
  start_time_str: String,
  just_explain: bool,
  outer_fragment_indices: Vec<i64>,
}

impl HeavyStartQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStartQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TSessionId> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_85 = i_prot.read_i64()?;
            val.push(list_elem_85);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyStartQueryArgs.leaf_session", &f_1)?;
    verify_required_field_exists("HeavyStartQueryArgs.parent_session", &f_2)?;
    verify_required_field_exists("HeavyStartQueryArgs.query_ra", &f_3)?;
    verify_required_field_exists("HeavyStartQueryArgs.start_time_str", &f_4)?;
    verify_required_field_exists("HeavyStartQueryArgs.just_explain", &f_5)?;
    verify_required_field_exists("HeavyStartQueryArgs.outer_fragment_indices", &f_6)?;
    let ret = HeavyStartQueryArgs {
      leaf_session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parent_session: f_2.expect("auto-generated code should have checked for presence of required fields"),
      query_ra: f_3.expect("auto-generated code should have checked for presence of required fields"),
      start_time_str: f_4.expect("auto-generated code should have checked for presence of required fields"),
      just_explain: f_5.expect("auto-generated code should have checked for presence of required fields"),
      outer_fragment_indices: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaf_session", TType::String, 1))?;
    o_prot.write_string(&self.leaf_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parent_session", TType::String, 2))?;
    o_prot.write_string(&self.parent_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_ra", TType::String, 3))?;
    o_prot.write_string(&self.query_ra)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_time_str", TType::String, 4))?;
    o_prot.write_string(&self.start_time_str)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("just_explain", TType::Bool, 5))?;
    o_prot.write_bool(self.just_explain)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("outer_fragment_indices", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.outer_fragment_indices.len() as i32))?;
    for e in &self.outer_fragment_indices {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyStartQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStartQueryResult {
  result_value: Option<TPendingQuery>,
  e: Option<TDBException>,
}

impl HeavyStartQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStartQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPendingQuery> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPendingQuery::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyStartQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyStartQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPendingQuery> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyStartQuery"
          )
        )
      )
    }
  }
}

//
// HeavyExecuteQueryStepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyExecuteQueryStepArgs {
  pending_query: TPendingQuery,
  subquery_id: TSubqueryId,
  start_time_str: String,
}

impl HeavyExecuteQueryStepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyExecuteQueryStepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPendingQuery> = None;
    let mut f_2: Option<TSubqueryId> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPendingQuery::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyExecuteQueryStepArgs.pending_query", &f_1)?;
    verify_required_field_exists("HeavyExecuteQueryStepArgs.subquery_id", &f_2)?;
    verify_required_field_exists("HeavyExecuteQueryStepArgs.start_time_str", &f_3)?;
    let ret = HeavyExecuteQueryStepArgs {
      pending_query: f_1.expect("auto-generated code should have checked for presence of required fields"),
      subquery_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_time_str: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("execute_query_step_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pending_query", TType::Struct, 1))?;
    self.pending_query.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("subquery_id", TType::I64, 2))?;
    o_prot.write_i64(self.subquery_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_time_str", TType::String, 3))?;
    o_prot.write_string(&self.start_time_str)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyExecuteQueryStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyExecuteQueryStepResult {
  result_value: Option<TStepResult>,
  e: Option<TDBException>,
}

impl HeavyExecuteQueryStepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyExecuteQueryStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TStepResult> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TStepResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyExecuteQueryStepResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyExecuteQueryStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TStepResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyExecuteQueryStep"
          )
        )
      )
    }
  }
}

//
// HeavyBroadcastSerializedRowsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyBroadcastSerializedRowsArgs {
  serialized_rows: serialized_result_set::TSerializedRows,
  row_desc: TRowDescriptor,
  query_id: TQueryId,
  subquery_id: TSubqueryId,
  is_final_subquery_result: bool,
}

impl HeavyBroadcastSerializedRowsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyBroadcastSerializedRowsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<serialized_result_set::TSerializedRows> = None;
    let mut f_2: Option<TRowDescriptor> = None;
    let mut f_3: Option<TQueryId> = None;
    let mut f_4: Option<TSubqueryId> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = serialized_result_set::TSerializedRows::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_86 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_86);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyBroadcastSerializedRowsArgs.serialized_rows", &f_1)?;
    verify_required_field_exists("HeavyBroadcastSerializedRowsArgs.row_desc", &f_2)?;
    verify_required_field_exists("HeavyBroadcastSerializedRowsArgs.query_id", &f_3)?;
    verify_required_field_exists("HeavyBroadcastSerializedRowsArgs.subquery_id", &f_4)?;
    verify_required_field_exists("HeavyBroadcastSerializedRowsArgs.is_final_subquery_result", &f_5)?;
    let ret = HeavyBroadcastSerializedRowsArgs {
      serialized_rows: f_1.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_2.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      subquery_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      is_final_subquery_result: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("broadcast_serialized_rows_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialized_rows", TType::Struct, 1))?;
    self.serialized_rows.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::I64, 3))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("subquery_id", TType::I64, 4))?;
    o_prot.write_i64(self.subquery_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_final_subquery_result", TType::Bool, 5))?;
    o_prot.write_bool(self.is_final_subquery_result)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyBroadcastSerializedRowsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyBroadcastSerializedRowsResult {
  e: Option<TDBException>,
}

impl HeavyBroadcastSerializedRowsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyBroadcastSerializedRowsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyBroadcastSerializedRowsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyBroadcastSerializedRowsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyStartRenderQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStartRenderQueryArgs {
  session: TSessionId,
  widget_id: i64,
  node_idx: i16,
  vega_json: String,
}

impl HeavyStartRenderQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStartRenderQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i16> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyStartRenderQueryArgs.session", &f_1)?;
    verify_required_field_exists("HeavyStartRenderQueryArgs.widget_id", &f_2)?;
    verify_required_field_exists("HeavyStartRenderQueryArgs.node_idx", &f_3)?;
    verify_required_field_exists("HeavyStartRenderQueryArgs.vega_json", &f_4)?;
    let ret = HeavyStartRenderQueryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      node_idx: f_3.expect("auto-generated code should have checked for presence of required fields"),
      vega_json: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_render_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_idx", TType::I16, 3))?;
    o_prot.write_i16(self.node_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("vega_json", TType::String, 4))?;
    o_prot.write_string(&self.vega_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyStartRenderQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyStartRenderQueryResult {
  result_value: Option<TPendingRenderQuery>,
  e: Option<TDBException>,
}

impl HeavyStartRenderQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyStartRenderQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPendingRenderQuery> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPendingRenderQuery::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyStartRenderQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyStartRenderQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPendingRenderQuery> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyStartRenderQuery"
          )
        )
      )
    }
  }
}

//
// HeavyExecuteNextRenderStepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyExecuteNextRenderStepArgs {
  pending_render: TPendingRenderQuery,
  merged_data: TRenderAggDataMap,
}

impl HeavyExecuteNextRenderStepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyExecuteNextRenderStepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPendingRenderQuery> = None;
    let mut f_2: Option<TRenderAggDataMap> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPendingRenderQuery::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_87 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_88: BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_89 = i_prot.read_string()?;
              let map_ident = i_prot.read_map_begin()?;
              let mut map_val_90: BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>> = BTreeMap::new();
              for _ in 0..map_ident.size {
                let map_key_91 = i_prot.read_string()?;
                let map_ident = i_prot.read_map_begin()?;
                let mut map_val_92: BTreeMap<String, Vec<TRenderDatum>> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_93 = i_prot.read_string()?;
                  let list_ident = i_prot.read_list_begin()?;
                  let mut map_val_94: Vec<TRenderDatum> = Vec::with_capacity(list_ident.size as usize);
                  for _ in 0..list_ident.size {
                    let list_elem_95 = TRenderDatum::read_from_in_protocol(i_prot)?;
                    map_val_94.push(list_elem_95);
                  }
                  i_prot.read_list_end()?;
                  map_val_92.insert(map_key_93, map_val_94);
                }
                i_prot.read_map_end()?;
                map_val_90.insert(map_key_91, map_val_92);
              }
              i_prot.read_map_end()?;
              map_val_88.insert(map_key_89, map_val_90);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_87, map_val_88);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyExecuteNextRenderStepArgs.pending_render", &f_1)?;
    verify_required_field_exists("HeavyExecuteNextRenderStepArgs.merged_data", &f_2)?;
    let ret = HeavyExecuteNextRenderStepArgs {
      pending_render: f_1.expect("auto-generated code should have checked for presence of required fields"),
      merged_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("execute_next_render_step_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pending_render", TType::Struct, 1))?;
    self.pending_render.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("merged_data", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, self.merged_data.len() as i32))?;
    for (k, v) in &self.merged_data {
      o_prot.write_string(k)?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
      for (k, v) in v {
        o_prot.write_string(k)?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
        for (k, v) in v {
          o_prot.write_string(k)?;
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
          for (k, v) in v {
            o_prot.write_string(k)?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
            for e in v {
              e.write_to_out_protocol(o_prot)?;
            }
            o_prot.write_list_end()?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyExecuteNextRenderStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyExecuteNextRenderStepResult {
  result_value: Option<TRenderStepResult>,
  e: Option<TDBException>,
}

impl HeavyExecuteNextRenderStepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyExecuteNextRenderStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenderStepResult> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenderStepResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyExecuteNextRenderStepResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyExecuteNextRenderStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenderStepResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyExecuteNextRenderStep"
          )
        )
      )
    }
  }
}

//
// HeavyInsertDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInsertDataArgs {
  session: TSessionId,
  insert_data: TInsertData,
}

impl HeavyInsertDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInsertDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TInsertData> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TInsertData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyInsertDataArgs.session", &f_1)?;
    verify_required_field_exists("HeavyInsertDataArgs.insert_data", &f_2)?;
    let ret = HeavyInsertDataArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      insert_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insert_data_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("insert_data", TType::Struct, 2))?;
    self.insert_data.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyInsertDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInsertDataResult {
  e: Option<TDBException>,
}

impl HeavyInsertDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInsertDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyInsertDataResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyInsertDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyInsertChunksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInsertChunksArgs {
  session: TSessionId,
  insert_chunks: TInsertChunks,
}

impl HeavyInsertChunksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInsertChunksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TInsertChunks> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TInsertChunks::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyInsertChunksArgs.session", &f_1)?;
    verify_required_field_exists("HeavyInsertChunksArgs.insert_chunks", &f_2)?;
    let ret = HeavyInsertChunksArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      insert_chunks: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insert_chunks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("insert_chunks", TType::Struct, 2))?;
    self.insert_chunks.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyInsertChunksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyInsertChunksResult {
  e: Option<TDBException>,
}

impl HeavyInsertChunksResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyInsertChunksResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyInsertChunksResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyInsertChunksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyCheckpointArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCheckpointArgs {
  session: TSessionId,
  table_id: i32,
}

impl HeavyCheckpointArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCheckpointArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyCheckpointArgs.session", &f_1)?;
    verify_required_field_exists("HeavyCheckpointArgs.table_id", &f_2)?;
    let ret = HeavyCheckpointArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkpoint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyCheckpointResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyCheckpointResult {
  e: Option<TDBException>,
}

impl HeavyCheckpointResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyCheckpointResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyCheckpointResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyCheckpointResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyGetRolesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetRolesArgs {
  session: TSessionId,
}

impl HeavyGetRolesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetRolesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetRolesArgs.session", &f_1)?;
    let ret = HeavyGetRolesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_roles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetRolesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetRolesResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetRolesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetRolesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_96 = i_prot.read_string()?;
            val.push(list_elem_96);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetRolesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetRolesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetRoles"
          )
        )
      )
    }
  }
}

//
// HeavyGetDbObjectsForGranteeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDbObjectsForGranteeArgs {
  session: TSessionId,
  role_name: String,
}

impl HeavyGetDbObjectsForGranteeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDbObjectsForGranteeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDbObjectsForGranteeArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetDbObjectsForGranteeArgs.role_name", &f_2)?;
    let ret = HeavyGetDbObjectsForGranteeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      role_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_db_objects_for_grantee_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 2))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDbObjectsForGranteeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDbObjectsForGranteeResult {
  result_value: Option<Vec<TDBObject>>,
  e: Option<TDBException>,
}

impl HeavyGetDbObjectsForGranteeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDbObjectsForGranteeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBObject>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBObject> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_97 = TDBObject::read_from_in_protocol(i_prot)?;
            val.push(list_elem_97);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDbObjectsForGranteeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDbObjectsForGranteeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBObject>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDbObjectsForGrantee"
          )
        )
      )
    }
  }
}

//
// HeavyGetDbObjectPrivsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDbObjectPrivsArgs {
  session: TSessionId,
  object_name: String,
  type_: TDBObjectType,
}

impl HeavyGetDbObjectPrivsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDbObjectPrivsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TDBObjectType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDbObjectPrivsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetDbObjectPrivsArgs.object_name", &f_2)?;
    verify_required_field_exists("HeavyGetDbObjectPrivsArgs.type_", &f_3)?;
    let ret = HeavyGetDbObjectPrivsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      object_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_db_object_privs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 2))?;
    o_prot.write_string(&self.object_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDbObjectPrivsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDbObjectPrivsResult {
  result_value: Option<Vec<TDBObject>>,
  e: Option<TDBException>,
}

impl HeavyGetDbObjectPrivsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDbObjectPrivsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBObject>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBObject> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_98 = TDBObject::read_from_in_protocol(i_prot)?;
            val.push(list_elem_98);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDbObjectPrivsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDbObjectPrivsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBObject>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDbObjectPrivs"
          )
        )
      )
    }
  }
}

//
// HeavyGetAllRolesForUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetAllRolesForUserArgs {
  session: TSessionId,
  user_name: String,
}

impl HeavyGetAllRolesForUserArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetAllRolesForUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetAllRolesForUserArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetAllRolesForUserArgs.user_name", &f_2)?;
    let ret = HeavyGetAllRolesForUserArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_roles_for_user_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 2))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetAllRolesForUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetAllRolesForUserResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetAllRolesForUserResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetAllRolesForUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_99 = i_prot.read_string()?;
            val.push(list_elem_99);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetAllRolesForUserResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetAllRolesForUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetAllRolesForUser"
          )
        )
      )
    }
  }
}

//
// HeavyGetAllEffectiveRolesForUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetAllEffectiveRolesForUserArgs {
  session: TSessionId,
  user_name: String,
}

impl HeavyGetAllEffectiveRolesForUserArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetAllEffectiveRolesForUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetAllEffectiveRolesForUserArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetAllEffectiveRolesForUserArgs.user_name", &f_2)?;
    let ret = HeavyGetAllEffectiveRolesForUserArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_effective_roles_for_user_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 2))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetAllEffectiveRolesForUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetAllEffectiveRolesForUserResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetAllEffectiveRolesForUserResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetAllEffectiveRolesForUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_100 = i_prot.read_string()?;
            val.push(list_elem_100);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetAllEffectiveRolesForUserResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetAllEffectiveRolesForUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetAllEffectiveRolesForUser"
          )
        )
      )
    }
  }
}

//
// HeavyHasRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyHasRoleArgs {
  session: TSessionId,
  grantee_name: String,
  role_name: String,
}

impl HeavyHasRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyHasRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyHasRoleArgs.session", &f_1)?;
    verify_required_field_exists("HeavyHasRoleArgs.grantee_name", &f_2)?;
    verify_required_field_exists("HeavyHasRoleArgs.role_name", &f_3)?;
    let ret = HeavyHasRoleArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      grantee_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("granteeName", TType::String, 2))?;
    o_prot.write_string(&self.grantee_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 3))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyHasRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyHasRoleResult {
  result_value: Option<bool>,
  e: Option<TDBException>,
}

impl HeavyHasRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyHasRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyHasRoleResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyHasRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyHasRole"
          )
        )
      )
    }
  }
}

//
// HeavyHasObjectPrivilegeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyHasObjectPrivilegeArgs {
  session: TSessionId,
  grantee_name: String,
  object_name: String,
  object_type: TDBObjectType,
  permissions: TDBObjectPermissions,
}

impl HeavyHasObjectPrivilegeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyHasObjectPrivilegeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TDBObjectType> = None;
    let mut f_5: Option<TDBObjectPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDBObjectPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyHasObjectPrivilegeArgs.session", &f_1)?;
    verify_required_field_exists("HeavyHasObjectPrivilegeArgs.grantee_name", &f_2)?;
    verify_required_field_exists("HeavyHasObjectPrivilegeArgs.object_name", &f_3)?;
    verify_required_field_exists("HeavyHasObjectPrivilegeArgs.object_type", &f_4)?;
    verify_required_field_exists("HeavyHasObjectPrivilegeArgs.permissions", &f_5)?;
    let ret = HeavyHasObjectPrivilegeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      grantee_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      object_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      object_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_object_privilege_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("granteeName", TType::String, 2))?;
    o_prot.write_string(&self.grantee_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ObjectName", TType::String, 3))?;
    o_prot.write_string(&self.object_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 4))?;
    self.object_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyHasObjectPrivilegeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyHasObjectPrivilegeResult {
  result_value: Option<bool>,
  e: Option<TDBException>,
}

impl HeavyHasObjectPrivilegeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyHasObjectPrivilegeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyHasObjectPrivilegeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyHasObjectPrivilegeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyHasObjectPrivilege"
          )
        )
      )
    }
  }
}

//
// HeavySetLicenseKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetLicenseKeyArgs {
  session: TSessionId,
  key: String,
  nonce: String,
}

impl HeavySetLicenseKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetLicenseKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavySetLicenseKeyArgs.session", &f_1)?;
    verify_required_field_exists("HeavySetLicenseKeyArgs.key", &f_2)?;
    verify_required_field_exists("HeavySetLicenseKeyArgs.nonce", &f_3)?;
    let ret = HeavySetLicenseKeyArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_license_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 3))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavySetLicenseKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavySetLicenseKeyResult {
  result_value: Option<TLicenseInfo>,
  e: Option<TDBException>,
}

impl HeavySetLicenseKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavySetLicenseKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TLicenseInfo> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TLicenseInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavySetLicenseKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavySetLicenseKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TLicenseInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavySetLicenseKey"
          )
        )
      )
    }
  }
}

//
// HeavyGetLicenseClaimsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetLicenseClaimsArgs {
  session: TSessionId,
  nonce: String,
}

impl HeavyGetLicenseClaimsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetLicenseClaimsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetLicenseClaimsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetLicenseClaimsArgs.nonce", &f_2)?;
    let ret = HeavyGetLicenseClaimsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_license_claims_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 2))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetLicenseClaimsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetLicenseClaimsResult {
  result_value: Option<TLicenseInfo>,
  e: Option<TDBException>,
}

impl HeavyGetLicenseClaimsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetLicenseClaimsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TLicenseInfo> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TLicenseInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetLicenseClaimsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetLicenseClaimsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TLicenseInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetLicenseClaims"
          )
        )
      )
    }
  }
}

//
// HeavyGetDeviceParametersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDeviceParametersArgs {
  session: TSessionId,
}

impl HeavyGetDeviceParametersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDeviceParametersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetDeviceParametersArgs.session", &f_1)?;
    let ret = HeavyGetDeviceParametersArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_device_parameters_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetDeviceParametersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetDeviceParametersResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TDBException>,
}

impl HeavyGetDeviceParametersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetDeviceParametersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_101 = i_prot.read_string()?;
            let map_val_102 = i_prot.read_string()?;
            val.insert(map_key_101, map_val_102);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetDeviceParametersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetDeviceParametersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetDeviceParameters"
          )
        )
      )
    }
  }
}

//
// HeavyRegisterRuntimeExtensionFunctionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyRegisterRuntimeExtensionFunctionsArgs {
  session: TSessionId,
  udfs: Vec<extension_functions::TUserDefinedFunction>,
  udtfs: Vec<extension_functions::TUserDefinedTableFunction>,
  device_ir_map: BTreeMap<String, String>,
}

impl HeavyRegisterRuntimeExtensionFunctionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyRegisterRuntimeExtensionFunctionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<extension_functions::TUserDefinedFunction>> = None;
    let mut f_3: Option<Vec<extension_functions::TUserDefinedTableFunction>> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_103 = extension_functions::TUserDefinedFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_103);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedTableFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_104 = extension_functions::TUserDefinedTableFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_104);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_105 = i_prot.read_string()?;
            let map_val_106 = i_prot.read_string()?;
            val.insert(map_key_105, map_val_106);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyRegisterRuntimeExtensionFunctionsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyRegisterRuntimeExtensionFunctionsArgs.udfs", &f_2)?;
    verify_required_field_exists("HeavyRegisterRuntimeExtensionFunctionsArgs.udtfs", &f_3)?;
    verify_required_field_exists("HeavyRegisterRuntimeExtensionFunctionsArgs.device_ir_map", &f_4)?;
    let ret = HeavyRegisterRuntimeExtensionFunctionsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      udfs: f_2.expect("auto-generated code should have checked for presence of required fields"),
      udtfs: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_ir_map: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("register_runtime_extension_functions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udfs", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.udfs.len() as i32))?;
    for e in &self.udfs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udtfs", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.udtfs.len() as i32))?;
    for e in &self.udtfs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_ir_map", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.device_ir_map.len() as i32))?;
    for (k, v) in &self.device_ir_map {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyRegisterRuntimeExtensionFunctionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyRegisterRuntimeExtensionFunctionsResult {
  e: Option<TDBException>,
}

impl HeavyRegisterRuntimeExtensionFunctionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyRegisterRuntimeExtensionFunctionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyRegisterRuntimeExtensionFunctionsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyRegisterRuntimeExtensionFunctionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// HeavyGetTableFunctionNamesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableFunctionNamesArgs {
  session: TSessionId,
}

impl HeavyGetTableFunctionNamesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableFunctionNamesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableFunctionNamesArgs.session", &f_1)?;
    let ret = HeavyGetTableFunctionNamesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_function_names_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableFunctionNamesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableFunctionNamesResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetTableFunctionNamesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableFunctionNamesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_107 = i_prot.read_string()?;
            val.push(list_elem_107);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableFunctionNamesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableFunctionNamesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableFunctionNames"
          )
        )
      )
    }
  }
}

//
// HeavyGetRuntimeTableFunctionNamesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetRuntimeTableFunctionNamesArgs {
  session: TSessionId,
}

impl HeavyGetRuntimeTableFunctionNamesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetRuntimeTableFunctionNamesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetRuntimeTableFunctionNamesArgs.session", &f_1)?;
    let ret = HeavyGetRuntimeTableFunctionNamesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_runtime_table_function_names_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetRuntimeTableFunctionNamesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetRuntimeTableFunctionNamesResult {
  result_value: Option<Vec<String>>,
  e: Option<TDBException>,
}

impl HeavyGetRuntimeTableFunctionNamesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetRuntimeTableFunctionNamesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_108 = i_prot.read_string()?;
            val.push(list_elem_108);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetRuntimeTableFunctionNamesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetRuntimeTableFunctionNamesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetRuntimeTableFunctionNames"
          )
        )
      )
    }
  }
}

//
// HeavyGetTableFunctionDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableFunctionDetailsArgs {
  session: TSessionId,
  udtf_names: Vec<String>,
}

impl HeavyGetTableFunctionDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableFunctionDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_109 = i_prot.read_string()?;
            val.push(list_elem_109);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeavyGetTableFunctionDetailsArgs.session", &f_1)?;
    verify_required_field_exists("HeavyGetTableFunctionDetailsArgs.udtf_names", &f_2)?;
    let ret = HeavyGetTableFunctionDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      udtf_names: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_function_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udtf_names", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.udtf_names.len() as i32))?;
    for e in &self.udtf_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeavyGetTableFunctionDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct HeavyGetTableFunctionDetailsResult {
  result_value: Option<Vec<extension_functions::TUserDefinedTableFunction>>,
  e: Option<TDBException>,
}

impl HeavyGetTableFunctionDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeavyGetTableFunctionDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<extension_functions::TUserDefinedTableFunction>> = None;
    let mut f_1: Option<TDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedTableFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_110 = extension_functions::TUserDefinedTableFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_110);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TDBException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeavyGetTableFunctionDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeavyGetTableFunctionDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<extension_functions::TUserDefinedTableFunction>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for HeavyGetTableFunctionDetails"
          )
        )
      )
    }
  }
}
