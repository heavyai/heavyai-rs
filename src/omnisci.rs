// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(clippy::too_many_arguments, clippy::type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::common;
use crate::completion_hints;
use crate::extension_functions;
use crate::serialized_result_set;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TExecuteMode {
  Gpu = 1,
  Cpu = 2,
}

impl TExecuteMode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExecuteMode> {
    let enum_value = i_prot.read_i32()?;
    TExecuteMode::try_from(enum_value)  }
}

impl TryFrom<i32> for TExecuteMode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(TExecuteMode::Gpu),
      2 => Ok(TExecuteMode::Cpu),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TExecuteMode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TFileType {
  Delimited = 0,
  Polygon = 1,
  Parquet = 2,
}

impl TFileType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileType> {
    let enum_value = i_prot.read_i32()?;
    TFileType::try_from(enum_value)  }
}

impl TryFrom<i32> for TFileType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TFileType::Delimited),
      1 => Ok(TFileType::Polygon),
      2 => Ok(TFileType::Parquet),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TFileType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TPartitionDetail {
  Default = 0,
  Replicated = 1,
  Sharded = 2,
  Other = 3,
}

impl TPartitionDetail {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionDetail> {
    let enum_value = i_prot.read_i32()?;
    TPartitionDetail::try_from(enum_value)  }
}

impl TryFrom<i32> for TPartitionDetail {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TPartitionDetail::Default),
      1 => Ok(TPartitionDetail::Replicated),
      2 => Ok(TPartitionDetail::Sharded),
      3 => Ok(TPartitionDetail::Other),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TPartitionDetail", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TGeoFileLayerContents {
  Empty = 0,
  Geo = 1,
  NonGeo = 2,
  UnsupportedGeo = 3,
}

impl TGeoFileLayerContents {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGeoFileLayerContents> {
    let enum_value = i_prot.read_i32()?;
    TGeoFileLayerContents::try_from(enum_value)  }
}

impl TryFrom<i32> for TGeoFileLayerContents {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TGeoFileLayerContents::Empty),
      1 => Ok(TGeoFileLayerContents::Geo),
      2 => Ok(TGeoFileLayerContents::NonGeo),
      3 => Ok(TGeoFileLayerContents::UnsupportedGeo),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TGeoFileLayerContents", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TImportHeaderRow {
  Autodetect = 0,
  NoHeader = 1,
  HasHeader = 2,
}

impl TImportHeaderRow {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TImportHeaderRow> {
    let enum_value = i_prot.read_i32()?;
    TImportHeaderRow::try_from(enum_value)  }
}

impl TryFrom<i32> for TImportHeaderRow {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TImportHeaderRow::Autodetect),
      1 => Ok(TImportHeaderRow::NoHeader),
      2 => Ok(TImportHeaderRow::HasHeader),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TImportHeaderRow", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TRole {
  Server = 0,
  Aggregator = 1,
  Leaf = 2,
  StringDictionary = 3,
}

impl TRole {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRole> {
    let enum_value = i_prot.read_i32()?;
    TRole::try_from(enum_value)  }
}

impl TryFrom<i32> for TRole {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TRole::Server),
      1 => Ok(TRole::Aggregator),
      2 => Ok(TRole::Leaf),
      3 => Ok(TRole::StringDictionary),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TRole", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TMergeType {
  Union = 0,
  Reduce = 1,
}

impl TMergeType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMergeType> {
    let enum_value = i_prot.read_i32()?;
    TMergeType::try_from(enum_value)  }
}

impl TryFrom<i32> for TMergeType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TMergeType::Union),
      1 => Ok(TMergeType::Reduce),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TMergeType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TQueryType {
  Unknown = 0,
  Read = 1,
  Write = 2,
  SchemaRead = 3,
  SchemaWrite = 4,
}

impl TQueryType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryType> {
    let enum_value = i_prot.read_i32()?;
    TQueryType::try_from(enum_value)  }
}

impl TryFrom<i32> for TQueryType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TQueryType::Unknown),
      1 => Ok(TQueryType::Read),
      2 => Ok(TQueryType::Write),
      3 => Ok(TQueryType::SchemaRead),
      4 => Ok(TQueryType::SchemaWrite),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TQueryType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TExpressionRangeType {
  Invalid = 0,
  Integer = 1,
  Float = 2,
  Double = 3,
}

impl TExpressionRangeType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExpressionRangeType> {
    let enum_value = i_prot.read_i32()?;
    TExpressionRangeType::try_from(enum_value)  }
}

impl TryFrom<i32> for TExpressionRangeType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TExpressionRangeType::Invalid),
      1 => Ok(TExpressionRangeType::Integer),
      2 => Ok(TExpressionRangeType::Float),
      3 => Ok(TExpressionRangeType::Double),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TExpressionRangeType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDBObjectType {
  AbstractDBObjectType = 0,
  DatabaseDBObjectType = 1,
  TableDBObjectType = 2,
  DashboardDBObjectType = 3,
  ViewDBObjectType = 4,
}

impl TDBObjectType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObjectType> {
    let enum_value = i_prot.read_i32()?;
    TDBObjectType::try_from(enum_value)  }
}

impl TryFrom<i32> for TDBObjectType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TDBObjectType::AbstractDBObjectType),
      1 => Ok(TDBObjectType::DatabaseDBObjectType),
      2 => Ok(TDBObjectType::TableDBObjectType),
      3 => Ok(TDBObjectType::DashboardDBObjectType),
      4 => Ok(TDBObjectType::ViewDBObjectType),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TDBObjectType", i)
            )
          )
        )
      },
    }
  }
}

pub type TRowDescriptor = Vec<TColumnType>;

pub type TSessionId = String;

pub type TKrb5Token = String;

pub type TQueryId = i64;

pub type TRenderPassMap = BTreeMap<i32, TRawRenderPassDataResult>;

pub type TRenderAggDataMap = BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>>;

//
// TDatumVal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatumVal {
  pub int_val: Option<i64>,
  pub real_val: Option<OrderedFloat<f64>>,
  pub str_val: Option<String>,
  pub arr_val: Option<Vec<Box<TDatum>>>,
}

impl TDatumVal {
  pub fn new<F1, F2, F3, F4>(int_val: F1, real_val: F2, str_val: F3, arr_val: F4) -> TDatumVal where F1: Into<Option<i64>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<String>>, F4: Into<Option<Vec<Box<TDatum>>>> {
    TDatumVal {
      int_val: int_val.into(),
      real_val: real_val.into(),
      str_val: str_val.into(),
      arr_val: arr_val.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatumVal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<Box<TDatum>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TDatum>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TDatum::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatumVal {
      int_val: f_1,
      real_val: f_2,
      str_val: f_3,
      arr_val: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatumVal");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.int_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_val", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.real_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("real_val", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.str_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_val", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.arr_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("arr_val", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatumVal {
  fn default() -> Self {
    TDatumVal{
      int_val: Some(0),
      real_val: Some(OrderedFloat::from(0.0)),
      str_val: Some("".to_owned()),
      arr_val: Some(Vec::new()),
    }
  }
}

//
// TDatum
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatum {
  pub val: Option<TDatumVal>,
  pub is_null: Option<bool>,
}

impl TDatum {
  pub fn new<F1, F2>(val: F1, is_null: F2) -> TDatum where F1: Into<Option<TDatumVal>>, F2: Into<Option<bool>> {
    TDatum {
      val: val.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatum> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDatumVal> = None;
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatumVal::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatum {
      val: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatum");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.val {
      o_prot.write_field_begin(&TFieldIdentifier::new("val", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatum {
  fn default() -> Self {
    TDatum{
      val: None,
      is_null: Some(false),
    }
  }
}

//
// TStringValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringValue {
  pub str_val: Option<String>,
  pub is_null: Option<bool>,
}

impl TStringValue {
  pub fn new<F1, F2>(str_val: F1, is_null: F2) -> TStringValue where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    TStringValue {
      str_val: str_val.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringValue {
      str_val: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.str_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_val", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringValue {
  fn default() -> Self {
    TStringValue{
      str_val: Some("".to_owned()),
      is_null: Some(false),
    }
  }
}

//
// TColumnType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnType {
  pub col_name: Option<String>,
  pub col_type: Option<common::TTypeInfo>,
  pub is_reserved_keyword: Option<bool>,
  pub src_name: Option<String>,
  pub is_system: Option<bool>,
  pub is_physical: Option<bool>,
  pub col_id: Option<i64>,
}

impl TColumnType {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(col_name: F1, col_type: F2, is_reserved_keyword: F3, src_name: F4, is_system: F5, is_physical: F6, col_id: F7) -> TColumnType where F1: Into<Option<String>>, F2: Into<Option<common::TTypeInfo>>, F3: Into<Option<bool>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<i64>> {
    TColumnType {
      col_name: col_name.into(),
      col_type: col_type.into(),
      is_reserved_keyword: is_reserved_keyword.into(),
      src_name: src_name.into(),
      is_system: is_system.into(),
      is_physical: is_physical.into(),
      col_id: col_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<common::TTypeInfo> = None;
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = common::TTypeInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnType {
      col_name: f_1,
      col_type: f_2,
      is_reserved_keyword: f_3,
      src_name: f_4,
      is_system: f_5,
      is_physical: f_6,
      col_id: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.col_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_type", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_reserved_keyword {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_reserved_keyword", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.src_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("src_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_system {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_system", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_physical {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_physical", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.col_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_id", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnType {
  fn default() -> Self {
    TColumnType{
      col_name: Some("".to_owned()),
      col_type: None,
      is_reserved_keyword: Some(false),
      src_name: Some("".to_owned()),
      is_system: Some(false),
      is_physical: Some(false),
      col_id: Some(0),
    }
  }
}

//
// TRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRow {
  pub cols: Option<Vec<TDatum>>,
}

impl TRow {
  pub fn new<F1>(cols: F1) -> TRow where F1: Into<Option<Vec<TDatum>>> {
    TRow {
      cols: cols.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TDatum>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDatum> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = TDatum::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRow {
      cols: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRow");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRow {
  fn default() -> Self {
    TRow{
      cols: Some(Vec::new()),
    }
  }
}

//
// TColumnData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnData {
  pub int_col: Option<Vec<i64>>,
  pub real_col: Option<Vec<OrderedFloat<f64>>>,
  pub str_col: Option<Vec<String>>,
  pub arr_col: Option<Vec<Box<TColumn>>>,
}

impl TColumnData {
  pub fn new<F1, F2, F3, F4>(int_col: F1, real_col: F2, str_col: F3, arr_col: F4) -> TColumnData where F1: Into<Option<Vec<i64>>>, F2: Into<Option<Vec<OrderedFloat<f64>>>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<Vec<Box<TColumn>>>> {
    TColumnData {
      int_col: int_col.into(),
      real_col: real_col.into(),
      str_col: str_col.into(),
      arr_col: arr_col.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = Some(Vec::new());
    let mut f_2: Option<Vec<OrderedFloat<f64>>> = Some(Vec::new());
    let mut f_3: Option<Vec<String>> = Some(Vec::new());
    let mut f_4: Option<Vec<Box<TColumn>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_i64()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = OrderedFloat::from(i_prot.read_double()?);
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TColumn>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = Box::new(TColumn::read_from_in_protocol(i_prot)?);
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnData {
      int_col: f_1,
      real_col: f_2,
      str_col: f_3,
      arr_col: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.int_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_col", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.real_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("real_col", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_double((*e).into())?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.str_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_col", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.arr_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("arr_col", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnData {
  fn default() -> Self {
    TColumnData{
      int_col: Some(Vec::new()),
      real_col: Some(Vec::new()),
      str_col: Some(Vec::new()),
      arr_col: Some(Vec::new()),
    }
  }
}

//
// TColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumn {
  pub data: Option<TColumnData>,
  pub nulls: Option<Vec<bool>>,
}

impl TColumn {
  pub fn new<F1, F2>(data: F1, nulls: F2) -> TColumn where F1: Into<Option<TColumnData>>, F2: Into<Option<Vec<bool>>> {
    TColumn {
      data: data.into(),
      nulls: nulls.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TColumnData> = None;
    let mut f_2: Option<Vec<bool>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TColumnData::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_bool()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumn {
      data: f_1,
      nulls: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumn {
  fn default() -> Self {
    TColumn{
      data: None,
      nulls: Some(Vec::new()),
    }
  }
}

//
// TStringRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringRow {
  pub cols: Option<Vec<TStringValue>>,
}

impl TStringRow {
  pub fn new<F1>(cols: F1) -> TStringRow where F1: Into<Option<Vec<TStringValue>>> {
    TStringRow {
      cols: cols.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TStringValue>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStringValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = TStringValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringRow {
      cols: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringRow");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringRow {
  fn default() -> Self {
    TStringRow{
      cols: Some(Vec::new()),
    }
  }
}

//
// TKrb5Session
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TKrb5Session {
  pub session_id: Option<TSessionId>,
  pub krb_token: Option<TKrb5Token>,
}

impl TKrb5Session {
  pub fn new<F1, F2>(session_id: F1, krb_token: F2) -> TKrb5Session where F1: Into<Option<TSessionId>>, F2: Into<Option<TKrb5Token>> {
    TKrb5Session {
      session_id: session_id.into(),
      krb_token: krb_token.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TKrb5Session> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = Some("".to_owned());
    let mut f_2: Option<TKrb5Token> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TKrb5Session {
      session_id: f_1,
      krb_token: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TKrb5Session");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.krb_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("krbToken", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TKrb5Session {
  fn default() -> Self {
    TKrb5Session{
      session_id: Some("".to_owned()),
      krb_token: Some("".to_owned()),
    }
  }
}

//
// TStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStepResult {
  pub serialized_rows: Option<serialized_result_set::TSerializedRows>,
  pub execution_finished: Option<bool>,
  pub merge_type: Option<TMergeType>,
  pub sharded: Option<bool>,
  pub row_desc: Option<TRowDescriptor>,
  pub node_id: Option<i32>,
}

impl TStepResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(serialized_rows: F1, execution_finished: F2, merge_type: F3, sharded: F4, row_desc: F5, node_id: F6) -> TStepResult where F1: Into<Option<serialized_result_set::TSerializedRows>>, F2: Into<Option<bool>>, F3: Into<Option<TMergeType>>, F4: Into<Option<bool>>, F5: Into<Option<TRowDescriptor>>, F6: Into<Option<i32>> {
    TStepResult {
      serialized_rows: serialized_rows.into(),
      execution_finished: execution_finished.into(),
      merge_type: merge_type.into(),
      sharded: sharded.into(),
      row_desc: row_desc.into(),
      node_id: node_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<serialized_result_set::TSerializedRows> = None;
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<TMergeType> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_6: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = serialized_result_set::TSerializedRows::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TMergeType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStepResult {
      serialized_rows: f_1,
      execution_finished: f_2,
      merge_type: f_3,
      sharded: f_4,
      row_desc: f_5,
      node_id: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.serialized_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_rows", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_finished {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_finished", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.merge_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sharded {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharded", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.node_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStepResult {
  fn default() -> Self {
    TStepResult{
      serialized_rows: None,
      execution_finished: Some(false),
      merge_type: None,
      sharded: Some(false),
      row_desc: Some(Vec::new()),
      node_id: Some(0),
    }
  }
}

//
// TRowSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRowSet {
  pub row_desc: Option<TRowDescriptor>,
  pub rows: Option<Vec<TRow>>,
  pub columns: Option<Vec<TColumn>>,
  pub is_columnar: Option<bool>,
}

impl TRowSet {
  pub fn new<F1, F2, F3, F4>(row_desc: F1, rows: F2, columns: F3, is_columnar: F4) -> TRowSet where F1: Into<Option<TRowDescriptor>>, F2: Into<Option<Vec<TRow>>>, F3: Into<Option<Vec<TColumn>>>, F4: Into<Option<bool>> {
    TRowSet {
      row_desc: row_desc.into(),
      rows: rows.into(),
      columns: columns.into(),
      is_columnar: is_columnar.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRowSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_2: Option<Vec<TRow>> = Some(Vec::new());
    let mut f_3: Option<Vec<TColumn>> = Some(Vec::new());
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRowSet {
      row_desc: f_1,
      rows: f_2,
      columns: f_3,
      is_columnar: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRowSet");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_columnar {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_columnar", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRowSet {
  fn default() -> Self {
    TRowSet{
      row_desc: Some(Vec::new()),
      rows: Some(Vec::new()),
      columns: Some(Vec::new()),
      is_columnar: Some(false),
    }
  }
}

//
// TQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryResult {
  pub row_set: Option<TRowSet>,
  pub execution_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
  pub nonce: Option<String>,
  pub debug: Option<String>,
  pub success: Option<bool>,
  pub query_type: Option<TQueryType>,
}

impl TQueryResult {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(row_set: F1, execution_time_ms: F2, total_time_ms: F3, nonce: F4, debug: F5, success: F6, query_type: F7) -> TQueryResult where F1: Into<Option<TRowSet>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<bool>>, F7: Into<Option<TQueryType>> {
    TQueryResult {
      row_set: row_set.into(),
      execution_time_ms: execution_time_ms.into(),
      total_time_ms: total_time_ms.into(),
      nonce: nonce.into(),
      debug: debug.into(),
      success: success.into(),
      query_type: query_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowSet> = None;
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<TQueryType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = TQueryType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TQueryResult {
      row_set: f_1,
      execution_time_ms: f_2,
      total_time_ms: f_3,
      nonce: f_4,
      debug: f_5,
      success: f_6,
      query_type: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.debug {
      o_prot.write_field_begin(&TFieldIdentifier::new("debug", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_type", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TQueryResult {
  fn default() -> Self {
    TQueryResult{
      row_set: None,
      execution_time_ms: Some(0),
      total_time_ms: Some(0),
      nonce: Some("".to_owned()),
      debug: Some("".to_owned()),
      success: Some(false),
      query_type: None,
    }
  }
}

//
// TDataFrame
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataFrame {
  pub sm_handle: Option<Vec<u8>>,
  pub sm_size: Option<i64>,
  pub df_handle: Option<Vec<u8>>,
  pub df_size: Option<i64>,
  pub execution_time_ms: Option<i64>,
  pub arrow_conversion_time_ms: Option<i64>,
}

impl TDataFrame {
  pub fn new<F1, F2, F3, F4, F5, F6>(sm_handle: F1, sm_size: F2, df_handle: F3, df_size: F4, execution_time_ms: F5, arrow_conversion_time_ms: F6) -> TDataFrame where F1: Into<Option<Vec<u8>>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<i64>> {
    TDataFrame {
      sm_handle: sm_handle.into(),
      sm_size: sm_size.into(),
      df_handle: df_handle.into(),
      df_size: df_size.into(),
      execution_time_ms: execution_time_ms.into(),
      arrow_conversion_time_ms: arrow_conversion_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataFrame> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDataFrame {
      sm_handle: f_1,
      sm_size: f_2,
      df_handle: f_3,
      df_size: f_4,
      execution_time_ms: f_5,
      arrow_conversion_time_ms: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataFrame");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.sm_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("sm_handle", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sm_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("sm_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.df_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_handle", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.df_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_size", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.arrow_conversion_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("arrow_conversion_time_ms", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDataFrame {
  fn default() -> Self {
    TDataFrame{
      sm_handle: Some(Vec::new()),
      sm_size: Some(0),
      df_handle: Some(Vec::new()),
      df_size: Some(0),
      execution_time_ms: Some(0),
      arrow_conversion_time_ms: Some(0),
    }
  }
}

//
// TDBInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBInfo {
  pub db_name: Option<String>,
  pub db_owner: Option<String>,
}

impl TDBInfo {
  pub fn new<F1, F2>(db_name: F1, db_owner: F2) -> TDBInfo where F1: Into<Option<String>>, F2: Into<Option<String>> {
    TDBInfo {
      db_name: db_name.into(),
      db_owner: db_owner.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBInfo {
      db_name: f_1,
      db_owner: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.db_owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_owner", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBInfo {
  fn default() -> Self {
    TDBInfo{
      db_name: Some("".to_owned()),
      db_owner: Some("".to_owned()),
    }
  }
}

//
// TOmniSciException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOmniSciException {
  pub error_msg: Option<String>,
}

impl TOmniSciException {
  pub fn new<F1>(error_msg: F1) -> TOmniSciException where F1: Into<Option<String>> {
    TOmniSciException {
      error_msg: error_msg.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOmniSciException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TOmniSciException {
      error_msg: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOmniSciException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.error_msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("error_msg", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TOmniSciException {
  fn default() -> Self {
    TOmniSciException{
      error_msg: Some("".to_owned()),
    }
  }
}

impl Error for TOmniSciException {
  fn description(&self) -> &str {
    "remote service threw TOmniSciException"
  }
}

impl From<TOmniSciException> for thrift::Error {
  fn from(e: TOmniSciException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TOmniSciException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// TCopyParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCopyParams {
  pub delimiter: Option<String>,
  pub null_str: Option<String>,
  pub has_header: Option<TImportHeaderRow>,
  pub quoted: Option<bool>,
  pub quote: Option<String>,
  pub escape: Option<String>,
  pub line_delim: Option<String>,
  pub array_delim: Option<String>,
  pub array_begin: Option<String>,
  pub array_end: Option<String>,
  pub threads: Option<i32>,
  pub file_type: Option<TFileType>,
  pub s3_access_key: Option<String>,
  pub s3_secret_key: Option<String>,
  pub s3_region: Option<String>,
  pub geo_coords_encoding: Option<common::TEncodingType>,
  pub geo_coords_comp_param: Option<i32>,
  pub geo_coords_type: Option<common::TDatumType>,
  pub geo_coords_srid: Option<i32>,
  pub sanitize_column_names: Option<bool>,
  pub geo_layer_name: Option<String>,
  pub s3_endpoint: Option<String>,
  pub geo_assign_render_groups: Option<bool>,
  pub geo_explode_collections: Option<bool>,
}

impl TCopyParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24>(delimiter: F1, null_str: F2, has_header: F3, quoted: F4, quote: F5, escape: F6, line_delim: F7, array_delim: F8, array_begin: F9, array_end: F10, threads: F11, file_type: F12, s3_access_key: F13, s3_secret_key: F14, s3_region: F15, geo_coords_encoding: F16, geo_coords_comp_param: F17, geo_coords_type: F18, geo_coords_srid: F19, sanitize_column_names: F20, geo_layer_name: F21, s3_endpoint: F22, geo_assign_render_groups: F23, geo_explode_collections: F24) -> TCopyParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<TImportHeaderRow>>, F4: Into<Option<bool>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<i32>>, F12: Into<Option<TFileType>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<String>>, F16: Into<Option<common::TEncodingType>>, F17: Into<Option<i32>>, F18: Into<Option<common::TDatumType>>, F19: Into<Option<i32>>, F20: Into<Option<bool>>, F21: Into<Option<String>>, F22: Into<Option<String>>, F23: Into<Option<bool>>, F24: Into<Option<bool>> {
    TCopyParams {
      delimiter: delimiter.into(),
      null_str: null_str.into(),
      has_header: has_header.into(),
      quoted: quoted.into(),
      quote: quote.into(),
      escape: escape.into(),
      line_delim: line_delim.into(),
      array_delim: array_delim.into(),
      array_begin: array_begin.into(),
      array_end: array_end.into(),
      threads: threads.into(),
      file_type: file_type.into(),
      s3_access_key: s3_access_key.into(),
      s3_secret_key: s3_secret_key.into(),
      s3_region: s3_region.into(),
      geo_coords_encoding: geo_coords_encoding.into(),
      geo_coords_comp_param: geo_coords_comp_param.into(),
      geo_coords_type: geo_coords_type.into(),
      geo_coords_srid: geo_coords_srid.into(),
      sanitize_column_names: sanitize_column_names.into(),
      geo_layer_name: geo_layer_name.into(),
      s3_endpoint: s3_endpoint.into(),
      geo_assign_render_groups: geo_assign_render_groups.into(),
      geo_explode_collections: geo_explode_collections.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCopyParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<TImportHeaderRow> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<i32> = Some(0);
    let mut f_12: Option<TFileType> = None;
    let mut f_13: Option<String> = Some("".to_owned());
    let mut f_14: Option<String> = Some("".to_owned());
    let mut f_15: Option<String> = Some("".to_owned());
    let mut f_16: Option<common::TEncodingType> = None;
    let mut f_17: Option<i32> = Some(0);
    let mut f_18: Option<common::TDatumType> = None;
    let mut f_19: Option<i32> = Some(0);
    let mut f_20: Option<bool> = Some(false);
    let mut f_21: Option<String> = Some("".to_owned());
    let mut f_22: Option<String> = Some("".to_owned());
    let mut f_23: Option<bool> = Some(false);
    let mut f_24: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TImportHeaderRow::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TFileType::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let val = common::TEncodingType::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = common::TDatumType::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i32()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_bool()?;
          f_24 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCopyParams {
      delimiter: f_1,
      null_str: f_2,
      has_header: f_3,
      quoted: f_4,
      quote: f_5,
      escape: f_6,
      line_delim: f_7,
      array_delim: f_8,
      array_begin: f_9,
      array_end: f_10,
      threads: f_11,
      file_type: f_12,
      s3_access_key: f_13,
      s3_secret_key: f_14,
      s3_region: f_15,
      geo_coords_encoding: f_16,
      geo_coords_comp_param: f_17,
      geo_coords_type: f_18,
      geo_coords_srid: f_19,
      sanitize_column_names: f_20,
      geo_layer_name: f_21,
      s3_endpoint: f_22,
      geo_assign_render_groups: f_23,
      geo_explode_collections: f_24,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCopyParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("delimiter", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.null_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_str", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.has_header {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_header", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.quoted {
      o_prot.write_field_begin(&TFieldIdentifier::new("quoted", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.quote {
      o_prot.write_field_begin(&TFieldIdentifier::new("quote", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.escape {
      o_prot.write_field_begin(&TFieldIdentifier::new("escape", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.line_delim {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delim", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.array_delim {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_delim", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.array_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_begin", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.array_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_end", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.threads {
      o_prot.write_field_begin(&TFieldIdentifier::new("threads", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.file_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_access_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_access_key", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_secret_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_secret_key", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_region {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_region", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.geo_coords_encoding {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_encoding", TType::I32, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_coords_comp_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_comp_param", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.geo_coords_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_type", TType::I32, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_coords_srid {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_srid", TType::I32, 19))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sanitize_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("sanitize_column_names", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.geo_layer_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_layer_name", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_endpoint {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_endpoint", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_assign_render_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_assign_render_groups", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_explode_collections {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_explode_collections", TType::Bool, 24))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCopyParams {
  fn default() -> Self {
    TCopyParams{
      delimiter: Some("".to_owned()),
      null_str: Some("".to_owned()),
      has_header: None,
      quoted: Some(false),
      quote: Some("".to_owned()),
      escape: Some("".to_owned()),
      line_delim: Some("".to_owned()),
      array_delim: Some("".to_owned()),
      array_begin: Some("".to_owned()),
      array_end: Some("".to_owned()),
      threads: Some(0),
      file_type: None,
      s3_access_key: Some("".to_owned()),
      s3_secret_key: Some("".to_owned()),
      s3_region: Some("".to_owned()),
      geo_coords_encoding: None,
      geo_coords_comp_param: Some(0),
      geo_coords_type: None,
      geo_coords_srid: Some(0),
      sanitize_column_names: Some(false),
      geo_layer_name: Some("".to_owned()),
      s3_endpoint: Some("".to_owned()),
      geo_assign_render_groups: Some(false),
      geo_explode_collections: Some(false),
    }
  }
}

//
// TCreateParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCreateParams {
  pub is_replicated: Option<bool>,
}

impl TCreateParams {
  pub fn new<F1>(is_replicated: F1) -> TCreateParams where F1: Into<Option<bool>> {
    TCreateParams {
      is_replicated: is_replicated.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCreateParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCreateParams {
      is_replicated: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCreateParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_replicated {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_replicated", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCreateParams {
  fn default() -> Self {
    TCreateParams{
      is_replicated: Some(false),
    }
  }
}

//
// TDetectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDetectResult {
  pub row_set: Option<TRowSet>,
  pub copy_params: Option<TCopyParams>,
}

impl TDetectResult {
  pub fn new<F1, F2>(row_set: F1, copy_params: F2) -> TDetectResult where F1: Into<Option<TRowSet>>, F2: Into<Option<TCopyParams>> {
    TDetectResult {
      row_set: row_set.into(),
      copy_params: copy_params.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDetectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowSet> = None;
    let mut f_2: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDetectResult {
      row_set: f_1,
      copy_params: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDetectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.copy_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDetectResult {
  fn default() -> Self {
    TDetectResult{
      row_set: None,
      copy_params: None,
    }
  }
}

//
// TImportStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TImportStatus {
  pub elapsed: Option<i64>,
  pub rows_completed: Option<i64>,
  pub rows_estimated: Option<i64>,
  pub rows_rejected: Option<i64>,
}

impl TImportStatus {
  pub fn new<F1, F2, F3, F4>(elapsed: F1, rows_completed: F2, rows_estimated: F3, rows_rejected: F4) -> TImportStatus where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    TImportStatus {
      elapsed: elapsed.into(),
      rows_completed: rows_completed.into(),
      rows_estimated: rows_estimated.into(),
      rows_rejected: rows_rejected.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TImportStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TImportStatus {
      elapsed: f_1,
      rows_completed: f_2,
      rows_estimated: f_3,
      rows_rejected: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TImportStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.elapsed {
      o_prot.write_field_begin(&TFieldIdentifier::new("elapsed", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rows_completed {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_completed", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rows_estimated {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_estimated", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rows_rejected {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_rejected", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TImportStatus {
  fn default() -> Self {
    TImportStatus{
      elapsed: Some(0),
      rows_completed: Some(0),
      rows_estimated: Some(0),
      rows_rejected: Some(0),
    }
  }
}

//
// TFrontendView
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFrontendView {
  pub view_name: Option<String>,
  pub view_state: Option<String>,
  pub image_hash: Option<String>,
  pub update_time: Option<String>,
  pub view_metadata: Option<String>,
}

impl TFrontendView {
  pub fn new<F1, F2, F3, F4, F5>(view_name: F1, view_state: F2, image_hash: F3, update_time: F4, view_metadata: F5) -> TFrontendView where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    TFrontendView {
      view_name: view_name.into(),
      view_state: view_state.into(),
      image_hash: image_hash.into(),
      update_time: update_time.into(),
      view_metadata: view_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFrontendView> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFrontendView {
      view_name: f_1,
      view_state: f_2,
      image_hash: f_3,
      update_time: f_4,
      view_metadata: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFrontendView");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.view_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.view_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_state", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.image_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_time", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.view_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_metadata", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TFrontendView {
  fn default() -> Self {
    TFrontendView{
      view_name: Some("".to_owned()),
      view_state: Some("".to_owned()),
      image_hash: Some("".to_owned()),
      update_time: Some("".to_owned()),
      view_metadata: Some("".to_owned()),
    }
  }
}

//
// TDashboard
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboard {
  pub dashboard_name: Option<String>,
  pub dashboard_state: Option<String>,
  pub image_hash: Option<String>,
  pub update_time: Option<String>,
  pub dashboard_metadata: Option<String>,
  pub dashboard_id: Option<i32>,
  pub dashboard_owner: Option<String>,
  pub is_dash_shared: Option<bool>,
}

impl TDashboard {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(dashboard_name: F1, dashboard_state: F2, image_hash: F3, update_time: F4, dashboard_metadata: F5, dashboard_id: F6, dashboard_owner: F7, is_dash_shared: F8) -> TDashboard where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<String>>, F8: Into<Option<bool>> {
    TDashboard {
      dashboard_name: dashboard_name.into(),
      dashboard_state: dashboard_state.into(),
      image_hash: image_hash.into(),
      update_time: update_time.into(),
      dashboard_metadata: dashboard_metadata.into(),
      dashboard_id: dashboard_id.into(),
      dashboard_owner: dashboard_owner.into(),
      is_dash_shared: is_dash_shared.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboard> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboard {
      dashboard_name: f_1,
      dashboard_state: f_2,
      image_hash: f_3,
      update_time: f_4,
      dashboard_metadata: f_5,
      dashboard_id: f_6,
      dashboard_owner: f_7,
      is_dash_shared: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboard");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dashboard_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dashboard_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.image_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_time", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dashboard_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.dashboard_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dashboard_owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_owner", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_dash_shared {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_dash_shared", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboard {
  fn default() -> Self {
    TDashboard{
      dashboard_name: Some("".to_owned()),
      dashboard_state: Some("".to_owned()),
      image_hash: Some("".to_owned()),
      update_time: Some("".to_owned()),
      dashboard_metadata: Some("".to_owned()),
      dashboard_id: Some(0),
      dashboard_owner: Some("".to_owned()),
      is_dash_shared: Some(false),
    }
  }
}

//
// TServerStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TServerStatus {
  pub read_only: Option<bool>,
  pub version: Option<String>,
  pub rendering_enabled: Option<bool>,
  pub start_time: Option<i64>,
  pub edition: Option<String>,
  pub host_name: Option<String>,
  pub poly_rendering_enabled: Option<bool>,
  pub role: Option<TRole>,
}

impl TServerStatus {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(read_only: F1, version: F2, rendering_enabled: F3, start_time: F4, edition: F5, host_name: F6, poly_rendering_enabled: F7, role: F8) -> TServerStatus where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<bool>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<TRole>> {
    TServerStatus {
      read_only: read_only.into(),
      version: version.into(),
      rendering_enabled: rendering_enabled.into(),
      start_time: start_time.into(),
      edition: edition.into(),
      host_name: host_name.into(),
      poly_rendering_enabled: poly_rendering_enabled.into(),
      role: role.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TServerStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<TRole> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = TRole::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TServerStatus {
      read_only: f_1,
      version: f_2,
      rendering_enabled: f_3,
      start_time: f_4,
      edition: f_5,
      host_name: f_6,
      poly_rendering_enabled: f_7,
      role: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TServerStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_only", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rendering_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("rendering_enabled", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_time", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.edition {
      o_prot.write_field_begin(&TFieldIdentifier::new("edition", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.poly_rendering_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("poly_rendering_enabled", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.role {
      o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TServerStatus {
  fn default() -> Self {
    TServerStatus{
      read_only: Some(false),
      version: Some("".to_owned()),
      rendering_enabled: Some(false),
      start_time: Some(0),
      edition: Some("".to_owned()),
      host_name: Some("".to_owned()),
      poly_rendering_enabled: Some(false),
      role: None,
    }
  }
}

//
// TPixel
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPixel {
  pub x: Option<i64>,
  pub y: Option<i64>,
}

impl TPixel {
  pub fn new<F1, F2>(x: F1, y: F2) -> TPixel where F1: Into<Option<i64>>, F2: Into<Option<i64>> {
    TPixel {
      x: x.into(),
      y: y.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPixel> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPixel {
      x: f_1,
      y: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPixel");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.x {
      o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.y {
      o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPixel {
  fn default() -> Self {
    TPixel{
      x: Some(0),
      y: Some(0),
    }
  }
}

//
// TPixelTableRowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPixelTableRowResult {
  pub pixel: Option<TPixel>,
  pub vega_table_name: Option<String>,
  pub table_id: Option<Vec<i64>>,
  pub row_id: Option<Vec<i64>>,
  pub row_set: Option<TRowSet>,
  pub nonce: Option<String>,
}

impl TPixelTableRowResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(pixel: F1, vega_table_name: F2, table_id: F3, row_id: F4, row_set: F5, nonce: F6) -> TPixelTableRowResult where F1: Into<Option<TPixel>>, F2: Into<Option<String>>, F3: Into<Option<Vec<i64>>>, F4: Into<Option<Vec<i64>>>, F5: Into<Option<TRowSet>>, F6: Into<Option<String>> {
    TPixelTableRowResult {
      pixel: pixel.into(),
      vega_table_name: vega_table_name.into(),
      table_id: table_id.into(),
      row_id: row_id.into(),
      row_set: row_set.into(),
      nonce: nonce.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPixelTableRowResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPixel> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Vec<i64>> = Some(Vec::new());
    let mut f_4: Option<Vec<i64>> = Some(Vec::new());
    let mut f_5: Option<TRowSet> = None;
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPixel::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_i64()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = i_prot.read_i64()?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPixelTableRowResult {
      pixel: f_1,
      vega_table_name: f_2,
      table_id: f_3,
      row_id: f_4,
      row_set: f_5,
      nonce: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPixelTableRowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pixel {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixel", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.vega_table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("vega_table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_id", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPixelTableRowResult {
  fn default() -> Self {
    TPixelTableRowResult{
      pixel: None,
      vega_table_name: Some("".to_owned()),
      table_id: Some(Vec::new()),
      row_id: Some(Vec::new()),
      row_set: None,
      nonce: Some("".to_owned()),
    }
  }
}

//
// TRenderResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderResult {
  pub image: Option<Vec<u8>>,
  pub nonce: Option<String>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
  pub vega_metadata: Option<String>,
}

impl TRenderResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(image: F1, nonce: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5, vega_metadata: F6) -> TRenderResult where F1: Into<Option<Vec<u8>>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<String>> {
    TRenderResult {
      image: image.into(),
      nonce: nonce.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
      vega_metadata: vega_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderResult {
      image: f_1,
      nonce: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
      vega_metadata: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.image {
      o_prot.write_field_begin(&TFieldIdentifier::new("image", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.vega_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("vega_metadata", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderResult {
  fn default() -> Self {
    TRenderResult{
      image: Some(Vec::new()),
      nonce: Some("".to_owned()),
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
      vega_metadata: Some("".to_owned()),
    }
  }
}

//
// TGpuSpecification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGpuSpecification {
  pub num_sm: Option<i32>,
  pub clock_frequency_k_hz: Option<i64>,
  pub memory: Option<i64>,
  pub compute_capability_major: Option<i16>,
  pub compute_capability_minor: Option<i16>,
}

impl TGpuSpecification {
  pub fn new<F1, F2, F3, F4, F5>(num_sm: F1, clock_frequency_k_hz: F2, memory: F3, compute_capability_major: F4, compute_capability_minor: F5) -> TGpuSpecification where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i16>>, F5: Into<Option<i16>> {
    TGpuSpecification {
      num_sm: num_sm.into(),
      clock_frequency_k_hz: clock_frequency_k_hz.into(),
      memory: memory.into(),
      compute_capability_major: compute_capability_major.into(),
      compute_capability_minor: compute_capability_minor.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGpuSpecification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i16> = Some(0);
    let mut f_5: Option<i16> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i16()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGpuSpecification {
      num_sm: f_1,
      clock_frequency_k_hz: f_2,
      memory: f_3,
      compute_capability_major: f_4,
      compute_capability_minor: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGpuSpecification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_sm {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_sm", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.clock_frequency_k_hz {
      o_prot.write_field_begin(&TFieldIdentifier::new("clock_frequency_kHz", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.memory {
      o_prot.write_field_begin(&TFieldIdentifier::new("memory", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.compute_capability_major {
      o_prot.write_field_begin(&TFieldIdentifier::new("compute_capability_major", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.compute_capability_minor {
      o_prot.write_field_begin(&TFieldIdentifier::new("compute_capability_minor", TType::I16, 5))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TGpuSpecification {
  fn default() -> Self {
    TGpuSpecification{
      num_sm: Some(0),
      clock_frequency_k_hz: Some(0),
      memory: Some(0),
      compute_capability_major: Some(0),
      compute_capability_minor: Some(0),
    }
  }
}

//
// THardwareInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THardwareInfo {
  pub num_gpu_hw: Option<i16>,
  pub num_cpu_hw: Option<i16>,
  pub num_gpu_allocated: Option<i16>,
  pub start_gpu: Option<i16>,
  pub host_name: Option<String>,
  pub gpu_info: Option<Vec<TGpuSpecification>>,
}

impl THardwareInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(num_gpu_hw: F1, num_cpu_hw: F2, num_gpu_allocated: F3, start_gpu: F4, host_name: F5, gpu_info: F6) -> THardwareInfo where F1: Into<Option<i16>>, F2: Into<Option<i16>>, F3: Into<Option<i16>>, F4: Into<Option<i16>>, F5: Into<Option<String>>, F6: Into<Option<Vec<TGpuSpecification>>> {
    THardwareInfo {
      num_gpu_hw: num_gpu_hw.into(),
      num_cpu_hw: num_cpu_hw.into(),
      num_gpu_allocated: num_gpu_allocated.into(),
      start_gpu: start_gpu.into(),
      host_name: host_name.into(),
      gpu_info: gpu_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THardwareInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i16> = Some(0);
    let mut f_2: Option<i16> = Some(0);
    let mut f_3: Option<i16> = Some(0);
    let mut f_4: Option<i16> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<Vec<TGpuSpecification>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i16()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TGpuSpecification> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = TGpuSpecification::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THardwareInfo {
      num_gpu_hw: f_1,
      num_cpu_hw: f_2,
      num_gpu_allocated: f_3,
      start_gpu: f_4,
      host_name: f_5,
      gpu_info: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THardwareInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_gpu_hw {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_gpu_hw", TType::I16, 1))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_cpu_hw {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_cpu_hw", TType::I16, 2))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_gpu_allocated {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_gpu_allocated", TType::I16, 3))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_gpu {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_gpu", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.gpu_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("gpu_info", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for THardwareInfo {
  fn default() -> Self {
    THardwareInfo{
      num_gpu_hw: Some(0),
      num_cpu_hw: Some(0),
      num_gpu_allocated: Some(0),
      start_gpu: Some(0),
      host_name: Some("".to_owned()),
      gpu_info: Some(Vec::new()),
    }
  }
}

//
// TClusterHardwareInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TClusterHardwareInfo {
  pub hardware_info: Option<Vec<THardwareInfo>>,
}

impl TClusterHardwareInfo {
  pub fn new<F1>(hardware_info: F1) -> TClusterHardwareInfo where F1: Into<Option<Vec<THardwareInfo>>> {
    TClusterHardwareInfo {
      hardware_info: hardware_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TClusterHardwareInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<THardwareInfo>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<THardwareInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = THardwareInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TClusterHardwareInfo {
      hardware_info: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TClusterHardwareInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hardware_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("hardware_info", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TClusterHardwareInfo {
  fn default() -> Self {
    TClusterHardwareInfo{
      hardware_info: Some(Vec::new()),
    }
  }
}

//
// TMemoryData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMemoryData {
  pub slab: Option<i64>,
  pub start_page: Option<i32>,
  pub num_pages: Option<i64>,
  pub touch: Option<i32>,
  pub chunk_key: Option<Vec<i64>>,
  pub buffer_epoch: Option<i32>,
  pub is_free: Option<bool>,
}

impl TMemoryData {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(slab: F1, start_page: F2, num_pages: F3, touch: F4, chunk_key: F5, buffer_epoch: F6, is_free: F7) -> TMemoryData where F1: Into<Option<i64>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<i32>>, F5: Into<Option<Vec<i64>>>, F6: Into<Option<i32>>, F7: Into<Option<bool>> {
    TMemoryData {
      slab: slab.into(),
      start_page: start_page.into(),
      num_pages: num_pages.into(),
      touch: touch.into(),
      chunk_key: chunk_key.into(),
      buffer_epoch: buffer_epoch.into(),
      is_free: is_free.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMemoryData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<Vec<i64>> = Some(Vec::new());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_i64()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMemoryData {
      slab: f_1,
      start_page: f_2,
      num_pages: f_3,
      touch: f_4,
      chunk_key: f_5,
      buffer_epoch: f_6,
      is_free: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMemoryData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.slab {
      o_prot.write_field_begin(&TFieldIdentifier::new("slab", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_page {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_page", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_pages {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pages", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.touch {
      o_prot.write_field_begin(&TFieldIdentifier::new("touch", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.chunk_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("chunk_key", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.buffer_epoch {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffer_epoch", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_free {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_free", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMemoryData {
  fn default() -> Self {
    TMemoryData{
      slab: Some(0),
      start_page: Some(0),
      num_pages: Some(0),
      touch: Some(0),
      chunk_key: Some(Vec::new()),
      buffer_epoch: Some(0),
      is_free: Some(false),
    }
  }
}

//
// TNodeMemoryInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeMemoryInfo {
  pub host_name: Option<String>,
  pub page_size: Option<i64>,
  pub max_num_pages: Option<i64>,
  pub num_pages_allocated: Option<i64>,
  pub is_allocation_capped: Option<bool>,
  pub node_memory_data: Option<Vec<TMemoryData>>,
}

impl TNodeMemoryInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(host_name: F1, page_size: F2, max_num_pages: F3, num_pages_allocated: F4, is_allocation_capped: F5, node_memory_data: F6) -> TNodeMemoryInfo where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<bool>>, F6: Into<Option<Vec<TMemoryData>>> {
    TNodeMemoryInfo {
      host_name: host_name.into(),
      page_size: page_size.into(),
      max_num_pages: max_num_pages.into(),
      num_pages_allocated: num_pages_allocated.into(),
      is_allocation_capped: is_allocation_capped.into(),
      node_memory_data: node_memory_data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeMemoryInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<Vec<TMemoryData>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TMemoryData> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = TMemoryData::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TNodeMemoryInfo {
      host_name: f_1,
      page_size: f_2,
      max_num_pages: f_3,
      num_pages_allocated: f_4,
      is_allocation_capped: f_5,
      node_memory_data: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeMemoryInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("page_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_num_pages {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_num_pages", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_pages_allocated {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pages_allocated", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_allocation_capped {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_allocation_capped", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.node_memory_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_memory_data", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TNodeMemoryInfo {
  fn default() -> Self {
    TNodeMemoryInfo{
      host_name: Some("".to_owned()),
      page_size: Some(0),
      max_num_pages: Some(0),
      num_pages_allocated: Some(0),
      is_allocation_capped: Some(false),
      node_memory_data: Some(Vec::new()),
    }
  }
}

//
// TTableMeta
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableMeta {
  pub table_name: Option<String>,
  pub num_cols: Option<i64>,
  pub is_view: Option<bool>,
  pub is_replicated: Option<bool>,
  pub shard_count: Option<i64>,
  pub max_rows: Option<i64>,
  pub table_id: Option<i64>,
  pub max_table_id: Option<i64>,
  pub col_types: Option<Vec<common::TTypeInfo>>,
  pub col_names: Option<Vec<String>>,
}

impl TTableMeta {
  pub fn new<F1, F2, F4, F5, F6, F7, F8, F9, F10, F11>(table_name: F1, num_cols: F2, is_view: F4, is_replicated: F5, shard_count: F6, max_rows: F7, table_id: F8, max_table_id: F9, col_types: F10, col_names: F11) -> TTableMeta where F1: Into<Option<String>>, F2: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<i64>>, F10: Into<Option<Vec<common::TTypeInfo>>>, F11: Into<Option<Vec<String>>> {
    TTableMeta {
      table_name: table_name.into(),
      num_cols: num_cols.into(),
      is_view: is_view.into(),
      is_replicated: is_replicated.into(),
      shard_count: shard_count.into(),
      max_rows: max_rows.into(),
      table_id: table_id.into(),
      max_table_id: max_table_id.into(),
      col_types: col_types.into(),
      col_names: col_names.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableMeta> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<i64> = Some(0);
    let mut f_9: Option<i64> = Some(0);
    let mut f_10: Option<Vec<common::TTypeInfo>> = Some(Vec::new());
    let mut f_11: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common::TTypeInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = common::TTypeInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableMeta {
      table_name: f_1,
      num_cols: f_2,
      is_view: f_4,
      is_replicated: f_5,
      shard_count: f_6,
      max_rows: f_7,
      table_id: f_8,
      max_table_id: f_9,
      col_types: f_10,
      col_names: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableMeta");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_cols", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_view {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_view", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_replicated {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_replicated", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("shard_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_rows", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_table_id", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_types", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_names", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableMeta {
  fn default() -> Self {
    TTableMeta{
      table_name: Some("".to_owned()),
      num_cols: Some(0),
      is_view: Some(false),
      is_replicated: Some(false),
      shard_count: Some(0),
      max_rows: Some(0),
      table_id: Some(0),
      max_table_id: Some(0),
      col_types: Some(Vec::new()),
      col_names: Some(Vec::new()),
    }
  }
}

//
// TTableDetails
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableDetails {
  pub row_desc: Option<TRowDescriptor>,
  pub fragment_size: Option<i64>,
  pub page_size: Option<i64>,
  pub max_rows: Option<i64>,
  pub view_sql: Option<String>,
  pub shard_count: Option<i64>,
  pub key_metainfo: Option<String>,
  pub is_temporary: Option<bool>,
  pub partition_detail: Option<TPartitionDetail>,
}

impl TTableDetails {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(row_desc: F1, fragment_size: F2, page_size: F3, max_rows: F4, view_sql: F5, shard_count: F6, key_metainfo: F7, is_temporary: F8, partition_detail: F9) -> TTableDetails where F1: Into<Option<TRowDescriptor>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<i64>>, F7: Into<Option<String>>, F8: Into<Option<bool>>, F9: Into<Option<TPartitionDetail>> {
    TTableDetails {
      row_desc: row_desc.into(),
      fragment_size: fragment_size.into(),
      page_size: page_size.into(),
      max_rows: max_rows.into(),
      view_sql: view_sql.into(),
      shard_count: shard_count.into(),
      key_metainfo: key_metainfo.into(),
      is_temporary: is_temporary.into(),
      partition_detail: partition_detail.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableDetails> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<TPartitionDetail> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TPartitionDetail::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableDetails {
      row_desc: f_1,
      fragment_size: f_2,
      page_size: f_3,
      max_rows: f_4,
      view_sql: f_5,
      shard_count: f_6,
      key_metainfo: f_7,
      is_temporary: f_8,
      partition_detail: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableDetails");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fragment_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("page_size", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_rows", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.view_sql {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_sql", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("shard_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key_metainfo {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_metainfo", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_temporary {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_temporary", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.partition_detail {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_detail", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableDetails {
  fn default() -> Self {
    TTableDetails{
      row_desc: Some(Vec::new()),
      fragment_size: Some(0),
      page_size: Some(0),
      max_rows: Some(0),
      view_sql: Some("".to_owned()),
      shard_count: Some(0),
      key_metainfo: Some("".to_owned()),
      is_temporary: Some(false),
      partition_detail: None,
    }
  }
}

//
// TColumnRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnRange {
  pub type_: Option<TExpressionRangeType>,
  pub col_id: Option<i32>,
  pub table_id: Option<i32>,
  pub has_nulls: Option<bool>,
  pub int_min: Option<i64>,
  pub int_max: Option<i64>,
  pub bucket: Option<i64>,
  pub fp_min: Option<OrderedFloat<f64>>,
  pub fp_max: Option<OrderedFloat<f64>>,
}

impl TColumnRange {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(type_: F1, col_id: F2, table_id: F3, has_nulls: F4, int_min: F5, int_max: F6, bucket: F7, fp_min: F8, fp_max: F9) -> TColumnRange where F1: Into<Option<TExpressionRangeType>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<bool>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<OrderedFloat<f64>>>, F9: Into<Option<OrderedFloat<f64>>> {
    TColumnRange {
      type_: type_.into(),
      col_id: col_id.into(),
      table_id: table_id.into(),
      has_nulls: has_nulls.into(),
      int_min: int_min.into(),
      int_max: int_max.into(),
      bucket: bucket.into(),
      fp_min: fp_min.into(),
      fp_max: fp_max.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TExpressionRangeType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_9: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TExpressionRangeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_8 = Some(val);
        },
        9 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnRange {
      type_: f_1,
      col_id: f_2,
      table_id: f_3,
      has_nulls: f_4,
      int_min: f_5,
      int_max: f_6,
      bucket: f_7,
      fp_min: f_8,
      fp_max: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.col_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_nulls", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.int_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_min", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.int_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_max", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.bucket {
      o_prot.write_field_begin(&TFieldIdentifier::new("bucket", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fp_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("fp_min", TType::Double, 8))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fp_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("fp_max", TType::Double, 9))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnRange {
  fn default() -> Self {
    TColumnRange{
      type_: None,
      col_id: Some(0),
      table_id: Some(0),
      has_nulls: Some(false),
      int_min: Some(0),
      int_max: Some(0),
      bucket: Some(0),
      fp_min: Some(OrderedFloat::from(0.0)),
      fp_max: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// TDictionaryGeneration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDictionaryGeneration {
  pub dict_id: Option<i32>,
  pub entry_count: Option<i64>,
}

impl TDictionaryGeneration {
  pub fn new<F1, F2>(dict_id: F1, entry_count: F2) -> TDictionaryGeneration where F1: Into<Option<i32>>, F2: Into<Option<i64>> {
    TDictionaryGeneration {
      dict_id: dict_id.into(),
      entry_count: entry_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDictionaryGeneration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDictionaryGeneration {
      dict_id: f_1,
      entry_count: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDictionaryGeneration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.dict_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dict_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.entry_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("entry_count", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDictionaryGeneration {
  fn default() -> Self {
    TDictionaryGeneration{
      dict_id: Some(0),
      entry_count: Some(0),
    }
  }
}

//
// TTableGeneration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableGeneration {
  pub table_id: Option<i32>,
  pub tuple_count: Option<i64>,
  pub start_rowid: Option<i64>,
}

impl TTableGeneration {
  pub fn new<F1, F2, F3>(table_id: F1, tuple_count: F2, start_rowid: F3) -> TTableGeneration where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TTableGeneration {
      table_id: table_id.into(),
      tuple_count: tuple_count.into(),
      start_rowid: start_rowid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableGeneration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableGeneration {
      table_id: f_1,
      tuple_count: f_2,
      start_rowid: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableGeneration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.tuple_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_count", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_rowid {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_rowid", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableGeneration {
  fn default() -> Self {
    TTableGeneration{
      table_id: Some(0),
      tuple_count: Some(0),
      start_rowid: Some(0),
    }
  }
}

//
// TPendingQuery
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPendingQuery {
  pub id: Option<TQueryId>,
  pub column_ranges: Option<Vec<TColumnRange>>,
  pub dictionary_generations: Option<Vec<TDictionaryGeneration>>,
  pub table_generations: Option<Vec<TTableGeneration>>,
  pub parent_session_id: Option<TSessionId>,
}

impl TPendingQuery {
  pub fn new<F1, F2, F3, F4, F5>(id: F1, column_ranges: F2, dictionary_generations: F3, table_generations: F4, parent_session_id: F5) -> TPendingQuery where F1: Into<Option<TQueryId>>, F2: Into<Option<Vec<TColumnRange>>>, F3: Into<Option<Vec<TDictionaryGeneration>>>, F4: Into<Option<Vec<TTableGeneration>>>, F5: Into<Option<TSessionId>> {
    TPendingQuery {
      id: id.into(),
      column_ranges: column_ranges.into(),
      dictionary_generations: dictionary_generations.into(),
      table_generations: table_generations.into(),
      parent_session_id: parent_session_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPendingQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TQueryId> = Some(0);
    let mut f_2: Option<Vec<TColumnRange>> = Some(Vec::new());
    let mut f_3: Option<Vec<TDictionaryGeneration>> = Some(Vec::new());
    let mut f_4: Option<Vec<TTableGeneration>> = Some(Vec::new());
    let mut f_5: Option<TSessionId> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnRange> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = TColumnRange::read_from_in_protocol(i_prot)?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDictionaryGeneration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = TDictionaryGeneration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableGeneration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = TTableGeneration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPendingQuery {
      id: f_1,
      column_ranges: f_2,
      dictionary_generations: f_3,
      table_generations: f_4,
      parent_session_id: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPendingQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.column_ranges {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ranges", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dictionary_generations {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionary_generations", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.table_generations {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_generations", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.parent_session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("parent_session_id", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPendingQuery {
  fn default() -> Self {
    TPendingQuery{
      id: Some(0),
      column_ranges: Some(Vec::new()),
      dictionary_generations: Some(Vec::new()),
      table_generations: Some(Vec::new()),
      parent_session_id: Some("".to_owned()),
    }
  }
}

//
// TVarLen
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TVarLen {
  pub payload: Option<Vec<u8>>,
  pub is_null: Option<bool>,
}

impl TVarLen {
  pub fn new<F1, F2>(payload: F1, is_null: F2) -> TVarLen where F1: Into<Option<Vec<u8>>>, F2: Into<Option<bool>> {
    TVarLen {
      payload: payload.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TVarLen> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TVarLen {
      payload: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TVarLen");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.payload {
      o_prot.write_field_begin(&TFieldIdentifier::new("payload", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TVarLen {
  fn default() -> Self {
    TVarLen{
      payload: Some(Vec::new()),
      is_null: Some(false),
    }
  }
}

//
// TDataBlockPtr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDataBlockPtr {
  FixedLenData(Vec<u8>),
  VarLenData(Vec<TVarLen>),
}

impl TDataBlockPtr {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataBlockPtr> {
    let mut ret: Option<TDataBlockPtr> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TDataBlockPtr::FixedLenData(val));
          }
          received_field_count += 1;
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TVarLen> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = TVarLen::read_from_in_protocol(i_prot)?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          if ret.is_none() {
            ret = Some(TDataBlockPtr::VarLenData(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TDataBlockPtr"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TDataBlockPtr"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataBlockPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TDataBlockPtr::FixedLenData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("fixed_len_data", TType::String, 1))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TDataBlockPtr::VarLenData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("var_len_data", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, f.len() as i32))?;
        for e in f {
          e.write_to_out_protocol(o_prot)?;
          o_prot.write_list_end()?;
        }
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TInsertData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInsertData {
  pub db_id: Option<i32>,
  pub table_id: Option<i32>,
  pub column_ids: Option<Vec<i32>>,
  pub data: Option<Vec<TDataBlockPtr>>,
  pub num_rows: Option<i64>,
}

impl TInsertData {
  pub fn new<F1, F2, F3, F4, F5>(db_id: F1, table_id: F2, column_ids: F3, data: F4, num_rows: F5) -> TInsertData where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<i32>>>, F4: Into<Option<Vec<TDataBlockPtr>>>, F5: Into<Option<i64>> {
    TInsertData {
      db_id: db_id.into(),
      table_id: table_id.into(),
      column_ids: column_ids.into(),
      data: data.into(),
      num_rows: num_rows.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInsertData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<i32>> = Some(Vec::new());
    let mut f_4: Option<Vec<TDataBlockPtr>> = Some(Vec::new());
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_i32()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDataBlockPtr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = TDataBlockPtr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TInsertData {
      db_id: f_1,
      table_id: f_2,
      column_ids: f_3,
      data: f_4,
      num_rows: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TInsertData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.column_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ids", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TInsertData {
  fn default() -> Self {
    TInsertData{
      db_id: Some(0),
      table_id: Some(0),
      column_ids: Some(Vec::new()),
      data: Some(Vec::new()),
      num_rows: Some(0),
    }
  }
}

//
// TPendingRenderQuery
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPendingRenderQuery {
  pub id: Option<TQueryId>,
}

impl TPendingRenderQuery {
  pub fn new<F1>(id: F1) -> TPendingRenderQuery where F1: Into<Option<TQueryId>> {
    TPendingRenderQuery {
      id: id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPendingRenderQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TQueryId> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPendingRenderQuery {
      id: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPendingRenderQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPendingRenderQuery {
  fn default() -> Self {
    TPendingRenderQuery{
      id: Some(0),
    }
  }
}

//
// TRenderParseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderParseResult {
  pub merge_type: Option<TMergeType>,
  pub node_id: Option<i32>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
}

impl TRenderParseResult {
  pub fn new<F1, F2, F3, F4, F5>(merge_type: F1, node_id: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5) -> TRenderParseResult where F1: Into<Option<TMergeType>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    TRenderParseResult {
      merge_type: merge_type.into(),
      node_id: node_id.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderParseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMergeType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMergeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderParseResult {
      merge_type: f_1,
      node_id: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderParseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.merge_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.node_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderParseResult {
  fn default() -> Self {
    TRenderParseResult{
      merge_type: None,
      node_id: Some(0),
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
    }
  }
}

//
// TRawRenderPassDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRawRenderPassDataResult {
  pub num_pixel_channels: Option<i32>,
  pub num_pixel_samples: Option<i32>,
  pub pixels: Option<Vec<u8>>,
  pub row_ids_a: Option<Vec<u8>>,
  pub row_ids_b: Option<Vec<u8>>,
  pub table_ids: Option<Vec<u8>>,
  pub accum_data: Option<Vec<u8>>,
  pub accum_depth: Option<i32>,
}

impl TRawRenderPassDataResult {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(num_pixel_channels: F1, num_pixel_samples: F2, pixels: F3, row_ids_a: F4, row_ids_b: F5, table_ids: F6, accum_data: F7, accum_depth: F8) -> TRawRenderPassDataResult where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<Vec<u8>>>, F7: Into<Option<Vec<u8>>>, F8: Into<Option<i32>> {
    TRawRenderPassDataResult {
      num_pixel_channels: num_pixel_channels.into(),
      num_pixel_samples: num_pixel_samples.into(),
      pixels: pixels.into(),
      row_ids_a: row_ids_a.into(),
      row_ids_b: row_ids_b.into(),
      table_ids: table_ids.into(),
      accum_data: accum_data.into(),
      accum_depth: accum_depth.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRawRenderPassDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<Vec<u8>> = Some(Vec::new());
    let mut f_7: Option<Vec<u8>> = Some(Vec::new());
    let mut f_8: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bytes()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRawRenderPassDataResult {
      num_pixel_channels: f_1,
      num_pixel_samples: f_2,
      pixels: f_3,
      row_ids_a: f_4,
      row_ids_b: f_5,
      table_ids: f_6,
      accum_data: f_7,
      accum_depth: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRawRenderPassDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_pixel_channels {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pixel_channels", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_pixel_samples {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pixel_samples", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pixels {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixels", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_ids_a {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_ids_A", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_ids_b {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_ids_B", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.table_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_ids", TType::String, 6))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.accum_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("accum_data", TType::String, 7))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.accum_depth {
      o_prot.write_field_begin(&TFieldIdentifier::new("accum_depth", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRawRenderPassDataResult {
  fn default() -> Self {
    TRawRenderPassDataResult{
      num_pixel_channels: Some(0),
      num_pixel_samples: Some(0),
      pixels: Some(Vec::new()),
      row_ids_a: Some(Vec::new()),
      row_ids_b: Some(Vec::new()),
      table_ids: Some(Vec::new()),
      accum_data: Some(Vec::new()),
      accum_depth: Some(0),
    }
  }
}

//
// TRawPixelData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRawPixelData {
  pub width: Option<i32>,
  pub height: Option<i32>,
  pub render_pass_map: Option<TRenderPassMap>,
}

impl TRawPixelData {
  pub fn new<F1, F2, F3>(width: F1, height: F2, render_pass_map: F3) -> TRawPixelData where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<TRenderPassMap>> {
    TRawPixelData {
      width: width.into(),
      height: height.into(),
      render_pass_map: render_pass_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRawPixelData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<TRenderPassMap> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, TRawRenderPassDataResult> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_27 = i_prot.read_i32()?;
            let map_val_28 = TRawRenderPassDataResult::read_from_in_protocol(i_prot)?;
            val.insert(map_key_27, map_val_28);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRawPixelData {
      width: f_1,
      height: f_2,
      render_pass_map: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRawPixelData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.width {
      o_prot.write_field_begin(&TFieldIdentifier::new("width", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.height {
      o_prot.write_field_begin(&TFieldIdentifier::new("height", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.render_pass_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_pass_map", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRawPixelData {
  fn default() -> Self {
    TRawPixelData{
      width: Some(0),
      height: Some(0),
      render_pass_map: Some(BTreeMap::new()),
    }
  }
}

//
// TRenderDatum
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderDatum {
  pub type_: Option<common::TDatumType>,
  pub cnt: Option<i32>,
  pub value: Option<Vec<u8>>,
}

impl TRenderDatum {
  pub fn new<F1, F2, F3>(type_: F1, cnt: F2, value: F3) -> TRenderDatum where F1: Into<Option<common::TDatumType>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>> {
    TRenderDatum {
      type_: type_.into(),
      cnt: cnt.into(),
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderDatum> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TDatumType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TDatumType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderDatum {
      type_: f_1,
      cnt: f_2,
      value: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderDatum");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cnt {
      o_prot.write_field_begin(&TFieldIdentifier::new("cnt", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderDatum {
  fn default() -> Self {
    TRenderDatum{
      type_: None,
      cnt: Some(0),
      value: Some(Vec::new()),
    }
  }
}

//
// TRenderStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderStepResult {
  pub merge_data: Option<TRenderAggDataMap>,
  pub raw_pixel_data: Option<TRawPixelData>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
}

impl TRenderStepResult {
  pub fn new<F1, F2, F3, F4, F5>(merge_data: F1, raw_pixel_data: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5) -> TRenderStepResult where F1: Into<Option<TRenderAggDataMap>>, F2: Into<Option<TRawPixelData>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    TRenderStepResult {
      merge_data: merge_data.into(),
      raw_pixel_data: raw_pixel_data.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRenderAggDataMap> = Some(BTreeMap::new());
    let mut f_2: Option<TRawPixelData> = None;
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_29 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_30: BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_31 = i_prot.read_string()?;
              let map_ident = i_prot.read_map_begin()?;
              let mut map_val_32: BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>> = BTreeMap::new();
              for _ in 0..map_ident.size {
                let map_key_33 = i_prot.read_string()?;
                let map_ident = i_prot.read_map_begin()?;
                let mut map_val_34: BTreeMap<String, Vec<TRenderDatum>> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_35 = i_prot.read_string()?;
                  let list_ident = i_prot.read_list_begin()?;
                  let mut map_val_36: Vec<TRenderDatum> = Vec::with_capacity(list_ident.size as usize);
                  for _ in 0..list_ident.size {
                    let list_elem_37 = TRenderDatum::read_from_in_protocol(i_prot)?;
                    map_val_36.push(list_elem_37);
                  }
                  i_prot.read_list_end()?;
                  map_val_34.insert(map_key_35, map_val_36);
                }
                i_prot.read_map_end()?;
                map_val_32.insert(map_key_33, map_val_34);
              }
              i_prot.read_map_end()?;
              map_val_30.insert(map_key_31, map_val_32);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_29, map_val_30);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TRawPixelData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderStepResult {
      merge_data: f_1,
      raw_pixel_data: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.merge_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_data", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
        for (k, v) in v {
          o_prot.write_string(k)?;
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
          for (k, v) in v {
            o_prot.write_string(k)?;
            o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
            for (k, v) in v {
              o_prot.write_string(k)?;
              o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
              for e in v {
                e.write_to_out_protocol(o_prot)?;
                o_prot.write_list_end()?;
              }
              o_prot.write_map_end()?;
            }
            o_prot.write_map_end()?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.raw_pixel_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("raw_pixel_data", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderStepResult {
  fn default() -> Self {
    TRenderStepResult{
      merge_data: Some(BTreeMap::new()),
      raw_pixel_data: None,
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
    }
  }
}

//
// TDatabasePermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatabasePermissions {
  pub create_: Option<bool>,
  pub delete_: Option<bool>,
  pub view_sql_editor_: Option<bool>,
  pub access_: Option<bool>,
}

impl TDatabasePermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, delete_: F2, view_sql_editor_: F3, access_: F4) -> TDatabasePermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TDatabasePermissions {
      create_: create_.into(),
      delete_: delete_.into(),
      view_sql_editor_: view_sql_editor_.into(),
      access_: access_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatabasePermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatabasePermissions {
      create_: f_1,
      delete_: f_2,
      view_sql_editor_: f_3,
      access_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatabasePermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.view_sql_editor_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_sql_editor_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.access_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("access_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatabasePermissions {
  fn default() -> Self {
    TDatabasePermissions{
      create_: Some(false),
      delete_: Some(false),
      view_sql_editor_: Some(false),
      access_: Some(false),
    }
  }
}

//
// TTablePermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTablePermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub select_: Option<bool>,
  pub insert_: Option<bool>,
  pub update_: Option<bool>,
  pub delete_: Option<bool>,
  pub truncate_: Option<bool>,
  pub alter_: Option<bool>,
}

impl TTablePermissions {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(create_: F1, drop_: F2, select_: F3, insert_: F4, update_: F5, delete_: F6, truncate_: F7, alter_: F8) -> TTablePermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    TTablePermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      select_: select_.into(),
      insert_: insert_.into(),
      update_: update_.into(),
      delete_: delete_.into(),
      truncate_: truncate_.into(),
      alter_: alter_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTablePermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTablePermissions {
      create_: f_1,
      drop_: f_2,
      select_: f_3,
      insert_: f_4,
      update_: f_5,
      delete_: f_6,
      truncate_: f_7,
      alter_: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTablePermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.select_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("select_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.insert_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.update_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.truncate_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("truncate_", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.alter_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("alter_", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTablePermissions {
  fn default() -> Self {
    TTablePermissions{
      create_: Some(false),
      drop_: Some(false),
      select_: Some(false),
      insert_: Some(false),
      update_: Some(false),
      delete_: Some(false),
      truncate_: Some(false),
      alter_: Some(false),
    }
  }
}

//
// TDashboardPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboardPermissions {
  pub create_: Option<bool>,
  pub delete_: Option<bool>,
  pub view_: Option<bool>,
  pub edit_: Option<bool>,
}

impl TDashboardPermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, delete_: F2, view_: F3, edit_: F4) -> TDashboardPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TDashboardPermissions {
      create_: create_.into(),
      delete_: delete_.into(),
      view_: view_.into(),
      edit_: edit_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboardPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboardPermissions {
      create_: f_1,
      delete_: f_2,
      view_: f_3,
      edit_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboardPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.view_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.edit_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("edit_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboardPermissions {
  fn default() -> Self {
    TDashboardPermissions{
      create_: Some(false),
      delete_: Some(false),
      view_: Some(false),
      edit_: Some(false),
    }
  }
}

//
// TViewPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TViewPermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub select_: Option<bool>,
  pub insert_: Option<bool>,
  pub update_: Option<bool>,
  pub delete_: Option<bool>,
}

impl TViewPermissions {
  pub fn new<F1, F2, F3, F4, F5, F6>(create_: F1, drop_: F2, select_: F3, insert_: F4, update_: F5, delete_: F6) -> TViewPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>> {
    TViewPermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      select_: select_.into(),
      insert_: insert_.into(),
      update_: update_.into(),
      delete_: delete_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TViewPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TViewPermissions {
      create_: f_1,
      drop_: f_2,
      select_: f_3,
      insert_: f_4,
      update_: f_5,
      delete_: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TViewPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.select_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("select_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.insert_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.update_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TViewPermissions {
  fn default() -> Self {
    TViewPermissions{
      create_: Some(false),
      drop_: Some(false),
      select_: Some(false),
      insert_: Some(false),
      update_: Some(false),
      delete_: Some(false),
    }
  }
}

//
// TDBObjectPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDBObjectPermissions {
  DatabasePermissions(TDatabasePermissions),
  TablePermissions(TTablePermissions),
  DashboardPermissions(TDashboardPermissions),
  ViewPermissions(TViewPermissions),
}

impl TDBObjectPermissions {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObjectPermissions> {
    let mut ret: Option<TDBObjectPermissions> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatabasePermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::DatabasePermissions(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TTablePermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::TablePermissions(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::DashboardPermissions(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TViewPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::ViewPermissions(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TDBObjectPermissions"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TDBObjectPermissions"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBObjectPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TDBObjectPermissions::DatabasePermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("database_permissions_", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::TablePermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("table_permissions_", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::DashboardPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_permissions_", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::ViewPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("view_permissions_", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDBObject
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBObject {
  pub object_name: Option<String>,
  pub object_type: Option<TDBObjectType>,
  pub privs: Option<Vec<bool>>,
  pub grantee: Option<String>,
  pub privilege_object_type: Option<TDBObjectType>,
}

impl TDBObject {
  pub fn new<F1, F2, F3, F4, F5>(object_name: F1, object_type: F2, privs: F3, grantee: F4, privilege_object_type: F5) -> TDBObject where F1: Into<Option<String>>, F2: Into<Option<TDBObjectType>>, F3: Into<Option<Vec<bool>>>, F4: Into<Option<String>>, F5: Into<Option<TDBObjectType>> {
    TDBObject {
      object_name: object_name.into(),
      object_type: object_type.into(),
      privs: privs.into(),
      grantee: grantee.into(),
      privilege_object_type: privilege_object_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObject> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TDBObjectType> = None;
    let mut f_3: Option<Vec<bool>> = Some(Vec::new());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<TDBObjectType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = i_prot.read_bool()?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBObject {
      object_name: f_1,
      object_type: f_2,
      privs: f_3,
      grantee: f_4,
      privilege_object_type: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBObject");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.object_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.privs {
      o_prot.write_field_begin(&TFieldIdentifier::new("privs", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.grantee {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantee", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.privilege_object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilegeObjectType", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBObject {
  fn default() -> Self {
    TDBObject{
      object_name: Some("".to_owned()),
      object_type: None,
      privs: Some(Vec::new()),
      grantee: Some("".to_owned()),
      privilege_object_type: None,
    }
  }
}

//
// TDashboardGrantees
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboardGrantees {
  pub name: Option<String>,
  pub is_user: Option<bool>,
  pub permissions: Option<TDashboardPermissions>,
}

impl TDashboardGrantees {
  pub fn new<F1, F2, F3>(name: F1, is_user: F2, permissions: F3) -> TDashboardGrantees where F1: Into<Option<String>>, F2: Into<Option<bool>>, F3: Into<Option<TDashboardPermissions>> {
    TDashboardGrantees {
      name: name.into(),
      is_user: is_user.into(),
      permissions: permissions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboardGrantees> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboardGrantees {
      name: f_1,
      is_user: f_2,
      permissions: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboardGrantees");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_user {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_user", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.permissions {
      o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboardGrantees {
  fn default() -> Self {
    TDashboardGrantees{
      name: Some("".to_owned()),
      is_user: Some(false),
      permissions: None,
    }
  }
}

//
// TLicenseInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLicenseInfo {
  pub claims: Option<Vec<String>>,
}

impl TLicenseInfo {
  pub fn new<F1>(claims: F1) -> TLicenseInfo where F1: Into<Option<Vec<String>>> {
    TLicenseInfo {
      claims: claims.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLicenseInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = i_prot.read_string()?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TLicenseInfo {
      claims: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLicenseInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.claims {
      o_prot.write_field_begin(&TFieldIdentifier::new("claims", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TLicenseInfo {
  fn default() -> Self {
    TLicenseInfo{
      claims: Some(Vec::new()),
    }
  }
}

//
// TSessionInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSessionInfo {
  pub user: Option<String>,
  pub database: Option<String>,
  pub start_time: Option<i64>,
  pub is_super: Option<bool>,
}

impl TSessionInfo {
  pub fn new<F1, F2, F3, F4>(user: F1, database: F2, start_time: F3, is_super: F4) -> TSessionInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<bool>> {
    TSessionInfo {
      user: user.into(),
      database: database.into(),
      start_time: start_time.into(),
      is_super: is_super.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSessionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSessionInfo {
      user: f_1,
      database: f_2,
      start_time: f_3,
      is_super: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSessionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_time", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_super {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_super", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSessionInfo {
  fn default() -> Self {
    TSessionInfo{
      user: Some("".to_owned()),
      database: Some("".to_owned()),
      start_time: Some(0),
      is_super: Some(false),
    }
  }
}

//
// TGeoFileLayerInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGeoFileLayerInfo {
  pub name: Option<String>,
  pub contents: Option<TGeoFileLayerContents>,
}

impl TGeoFileLayerInfo {
  pub fn new<F1, F2>(name: F1, contents: F2) -> TGeoFileLayerInfo where F1: Into<Option<String>>, F2: Into<Option<TGeoFileLayerContents>> {
    TGeoFileLayerInfo {
      name: name.into(),
      contents: contents.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGeoFileLayerInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TGeoFileLayerContents> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TGeoFileLayerContents::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGeoFileLayerInfo {
      name: f_1,
      contents: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGeoFileLayerInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contents {
      o_prot.write_field_begin(&TFieldIdentifier::new("contents", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TGeoFileLayerInfo {
  fn default() -> Self {
    TGeoFileLayerInfo{
      name: Some("".to_owned()),
      contents: None,
    }
  }
}

//
// OmniSci service client
//

pub trait TOmniSciSyncClient {
  fn connect(&mut self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId>;
  fn krb5_connect(&mut self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session>;
  fn disconnect(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn switch_database(&mut self, session: TSessionId, dbname: String) -> thrift::Result<()>;
  fn clone_session(&mut self, session: TSessionId) -> thrift::Result<TSessionId>;
  fn get_server_status(&mut self, session: TSessionId) -> thrift::Result<TServerStatus>;
  fn get_status(&mut self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>>;
  fn get_hardware_info(&mut self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo>;
  fn get_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_physical_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_views(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_tables_meta(&mut self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>>;
  fn get_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn get_internal_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn get_users(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_databases(&mut self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>>;
  fn get_version(&mut self) -> thrift::Result<String>;
  fn start_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn stop_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn get_heap_profile(&mut self, session: TSessionId) -> thrift::Result<String>;
  fn get_memory(&mut self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>>;
  fn clear_cpu_memory(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn clear_gpu_memory(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn set_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()>;
  fn set_table_epoch_by_name(&mut self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()>;
  fn get_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32>;
  fn get_table_epoch_by_name(&mut self, session: TSessionId, table_name: String) -> thrift::Result<i32>;
  fn get_session_info(&mut self, session: TSessionId) -> thrift::Result<TSessionInfo>;
  fn sql_execute(&mut self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult>;
  fn sql_execute_df(&mut self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn sql_execute_gdf(&mut self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn deallocate_df(&mut self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()>;
  fn interrupt(&mut self, query_session: TSessionId, interrupt_session: TSessionId) -> thrift::Result<()>;
  fn sql_validate(&mut self, session: TSessionId, query: String) -> thrift::Result<TRowDescriptor>;
  fn get_completion_hints(&mut self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>>;
  fn set_execution_mode(&mut self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()>;
  fn render_vega(&mut self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult>;
  fn get_result_row_for_pixel(&mut self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult>;
  fn get_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard>;
  fn get_dashboards(&mut self, session: TSessionId) -> thrift::Result<Vec<TDashboard>>;
  fn create_dashboard(&mut self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32>;
  fn replace_dashboard(&mut self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()>;
  fn delete_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()>;
  fn share_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()>;
  fn unshare_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn get_dashboard_grantees(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>>;
  fn get_link_view(&mut self, session: TSessionId, link: String) -> thrift::Result<TFrontendView>;
  fn create_link(&mut self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String>;
  fn load_table_binary(&mut self, session: TSessionId, table_name: String, rows: Vec<TRow>) -> thrift::Result<()>;
  fn load_table_binary_columnar(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>) -> thrift::Result<()>;
  fn load_table_binary_arrow(&mut self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>) -> thrift::Result<()>;
  fn load_table(&mut self, session: TSessionId, table_name: String, rows: Vec<TStringRow>) -> thrift::Result<()>;
  fn detect_column_types(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult>;
  fn create_table(&mut self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, file_type: TFileType, create_params: TCreateParams) -> thrift::Result<()>;
  fn import_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()>;
  fn import_geo_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn import_table_status(&mut self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus>;
  fn get_first_geo_file_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String>;
  fn get_all_files_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>>;
  fn get_layers_in_geo_file(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>>;
  fn query_get_outer_fragment_count(&mut self, session: TSessionId, query: String) -> thrift::Result<i64>;
  fn check_table_consistency(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta>;
  fn start_query(&mut self, leaf_session: TSessionId, parent_session: TSessionId, query_ra: String, just_explain: bool, outer_fragment_indices: Vec<i64>) -> thrift::Result<TPendingQuery>;
  fn execute_query_step(&mut self, pending_query: TPendingQuery) -> thrift::Result<TStepResult>;
  fn broadcast_serialized_rows(&mut self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId) -> thrift::Result<()>;
  fn start_render_query(&mut self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery>;
  fn execute_next_render_step(&mut self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult>;
  fn insert_data(&mut self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()>;
  fn checkpoint(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<()>;
  fn get_roles(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_db_objects_for_grantee(&mut self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>>;
  fn get_db_object_privs(&mut self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>>;
  fn get_all_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn has_role(&mut self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool>;
  fn has_object_privilege(&mut self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool>;
  fn set_license_key(&mut self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn get_license_claims(&mut self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn get_device_parameters(&mut self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>>;
  fn register_runtime_extension_functions(&mut self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()>;
}

pub trait TOmniSciSyncClientMarker {}

pub struct OmniSciSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> OmniSciSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> OmniSciSyncClient<IP, OP> {
    OmniSciSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for OmniSciSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TOmniSciSyncClientMarker for OmniSciSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TOmniSciSyncClientMarker> TOmniSciSyncClient for C {
  fn connect(&mut self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connect", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciConnectArgs { user: user, passwd: passwd, dbname: dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciConnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn krb5_connect(&mut self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciKrb5ConnectArgs { input_token: input_token, dbname: dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("krb5_connect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciKrb5ConnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn disconnect(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciDisconnectArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("disconnect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciDisconnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn switch_database(&mut self, session: TSessionId, dbname: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSwitchDatabaseArgs { session: session, dbname: dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("switch_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSwitchDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clone_session(&mut self, session: TSessionId) -> thrift::Result<TSessionId> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciCloneSessionArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clone_session", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciCloneSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_server_status(&mut self, session: TSessionId) -> thrift::Result<TServerStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetServerStatusArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_server_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetServerStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_status(&mut self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_status", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetStatusArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_hardware_info(&mut self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetHardwareInfoArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_hardware_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetHardwareInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetTablesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_physical_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetPhysicalTablesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_physical_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetPhysicalTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_views(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_views", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetViewsArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_views", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetViewsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables_meta(&mut self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetTablesMetaArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables_meta", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetTablesMetaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetTableDetailsArgs { session: session, table_name: table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetTableDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_internal_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetInternalTableDetailsArgs { session: session, table_name: table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_internal_table_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetInternalTableDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_users(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_users", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetUsersArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_users", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetUsersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_databases(&mut self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDatabasesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_databases", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDatabasesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_version(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_version", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetVersionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciStartHeapProfileArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciStartHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn stop_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciStopHeapProfileArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("stop_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciStopHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_heap_profile(&mut self, session: TSessionId) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetHeapProfileArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_memory(&mut self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetMemoryArgs { session: session, memory_level: memory_level };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_cpu_memory(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciClearCpuMemoryArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_cpu_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciClearCpuMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_gpu_memory(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciClearGpuMemoryArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_gpu_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciClearGpuMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSetTableEpochArgs { session: session, db_id: db_id, table_id: table_id, new_epoch: new_epoch };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epoch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSetTableEpochResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epoch_by_name(&mut self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSetTableEpochByNameArgs { session: session, table_name: table_name, new_epoch: new_epoch };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epoch_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSetTableEpochByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetTableEpochArgs { session: session, db_id: db_id, table_id: table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epoch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetTableEpochResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epoch_by_name(&mut self, session: TSessionId, table_name: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetTableEpochByNameArgs { session: session, table_name: table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epoch_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetTableEpochByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_session_info(&mut self, session: TSessionId) -> thrift::Result<TSessionInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetSessionInfoArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_session_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetSessionInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute(&mut self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSqlExecuteArgs { session: session, query: query, column_format: column_format, nonce: nonce, first_n: first_n, at_most_n: at_most_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSqlExecuteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute_df(&mut self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSqlExecuteDfArgs { session: session, query: query, device_type: device_type, device_id: device_id, first_n: first_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute_df", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSqlExecuteDfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute_gdf(&mut self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSqlExecuteGdfArgs { session: session, query: query, device_id: device_id, first_n: first_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute_gdf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSqlExecuteGdfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn deallocate_df(&mut self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciDeallocateDfArgs { session: session, df: df, device_type: device_type, device_id: device_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deallocate_df", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciDeallocateDfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn interrupt(&mut self, query_session: TSessionId, interrupt_session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciInterruptArgs { query_session: query_session, interrupt_session: interrupt_session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("interrupt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciInterruptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_validate(&mut self, session: TSessionId, query: String) -> thrift::Result<TRowDescriptor> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSqlValidateArgs { session: session, query: query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_validate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSqlValidateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_completion_hints(&mut self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetCompletionHintsArgs { session: session, sql: sql, cursor: cursor };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_completion_hints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetCompletionHintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_execution_mode(&mut self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSetExecutionModeArgs { session: session, mode: mode };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_execution_mode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSetExecutionModeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn render_vega(&mut self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciRenderVegaArgs { session: session, widget_id: widget_id, vega_json: vega_json, compression_level: compression_level, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("render_vega", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciRenderVegaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_result_row_for_pixel(&mut self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetResultRowForPixelArgs { session: session, widget_id: widget_id, pixel: pixel, table_col_names: table_col_names, column_format: column_format, pixel_radius: pixel_radius, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_result_row_for_pixel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetResultRowForPixelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDashboardArgs { session: session, dashboard_id: dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboards(&mut self, session: TSessionId) -> thrift::Result<Vec<TDashboard>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDashboardsArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDashboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_dashboard(&mut self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciCreateDashboardArgs { session: session, dashboard_name: dashboard_name, dashboard_state: dashboard_state, image_hash: image_hash, dashboard_metadata: dashboard_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciCreateDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn replace_dashboard(&mut self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciReplaceDashboardArgs { session: session, dashboard_id: dashboard_id, dashboard_name: dashboard_name, dashboard_owner: dashboard_owner, dashboard_state: dashboard_state, image_hash: image_hash, dashboard_metadata: dashboard_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("replace_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciReplaceDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciDeleteDashboardArgs { session: session, dashboard_id: dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciDeleteDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn share_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciShareDashboardArgs { session: session, dashboard_id: dashboard_id, groups: groups, objects: objects, permissions: permissions, grant_role: grant_role };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("share_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciShareDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unshare_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciUnshareDashboardArgs { session: session, dashboard_id: dashboard_id, groups: groups, objects: objects, permissions: permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unshare_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciUnshareDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboard_grantees(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDashboardGranteesArgs { session: session, dashboard_id: dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboard_grantees", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDashboardGranteesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_link_view(&mut self, session: TSessionId, link: String) -> thrift::Result<TFrontendView> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetLinkViewArgs { session: session, link: link };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_link_view", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetLinkViewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_link(&mut self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_link", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciCreateLinkArgs { session: session, view_state: view_state, view_metadata: view_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_link", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciCreateLinkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary(&mut self, session: TSessionId, table_name: String, rows: Vec<TRow>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciLoadTableBinaryArgs { session: session, table_name: table_name, rows: rows };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciLoadTableBinaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_columnar(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciLoadTableBinaryColumnarArgs { session: session, table_name: table_name, cols: cols };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_columnar", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciLoadTableBinaryColumnarResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_arrow(&mut self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciLoadTableBinaryArrowArgs { session: session, table_name: table_name, arrow_stream: arrow_stream };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_arrow", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciLoadTableBinaryArrowResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table(&mut self, session: TSessionId, table_name: String, rows: Vec<TStringRow>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciLoadTableArgs { session: session, table_name: table_name, rows: rows };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciLoadTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn detect_column_types(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciDetectColumnTypesArgs { session: session, file_name: file_name, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("detect_column_types", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciDetectColumnTypesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_table(&mut self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, file_type: TFileType, create_params: TCreateParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciCreateTableArgs { session: session, table_name: table_name, row_desc: row_desc, file_type: file_type, create_params: create_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciCreateTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_table", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciImportTableArgs { session: session, table_name: table_name, file_name: file_name, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciImportTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_geo_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciImportGeoTableArgs { session: session, table_name: table_name, file_name: file_name, copy_params: copy_params, row_desc: row_desc, create_params: create_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_geo_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciImportGeoTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_table_status(&mut self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciImportTableStatusArgs { session: session, import_id: import_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_table_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciImportTableStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_first_geo_file_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetFirstGeoFileInArchiveArgs { session: session, archive_path: archive_path, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_first_geo_file_in_archive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetFirstGeoFileInArchiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_files_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetAllFilesInArchiveArgs { session: session, archive_path: archive_path, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_files_in_archive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetAllFilesInArchiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_layers_in_geo_file(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetLayersInGeoFileArgs { session: session, file_name: file_name, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_layers_in_geo_file", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetLayersInGeoFileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn query_get_outer_fragment_count(&mut self, session: TSessionId, query: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciQueryGetOuterFragmentCountArgs { session: session, query: query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("query_get_outer_fragment_count", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciQueryGetOuterFragmentCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_table_consistency(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciCheckTableConsistencyArgs { session: session, table_id: table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("check_table_consistency", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciCheckTableConsistencyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_query(&mut self, leaf_session: TSessionId, parent_session: TSessionId, query_ra: String, just_explain: bool, outer_fragment_indices: Vec<i64>) -> thrift::Result<TPendingQuery> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_query", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciStartQueryArgs { leaf_session: leaf_session, parent_session: parent_session, query_ra: query_ra, just_explain: just_explain, outer_fragment_indices: outer_fragment_indices };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciStartQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_query_step(&mut self, pending_query: TPendingQuery) -> thrift::Result<TStepResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciExecuteQueryStepArgs { pending_query: pending_query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("execute_query_step", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciExecuteQueryStepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn broadcast_serialized_rows(&mut self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciBroadcastSerializedRowsArgs { serialized_rows: serialized_rows, row_desc: row_desc, query_id: query_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("broadcast_serialized_rows", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciBroadcastSerializedRowsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_render_query(&mut self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciStartRenderQueryArgs { session: session, widget_id: widget_id, node_idx: node_idx, vega_json: vega_json };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_render_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciStartRenderQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_next_render_step(&mut self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciExecuteNextRenderStepArgs { pending_render: pending_render, merged_data: merged_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("execute_next_render_step", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciExecuteNextRenderStepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_data(&mut self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciInsertDataArgs { session: session, insert_data: insert_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insert_data", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciInsertDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn checkpoint(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciCheckpointArgs { session: session, db_id: db_id, table_id: table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkpoint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciCheckpointResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_roles(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetRolesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_roles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetRolesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_db_objects_for_grantee(&mut self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDbObjectsForGranteeArgs { session: session, role_name: role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_db_objects_for_grantee", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDbObjectsForGranteeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_db_object_privs(&mut self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDbObjectPrivsArgs { session: session, object_name: object_name, type_: type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_db_object_privs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDbObjectPrivsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetAllRolesForUserArgs { session: session, user_name: user_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_roles_for_user", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetAllRolesForUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_role(&mut self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_role", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciHasRoleArgs { session: session, grantee_name: grantee_name, role_name: role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciHasRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_object_privilege(&mut self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciHasObjectPrivilegeArgs { session: session, grantee_name: grantee_name, object_name: object_name, object_type: object_type, permissions: permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_object_privilege", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciHasObjectPrivilegeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_license_key(&mut self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciSetLicenseKeyArgs { session: session, key: key, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_license_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciSetLicenseKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_license_claims(&mut self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetLicenseClaimsArgs { session: session, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_license_claims", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetLicenseClaimsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_device_parameters(&mut self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciGetDeviceParametersArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_device_parameters", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciGetDeviceParametersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_runtime_extension_functions(&mut self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Call, self.sequence_number());
        let call_args = OmniSciRegisterRuntimeExtensionFunctionsArgs { session: session, udfs: udfs, udtfs: udtfs, device_ir_map: device_ir_map };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("register_runtime_extension_functions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = OmniSciRegisterRuntimeExtensionFunctionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// OmniSci service processor
//

pub trait OmniSciSyncHandler {
  fn handle_connect(&self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId>;
  fn handle_krb5_connect(&self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session>;
  fn handle_disconnect(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_switch_database(&self, session: TSessionId, dbname: String) -> thrift::Result<()>;
  fn handle_clone_session(&self, session: TSessionId) -> thrift::Result<TSessionId>;
  fn handle_get_server_status(&self, session: TSessionId) -> thrift::Result<TServerStatus>;
  fn handle_get_status(&self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>>;
  fn handle_get_hardware_info(&self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo>;
  fn handle_get_tables(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_physical_tables(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_views(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_tables_meta(&self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>>;
  fn handle_get_table_details(&self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_internal_table_details(&self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_users(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_databases(&self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>>;
  fn handle_get_version(&self) -> thrift::Result<String>;
  fn handle_start_heap_profile(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_stop_heap_profile(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_get_heap_profile(&self, session: TSessionId) -> thrift::Result<String>;
  fn handle_get_memory(&self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>>;
  fn handle_clear_cpu_memory(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_clear_gpu_memory(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_set_table_epoch(&self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()>;
  fn handle_set_table_epoch_by_name(&self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()>;
  fn handle_get_table_epoch(&self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32>;
  fn handle_get_table_epoch_by_name(&self, session: TSessionId, table_name: String) -> thrift::Result<i32>;
  fn handle_get_session_info(&self, session: TSessionId) -> thrift::Result<TSessionInfo>;
  fn handle_sql_execute(&self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult>;
  fn handle_sql_execute_df(&self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn handle_sql_execute_gdf(&self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn handle_deallocate_df(&self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()>;
  fn handle_interrupt(&self, query_session: TSessionId, interrupt_session: TSessionId) -> thrift::Result<()>;
  fn handle_sql_validate(&self, session: TSessionId, query: String) -> thrift::Result<TRowDescriptor>;
  fn handle_get_completion_hints(&self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>>;
  fn handle_set_execution_mode(&self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()>;
  fn handle_render_vega(&self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult>;
  fn handle_get_result_row_for_pixel(&self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult>;
  fn handle_get_dashboard(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard>;
  fn handle_get_dashboards(&self, session: TSessionId) -> thrift::Result<Vec<TDashboard>>;
  fn handle_create_dashboard(&self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32>;
  fn handle_replace_dashboard(&self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()>;
  fn handle_delete_dashboard(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()>;
  fn handle_share_dashboard(&self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()>;
  fn handle_unshare_dashboard(&self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn handle_get_dashboard_grantees(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>>;
  fn handle_get_link_view(&self, session: TSessionId, link: String) -> thrift::Result<TFrontendView>;
  fn handle_create_link(&self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String>;
  fn handle_load_table_binary(&self, session: TSessionId, table_name: String, rows: Vec<TRow>) -> thrift::Result<()>;
  fn handle_load_table_binary_columnar(&self, session: TSessionId, table_name: String, cols: Vec<TColumn>) -> thrift::Result<()>;
  fn handle_load_table_binary_arrow(&self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>) -> thrift::Result<()>;
  fn handle_load_table(&self, session: TSessionId, table_name: String, rows: Vec<TStringRow>) -> thrift::Result<()>;
  fn handle_detect_column_types(&self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult>;
  fn handle_create_table(&self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, file_type: TFileType, create_params: TCreateParams) -> thrift::Result<()>;
  fn handle_import_table(&self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()>;
  fn handle_import_geo_table(&self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn handle_import_table_status(&self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus>;
  fn handle_get_first_geo_file_in_archive(&self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String>;
  fn handle_get_all_files_in_archive(&self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>>;
  fn handle_get_layers_in_geo_file(&self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>>;
  fn handle_query_get_outer_fragment_count(&self, session: TSessionId, query: String) -> thrift::Result<i64>;
  fn handle_check_table_consistency(&self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta>;
  fn handle_start_query(&self, leaf_session: TSessionId, parent_session: TSessionId, query_ra: String, just_explain: bool, outer_fragment_indices: Vec<i64>) -> thrift::Result<TPendingQuery>;
  fn handle_execute_query_step(&self, pending_query: TPendingQuery) -> thrift::Result<TStepResult>;
  fn handle_broadcast_serialized_rows(&self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId) -> thrift::Result<()>;
  fn handle_start_render_query(&self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery>;
  fn handle_execute_next_render_step(&self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult>;
  fn handle_insert_data(&self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()>;
  fn handle_checkpoint(&self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<()>;
  fn handle_get_roles(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_db_objects_for_grantee(&self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>>;
  fn handle_get_db_object_privs(&self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>>;
  fn handle_get_all_roles_for_user(&self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn handle_has_role(&self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool>;
  fn handle_has_object_privilege(&self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool>;
  fn handle_set_license_key(&self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn handle_get_license_claims(&self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn handle_get_device_parameters(&self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_register_runtime_extension_functions(&self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()>;
}

pub struct OmniSciSyncProcessor<H: OmniSciSyncHandler> {
  handler: H,
}

impl <H: OmniSciSyncHandler> OmniSciSyncProcessor<H> {
  pub fn new(handler: H) -> OmniSciSyncProcessor<H> {
    OmniSciSyncProcessor {
      handler,
    }
  }
  fn process_connect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_connect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_krb5_connect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_krb5_connect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_disconnect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_disconnect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_switch_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_switch_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clone_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_clone_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_server_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_server_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_hardware_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_hardware_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_physical_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_physical_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_views(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_views(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables_meta(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_tables_meta(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_table_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_internal_table_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_internal_table_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_users(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_users(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_databases(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_databases(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_start_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_stop_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_stop_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_cpu_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_clear_cpu_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_gpu_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_clear_gpu_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epoch(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_set_table_epoch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epoch_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_set_table_epoch_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epoch(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_table_epoch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epoch_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_table_epoch_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_session_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_session_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_sql_execute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute_df(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_sql_execute_df(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute_gdf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_sql_execute_gdf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_deallocate_df(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_deallocate_df(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_interrupt(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_interrupt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_validate(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_sql_validate(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_completion_hints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_completion_hints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_execution_mode(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_set_execution_mode(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_render_vega(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_render_vega(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_result_row_for_pixel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_result_row_for_pixel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboards(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_dashboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_create_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_replace_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_replace_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_delete_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_share_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_share_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unshare_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_unshare_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboard_grantees(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_dashboard_grantees(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_link_view(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_link_view(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_link(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_create_link(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_load_table_binary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_columnar(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_load_table_binary_columnar(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_arrow(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_load_table_binary_arrow(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_load_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_detect_column_types(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_detect_column_types(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_create_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_import_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_geo_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_import_geo_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_table_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_import_table_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_first_geo_file_in_archive(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_first_geo_file_in_archive(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_files_in_archive(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_all_files_in_archive(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_layers_in_geo_file(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_layers_in_geo_file(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_query_get_outer_fragment_count(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_query_get_outer_fragment_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_table_consistency(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_check_table_consistency(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_start_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_query_step(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_execute_query_step(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_broadcast_serialized_rows(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_broadcast_serialized_rows(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_render_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_start_render_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_next_render_step(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_execute_next_render_step(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_insert_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_checkpoint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_checkpoint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_roles(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_roles(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_db_objects_for_grantee(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_db_objects_for_grantee(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_db_object_privs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_db_object_privs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_roles_for_user(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_all_roles_for_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_has_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_object_privilege(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_has_object_privilege(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_license_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_set_license_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_license_claims(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_license_claims(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_device_parameters(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_get_device_parameters(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_runtime_extension_functions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TOmniSciProcessFunctions::process_register_runtime_extension_functions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TOmniSciProcessFunctions;

impl TOmniSciProcessFunctions {
  pub fn process_connect<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciConnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connect(args.user, args.passwd, args.dbname) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciConnectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciConnectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_krb5_connect<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciKrb5ConnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_krb5_connect(args.input_token, args.dbname) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciKrb5ConnectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciKrb5ConnectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_disconnect<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciDisconnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_disconnect(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciDisconnectResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciDisconnectResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_switch_database<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSwitchDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_switch_database(args.session, args.dbname) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSwitchDatabaseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSwitchDatabaseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clone_session<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciCloneSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clone_session(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciCloneSessionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciCloneSessionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clone_session", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_server_status<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetServerStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_server_status(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetServerStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetServerStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_status<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_status(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_hardware_info<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetHardwareInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_hardware_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetHardwareInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetHardwareInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetTablesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetTablesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_physical_tables<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetPhysicalTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_physical_tables(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetPhysicalTablesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetPhysicalTablesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_views<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetViewsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_views(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_views", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetViewsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetViewsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_views", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables_meta<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetTablesMetaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables_meta(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetTablesMetaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetTablesMetaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_details<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetTableDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_details(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetTableDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetTableDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_internal_table_details<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetInternalTableDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_internal_table_details(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetInternalTableDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetInternalTableDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_users<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetUsersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_users(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_users", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetUsersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetUsersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_users", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_databases<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDatabasesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_databases(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDatabasesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDatabasesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_version<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = OmniSciGetVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_version() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetVersionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetVersionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_heap_profile<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciStartHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_heap_profile(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciStartHeapProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciStartHeapProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_stop_heap_profile<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciStopHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_stop_heap_profile(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciStopHeapProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciStopHeapProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_heap_profile<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_heap_profile(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetHeapProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetHeapProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_memory<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_memory(args.session, args.memory_level) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetMemoryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetMemoryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_cpu_memory<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciClearCpuMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_cpu_memory(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciClearCpuMemoryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciClearCpuMemoryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_gpu_memory<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciClearGpuMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_gpu_memory(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciClearGpuMemoryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciClearGpuMemoryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epoch<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSetTableEpochArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSetTableEpochResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSetTableEpochResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epoch_by_name<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSetTableEpochByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epoch_by_name(args.session, args.table_name, args.new_epoch) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSetTableEpochByNameResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSetTableEpochByNameResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epoch<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetTableEpochArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epoch(args.session, args.db_id, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetTableEpochResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epoch_by_name<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetTableEpochByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epoch_by_name(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetTableEpochByNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_session_info<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetSessionInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_session_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetSessionInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetSessionInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSqlExecuteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n, args.at_most_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSqlExecuteResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSqlExecuteResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute_df<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSqlExecuteDfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSqlExecuteDfResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSqlExecuteDfResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute_gdf<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSqlExecuteGdfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute_gdf(args.session, args.query, args.device_id, args.first_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSqlExecuteGdfResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSqlExecuteGdfResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_deallocate_df<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciDeallocateDfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_deallocate_df(args.session, args.df, args.device_type, args.device_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciDeallocateDfResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciDeallocateDfResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_interrupt<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciInterruptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_interrupt(args.query_session, args.interrupt_session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciInterruptResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciInterruptResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_validate<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSqlValidateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_validate(args.session, args.query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSqlValidateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSqlValidateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_completion_hints<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetCompletionHintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_completion_hints(args.session, args.sql, args.cursor) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetCompletionHintsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetCompletionHintsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_execution_mode<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSetExecutionModeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_execution_mode(args.session, args.mode) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSetExecutionModeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSetExecutionModeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_render_vega<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciRenderVegaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciRenderVegaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciRenderVegaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_result_row_for_pixel<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetResultRowForPixelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixel_radius, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetResultRowForPixelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetResultRowForPixelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboard<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboard(args.session, args.dashboard_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDashboardResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDashboardResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboards<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDashboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboards(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDashboardsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDashboardsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_dashboard<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciCreateDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_dashboard(args.session, args.dashboard_name, args.dashboard_state, args.image_hash, args.dashboard_metadata) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciCreateDashboardResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciCreateDashboardResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_replace_dashboard<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciReplaceDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_replace_dashboard(args.session, args.dashboard_id, args.dashboard_name, args.dashboard_owner, args.dashboard_state, args.image_hash, args.dashboard_metadata) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciReplaceDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciReplaceDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_dashboard<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciDeleteDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_dashboard(args.session, args.dashboard_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciDeleteDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciDeleteDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_share_dashboard<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciShareDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_share_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, args.grant_role) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciShareDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciShareDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unshare_dashboard<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciUnshareDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unshare_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciUnshareDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciUnshareDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboard_grantees<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDashboardGranteesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboard_grantees(args.session, args.dashboard_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDashboardGranteesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDashboardGranteesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_link_view<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetLinkViewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_link_view(args.session, args.link) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetLinkViewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetLinkViewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_link<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciCreateLinkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_link(args.session, args.view_state, args.view_metadata) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_link", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciCreateLinkResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciCreateLinkResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_link", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciLoadTableBinaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary(args.session, args.table_name, args.rows) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciLoadTableBinaryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciLoadTableBinaryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_columnar<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciLoadTableBinaryColumnarArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_columnar(args.session, args.table_name, args.cols) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciLoadTableBinaryColumnarResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciLoadTableBinaryColumnarResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_arrow<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciLoadTableBinaryArrowArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_arrow(args.session, args.table_name, args.arrow_stream) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciLoadTableBinaryArrowResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciLoadTableBinaryArrowResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciLoadTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table(args.session, args.table_name, args.rows) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciLoadTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciLoadTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_detect_column_types<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciDetectColumnTypesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_detect_column_types(args.session, args.file_name, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciDetectColumnTypesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciDetectColumnTypesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_table<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciCreateTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_table(args.session, args.table_name, args.row_desc, args.file_type, args.create_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciCreateTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciCreateTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_table<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciImportTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_table(args.session, args.table_name, args.file_name, args.copy_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("import_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciImportTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciImportTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_geo_table<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciImportGeoTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc, args.create_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciImportGeoTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciImportGeoTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_table_status<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciImportTableStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_table_status(args.session, args.import_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciImportTableStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciImportTableStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_first_geo_file_in_archive<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetFirstGeoFileInArchiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_first_geo_file_in_archive(args.session, args.archive_path, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetFirstGeoFileInArchiveResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetFirstGeoFileInArchiveResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_files_in_archive<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetAllFilesInArchiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_files_in_archive(args.session, args.archive_path, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetAllFilesInArchiveResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetAllFilesInArchiveResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_layers_in_geo_file<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetLayersInGeoFileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_layers_in_geo_file(args.session, args.file_name, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetLayersInGeoFileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetLayersInGeoFileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_query_get_outer_fragment_count<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciQueryGetOuterFragmentCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_query_get_outer_fragment_count(args.session, args.query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciQueryGetOuterFragmentCountResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciQueryGetOuterFragmentCountResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("query_get_outer_fragment_count", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_table_consistency<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciCheckTableConsistencyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_table_consistency(args.session, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciCheckTableConsistencyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciCheckTableConsistencyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_query<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciStartQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_query(args.leaf_session, args.parent_session, args.query_ra, args.just_explain, args.outer_fragment_indices) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("start_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciStartQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciStartQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_query_step<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciExecuteQueryStepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_query_step(args.pending_query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciExecuteQueryStepResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciExecuteQueryStepResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_broadcast_serialized_rows<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciBroadcastSerializedRowsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciBroadcastSerializedRowsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciBroadcastSerializedRowsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_render_query<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciStartRenderQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_render_query(args.session, args.widget_id, args.node_idx, args.vega_json) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciStartRenderQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciStartRenderQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_next_render_step<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciExecuteNextRenderStepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_next_render_step(args.pending_render, args.merged_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciExecuteNextRenderStepResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciExecuteNextRenderStepResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_data<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciInsertDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_data(args.session, args.insert_data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciInsertDataResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciInsertDataResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_checkpoint<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciCheckpointArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_checkpoint(args.session, args.db_id, args.table_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciCheckpointResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciCheckpointResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_roles<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetRolesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_roles(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetRolesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetRolesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_db_objects_for_grantee<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDbObjectsForGranteeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_db_objects_for_grantee(args.session, args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDbObjectsForGranteeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDbObjectsForGranteeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_db_object_privs<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDbObjectPrivsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_db_object_privs(args.session, args.object_name, args.type_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDbObjectPrivsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDbObjectPrivsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_roles_for_user<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetAllRolesForUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_roles_for_user(args.session, args.user_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetAllRolesForUserResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetAllRolesForUserResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_role<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciHasRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_role(args.session, args.grantee_name, args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciHasRoleResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciHasRoleResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("has_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_object_privilege<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciHasObjectPrivilegeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_object_privilege(args.session, args.grantee_name, args.object_name, args.object_type, args.permissions) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciHasObjectPrivilegeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciHasObjectPrivilegeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_license_key<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciSetLicenseKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_license_key(args.session, args.key, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciSetLicenseKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciSetLicenseKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_license_claims<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetLicenseClaimsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_license_claims(args.session, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetLicenseClaimsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetLicenseClaimsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_device_parameters<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciGetDeviceParametersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_device_parameters(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciGetDeviceParametersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciGetDeviceParametersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_runtime_extension_functions<H: OmniSciSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = OmniSciRegisterRuntimeExtensionFunctionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_runtime_extension_functions(args.session, args.udfs, args.udtfs, args.device_ir_map) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = OmniSciRegisterRuntimeExtensionFunctionsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TOmniSciException>().is_some() {
              let err = usr_err.downcast::<TOmniSciException>().expect("downcast already checked");
              let ret_err = OmniSciRegisterRuntimeExtensionFunctionsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: OmniSciSyncHandler> TProcessor for OmniSciSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "connect" => {
        self.process_connect(message_ident.sequence_number, i_prot, o_prot)
      },
      "krb5_connect" => {
        self.process_krb5_connect(message_ident.sequence_number, i_prot, o_prot)
      },
      "disconnect" => {
        self.process_disconnect(message_ident.sequence_number, i_prot, o_prot)
      },
      "switch_database" => {
        self.process_switch_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "clone_session" => {
        self.process_clone_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_server_status" => {
        self.process_get_server_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_status" => {
        self.process_get_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_hardware_info" => {
        self.process_get_hardware_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables" => {
        self.process_get_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_physical_tables" => {
        self.process_get_physical_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_views" => {
        self.process_get_views(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables_meta" => {
        self.process_get_tables_meta(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_details" => {
        self.process_get_table_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_internal_table_details" => {
        self.process_get_internal_table_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_users" => {
        self.process_get_users(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_databases" => {
        self.process_get_databases(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_version" => {
        self.process_get_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_heap_profile" => {
        self.process_start_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "stop_heap_profile" => {
        self.process_stop_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_heap_profile" => {
        self.process_get_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_memory" => {
        self.process_get_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_cpu_memory" => {
        self.process_clear_cpu_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_gpu_memory" => {
        self.process_clear_gpu_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epoch" => {
        self.process_set_table_epoch(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epoch_by_name" => {
        self.process_set_table_epoch_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epoch" => {
        self.process_get_table_epoch(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epoch_by_name" => {
        self.process_get_table_epoch_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_session_info" => {
        self.process_get_session_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute" => {
        self.process_sql_execute(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute_df" => {
        self.process_sql_execute_df(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute_gdf" => {
        self.process_sql_execute_gdf(message_ident.sequence_number, i_prot, o_prot)
      },
      "deallocate_df" => {
        self.process_deallocate_df(message_ident.sequence_number, i_prot, o_prot)
      },
      "interrupt" => {
        self.process_interrupt(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_validate" => {
        self.process_sql_validate(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_completion_hints" => {
        self.process_get_completion_hints(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_execution_mode" => {
        self.process_set_execution_mode(message_ident.sequence_number, i_prot, o_prot)
      },
      "render_vega" => {
        self.process_render_vega(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_result_row_for_pixel" => {
        self.process_get_result_row_for_pixel(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboard" => {
        self.process_get_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboards" => {
        self.process_get_dashboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_dashboard" => {
        self.process_create_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "replace_dashboard" => {
        self.process_replace_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_dashboard" => {
        self.process_delete_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "share_dashboard" => {
        self.process_share_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "unshare_dashboard" => {
        self.process_unshare_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboard_grantees" => {
        self.process_get_dashboard_grantees(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_link_view" => {
        self.process_get_link_view(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_link" => {
        self.process_create_link(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary" => {
        self.process_load_table_binary(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_columnar" => {
        self.process_load_table_binary_columnar(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_arrow" => {
        self.process_load_table_binary_arrow(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table" => {
        self.process_load_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "detect_column_types" => {
        self.process_detect_column_types(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_table" => {
        self.process_create_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_table" => {
        self.process_import_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_geo_table" => {
        self.process_import_geo_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_table_status" => {
        self.process_import_table_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_first_geo_file_in_archive" => {
        self.process_get_first_geo_file_in_archive(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_files_in_archive" => {
        self.process_get_all_files_in_archive(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_layers_in_geo_file" => {
        self.process_get_layers_in_geo_file(message_ident.sequence_number, i_prot, o_prot)
      },
      "query_get_outer_fragment_count" => {
        self.process_query_get_outer_fragment_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "check_table_consistency" => {
        self.process_check_table_consistency(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_query" => {
        self.process_start_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "execute_query_step" => {
        self.process_execute_query_step(message_ident.sequence_number, i_prot, o_prot)
      },
      "broadcast_serialized_rows" => {
        self.process_broadcast_serialized_rows(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_render_query" => {
        self.process_start_render_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "execute_next_render_step" => {
        self.process_execute_next_render_step(message_ident.sequence_number, i_prot, o_prot)
      },
      "insert_data" => {
        self.process_insert_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "checkpoint" => {
        self.process_checkpoint(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_roles" => {
        self.process_get_roles(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_db_objects_for_grantee" => {
        self.process_get_db_objects_for_grantee(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_db_object_privs" => {
        self.process_get_db_object_privs(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_roles_for_user" => {
        self.process_get_all_roles_for_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_role" => {
        self.process_has_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_object_privilege" => {
        self.process_has_object_privilege(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_license_key" => {
        self.process_set_license_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_license_claims" => {
        self.process_get_license_claims(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_device_parameters" => {
        self.process_get_device_parameters(message_ident.sequence_number, i_prot, o_prot)
      },
      "register_runtime_extension_functions" => {
        self.process_register_runtime_extension_functions(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// OmniSciConnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciConnectArgs {
  user: String,
  passwd: String,
  dbname: String,
}

impl OmniSciConnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciConnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciConnectArgs.user", &f_1)?;
    verify_required_field_exists("OmniSciConnectArgs.passwd", &f_2)?;
    verify_required_field_exists("OmniSciConnectArgs.dbname", &f_3)?;
    let ret = OmniSciConnectArgs {
      user: f_1.expect("auto-generated code should have checked for presence of required fields"),
      passwd: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("passwd", TType::String, 2))?;
    o_prot.write_string(&self.passwd)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 3))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciConnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciConnectResult {
  result_value: Option<TSessionId>,
  e: Option<TOmniSciException>,
}

impl OmniSciConnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciConnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionId> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciConnectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciConnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionId> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciConnect"
          )
        )
      )
    }
  }
}

//
// OmniSciKrb5ConnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciKrb5ConnectArgs {
  input_token: String,
  dbname: String,
}

impl OmniSciKrb5ConnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciKrb5ConnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciKrb5ConnectArgs.input_token", &f_1)?;
    verify_required_field_exists("OmniSciKrb5ConnectArgs.dbname", &f_2)?;
    let ret = OmniSciKrb5ConnectArgs {
      input_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("krb5_connect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("inputToken", TType::String, 1))?;
    o_prot.write_string(&self.input_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciKrb5ConnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciKrb5ConnectResult {
  result_value: Option<TKrb5Session>,
  e: Option<TOmniSciException>,
}

impl OmniSciKrb5ConnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciKrb5ConnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TKrb5Session> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TKrb5Session::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciKrb5ConnectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciKrb5ConnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TKrb5Session> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciKrb5Connect"
          )
        )
      )
    }
  }
}

//
// OmniSciDisconnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDisconnectArgs {
  session: TSessionId,
}

impl OmniSciDisconnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDisconnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciDisconnectArgs.session", &f_1)?;
    let ret = OmniSciDisconnectArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("disconnect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciDisconnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDisconnectResult {
  e: Option<TOmniSciException>,
}

impl OmniSciDisconnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDisconnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciDisconnectResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciDisconnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciSwitchDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSwitchDatabaseArgs {
  session: TSessionId,
  dbname: String,
}

impl OmniSciSwitchDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSwitchDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSwitchDatabaseArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSwitchDatabaseArgs.dbname", &f_2)?;
    let ret = OmniSciSwitchDatabaseArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("switch_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSwitchDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSwitchDatabaseResult {
  e: Option<TOmniSciException>,
}

impl OmniSciSwitchDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSwitchDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSwitchDatabaseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSwitchDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciCloneSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCloneSessionArgs {
  session: TSessionId,
}

impl OmniSciCloneSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCloneSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciCloneSessionArgs.session", &f_1)?;
    let ret = OmniSciCloneSessionArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clone_session_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciCloneSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCloneSessionResult {
  result_value: Option<TSessionId>,
  e: Option<TOmniSciException>,
}

impl OmniSciCloneSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCloneSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionId> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciCloneSessionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciCloneSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionId> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciCloneSession"
          )
        )
      )
    }
  }
}

//
// OmniSciGetServerStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetServerStatusArgs {
  session: TSessionId,
}

impl OmniSciGetServerStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetServerStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetServerStatusArgs.session", &f_1)?;
    let ret = OmniSciGetServerStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_server_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetServerStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetServerStatusResult {
  result_value: Option<TServerStatus>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetServerStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetServerStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TServerStatus> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TServerStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetServerStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetServerStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TServerStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetServerStatus"
          )
        )
      )
    }
  }
}

//
// OmniSciGetStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetStatusArgs {
  session: TSessionId,
}

impl OmniSciGetStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetStatusArgs.session", &f_1)?;
    let ret = OmniSciGetStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetStatusResult {
  result_value: Option<Vec<TServerStatus>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TServerStatus>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TServerStatus> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = TServerStatus::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TServerStatus>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetStatus"
          )
        )
      )
    }
  }
}

//
// OmniSciGetHardwareInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetHardwareInfoArgs {
  session: TSessionId,
}

impl OmniSciGetHardwareInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetHardwareInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetHardwareInfoArgs.session", &f_1)?;
    let ret = OmniSciGetHardwareInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_hardware_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetHardwareInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetHardwareInfoResult {
  result_value: Option<TClusterHardwareInfo>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetHardwareInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetHardwareInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TClusterHardwareInfo> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TClusterHardwareInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetHardwareInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetHardwareInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TClusterHardwareInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetHardwareInfo"
          )
        )
      )
    }
  }
}

//
// OmniSciGetTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTablesArgs {
  session: TSessionId,
}

impl OmniSciGetTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetTablesArgs.session", &f_1)?;
    let ret = OmniSciGetTablesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTablesResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = i_prot.read_string()?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetTablesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetTables"
          )
        )
      )
    }
  }
}

//
// OmniSciGetPhysicalTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetPhysicalTablesArgs {
  session: TSessionId,
}

impl OmniSciGetPhysicalTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetPhysicalTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetPhysicalTablesArgs.session", &f_1)?;
    let ret = OmniSciGetPhysicalTablesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_physical_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetPhysicalTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetPhysicalTablesResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetPhysicalTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetPhysicalTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_string()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetPhysicalTablesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetPhysicalTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetPhysicalTables"
          )
        )
      )
    }
  }
}

//
// OmniSciGetViewsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetViewsArgs {
  session: TSessionId,
}

impl OmniSciGetViewsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetViewsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetViewsArgs.session", &f_1)?;
    let ret = OmniSciGetViewsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_views_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetViewsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetViewsResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetViewsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetViewsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = i_prot.read_string()?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetViewsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetViewsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetViews"
          )
        )
      )
    }
  }
}

//
// OmniSciGetTablesMetaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTablesMetaArgs {
  session: TSessionId,
}

impl OmniSciGetTablesMetaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTablesMetaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetTablesMetaArgs.session", &f_1)?;
    let ret = OmniSciGetTablesMetaArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_meta_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetTablesMetaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTablesMetaResult {
  result_value: Option<Vec<TTableMeta>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetTablesMetaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTablesMetaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TTableMeta>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableMeta> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = TTableMeta::read_from_in_protocol(i_prot)?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetTablesMetaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetTablesMetaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TTableMeta>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetTablesMeta"
          )
        )
      )
    }
  }
}

//
// OmniSciGetTableDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTableDetailsArgs {
  session: TSessionId,
  table_name: String,
}

impl OmniSciGetTableDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTableDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetTableDetailsArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetTableDetailsArgs.table_name", &f_2)?;
    let ret = OmniSciGetTableDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetTableDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTableDetailsResult {
  result_value: Option<TTableDetails>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetTableDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTableDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetTableDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetTableDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetTableDetails"
          )
        )
      )
    }
  }
}

//
// OmniSciGetInternalTableDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetInternalTableDetailsArgs {
  session: TSessionId,
  table_name: String,
}

impl OmniSciGetInternalTableDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetInternalTableDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetInternalTableDetailsArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetInternalTableDetailsArgs.table_name", &f_2)?;
    let ret = OmniSciGetInternalTableDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_internal_table_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetInternalTableDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetInternalTableDetailsResult {
  result_value: Option<TTableDetails>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetInternalTableDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetInternalTableDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetInternalTableDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetInternalTableDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetInternalTableDetails"
          )
        )
      )
    }
  }
}

//
// OmniSciGetUsersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetUsersArgs {
  session: TSessionId,
}

impl OmniSciGetUsersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetUsersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetUsersArgs.session", &f_1)?;
    let ret = OmniSciGetUsersArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_users_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetUsersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetUsersResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetUsersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetUsersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = i_prot.read_string()?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetUsersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetUsersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetUsers"
          )
        )
      )
    }
  }
}

//
// OmniSciGetDatabasesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDatabasesArgs {
  session: TSessionId,
}

impl OmniSciGetDatabasesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDatabasesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDatabasesArgs.session", &f_1)?;
    let ret = OmniSciGetDatabasesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_databases_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDatabasesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDatabasesResult {
  result_value: Option<Vec<TDBInfo>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDatabasesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDatabasesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBInfo>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = TDBInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDatabasesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDatabasesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDatabases"
          )
        )
      )
    }
  }
}

//
// OmniSciGetVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetVersionArgs {
}

impl OmniSciGetVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetVersionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetVersionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetVersionResult {
  result_value: Option<String>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetVersionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetVersion"
          )
        )
      )
    }
  }
}

//
// OmniSciStartHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStartHeapProfileArgs {
  session: TSessionId,
}

impl OmniSciStartHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStartHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciStartHeapProfileArgs.session", &f_1)?;
    let ret = OmniSciStartHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciStartHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStartHeapProfileResult {
  e: Option<TOmniSciException>,
}

impl OmniSciStartHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStartHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciStartHeapProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciStartHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciStopHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStopHeapProfileArgs {
  session: TSessionId,
}

impl OmniSciStopHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStopHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciStopHeapProfileArgs.session", &f_1)?;
    let ret = OmniSciStopHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("stop_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciStopHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStopHeapProfileResult {
  e: Option<TOmniSciException>,
}

impl OmniSciStopHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStopHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciStopHeapProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciStopHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciGetHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetHeapProfileArgs {
  session: TSessionId,
}

impl OmniSciGetHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetHeapProfileArgs.session", &f_1)?;
    let ret = OmniSciGetHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetHeapProfileResult {
  result_value: Option<String>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetHeapProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetHeapProfile"
          )
        )
      )
    }
  }
}

//
// OmniSciGetMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetMemoryArgs {
  session: TSessionId,
  memory_level: String,
}

impl OmniSciGetMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetMemoryArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetMemoryArgs.memory_level", &f_2)?;
    let ret = OmniSciGetMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      memory_level: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("memory_level", TType::String, 2))?;
    o_prot.write_string(&self.memory_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetMemoryResult {
  result_value: Option<Vec<TNodeMemoryInfo>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TNodeMemoryInfo>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TNodeMemoryInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = TNodeMemoryInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetMemoryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TNodeMemoryInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetMemory"
          )
        )
      )
    }
  }
}

//
// OmniSciClearCpuMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciClearCpuMemoryArgs {
  session: TSessionId,
}

impl OmniSciClearCpuMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciClearCpuMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciClearCpuMemoryArgs.session", &f_1)?;
    let ret = OmniSciClearCpuMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_cpu_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciClearCpuMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciClearCpuMemoryResult {
  e: Option<TOmniSciException>,
}

impl OmniSciClearCpuMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciClearCpuMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciClearCpuMemoryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciClearCpuMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciClearGpuMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciClearGpuMemoryArgs {
  session: TSessionId,
}

impl OmniSciClearGpuMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciClearGpuMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciClearGpuMemoryArgs.session", &f_1)?;
    let ret = OmniSciClearGpuMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_gpu_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciClearGpuMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciClearGpuMemoryResult {
  e: Option<TOmniSciException>,
}

impl OmniSciClearGpuMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciClearGpuMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciClearGpuMemoryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciClearGpuMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciSetTableEpochArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetTableEpochArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
  new_epoch: i32,
}

impl OmniSciSetTableEpochArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetTableEpochArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSetTableEpochArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSetTableEpochArgs.db_id", &f_2)?;
    verify_required_field_exists("OmniSciSetTableEpochArgs.table_id", &f_3)?;
    verify_required_field_exists("OmniSciSetTableEpochArgs.new_epoch", &f_4)?;
    let ret = OmniSciSetTableEpochArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      new_epoch: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epoch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_epoch", TType::I32, 4))?;
    o_prot.write_i32(self.new_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSetTableEpochResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetTableEpochResult {
  e: Option<TOmniSciException>,
}

impl OmniSciSetTableEpochResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetTableEpochResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSetTableEpochResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSetTableEpochResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciSetTableEpochByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetTableEpochByNameArgs {
  session: TSessionId,
  table_name: String,
  new_epoch: i32,
}

impl OmniSciSetTableEpochByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetTableEpochByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSetTableEpochByNameArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSetTableEpochByNameArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciSetTableEpochByNameArgs.new_epoch", &f_3)?;
    let ret = OmniSciSetTableEpochByNameArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_epoch: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epoch_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_epoch", TType::I32, 3))?;
    o_prot.write_i32(self.new_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSetTableEpochByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetTableEpochByNameResult {
  e: Option<TOmniSciException>,
}

impl OmniSciSetTableEpochByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetTableEpochByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSetTableEpochByNameResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSetTableEpochByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciGetTableEpochArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTableEpochArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
}

impl OmniSciGetTableEpochArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTableEpochArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetTableEpochArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetTableEpochArgs.db_id", &f_2)?;
    verify_required_field_exists("OmniSciGetTableEpochArgs.table_id", &f_3)?;
    let ret = OmniSciGetTableEpochArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epoch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetTableEpochResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTableEpochResult {
  result_value: Option<i32>,
}

impl OmniSciGetTableEpochResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTableEpochResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetTableEpochResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetTableEpochResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetTableEpoch"
          )
        )
      )
    }
  }
}

//
// OmniSciGetTableEpochByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTableEpochByNameArgs {
  session: TSessionId,
  table_name: String,
}

impl OmniSciGetTableEpochByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTableEpochByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetTableEpochByNameArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetTableEpochByNameArgs.table_name", &f_2)?;
    let ret = OmniSciGetTableEpochByNameArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epoch_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetTableEpochByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetTableEpochByNameResult {
  result_value: Option<i32>,
}

impl OmniSciGetTableEpochByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetTableEpochByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetTableEpochByNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetTableEpochByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetTableEpochByName"
          )
        )
      )
    }
  }
}

//
// OmniSciGetSessionInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetSessionInfoArgs {
  session: TSessionId,
}

impl OmniSciGetSessionInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetSessionInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetSessionInfoArgs.session", &f_1)?;
    let ret = OmniSciGetSessionInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_session_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetSessionInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetSessionInfoResult {
  result_value: Option<TSessionInfo>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetSessionInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetSessionInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionInfo> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSessionInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetSessionInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetSessionInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetSessionInfo"
          )
        )
      )
    }
  }
}

//
// OmniSciSqlExecuteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlExecuteArgs {
  session: TSessionId,
  query: String,
  column_format: bool,
  nonce: String,
  first_n: i32,
  at_most_n: i32,
}

impl OmniSciSqlExecuteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlExecuteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSqlExecuteArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSqlExecuteArgs.query", &f_2)?;
    verify_required_field_exists("OmniSciSqlExecuteArgs.column_format", &f_3)?;
    verify_required_field_exists("OmniSciSqlExecuteArgs.nonce", &f_4)?;
    verify_required_field_exists("OmniSciSqlExecuteArgs.first_n", &f_5)?;
    verify_required_field_exists("OmniSciSqlExecuteArgs.at_most_n", &f_6)?;
    let ret = OmniSciSqlExecuteArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_format: f_3.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_4.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_5.expect("auto-generated code should have checked for presence of required fields"),
      at_most_n: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_format", TType::Bool, 3))?;
    o_prot.write_bool(self.column_format)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 4))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 5))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("at_most_n", TType::I32, 6))?;
    o_prot.write_i32(self.at_most_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSqlExecuteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlExecuteResult {
  result_value: Option<TQueryResult>,
  e: Option<TOmniSciException>,
}

impl OmniSciSqlExecuteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlExecuteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TQueryResult> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TQueryResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSqlExecuteResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSqlExecuteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TQueryResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciSqlExecute"
          )
        )
      )
    }
  }
}

//
// OmniSciSqlExecuteDfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlExecuteDfArgs {
  session: TSessionId,
  query: String,
  device_type: common::TDeviceType,
  device_id: i32,
  first_n: i32,
}

impl OmniSciSqlExecuteDfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlExecuteDfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<common::TDeviceType> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSqlExecuteDfArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSqlExecuteDfArgs.query", &f_2)?;
    verify_required_field_exists("OmniSciSqlExecuteDfArgs.device_type", &f_3)?;
    verify_required_field_exists("OmniSciSqlExecuteDfArgs.device_id", &f_4)?;
    verify_required_field_exists("OmniSciSqlExecuteDfArgs.first_n", &f_5)?;
    let ret = OmniSciSqlExecuteDfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_df_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 3))?;
    self.device_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 4))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 5))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSqlExecuteDfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlExecuteDfResult {
  result_value: Option<TDataFrame>,
  e: Option<TOmniSciException>,
}

impl OmniSciSqlExecuteDfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlExecuteDfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDataFrame> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSqlExecuteDfResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSqlExecuteDfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDataFrame> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciSqlExecuteDf"
          )
        )
      )
    }
  }
}

//
// OmniSciSqlExecuteGdfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlExecuteGdfArgs {
  session: TSessionId,
  query: String,
  device_id: i32,
  first_n: i32,
}

impl OmniSciSqlExecuteGdfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlExecuteGdfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSqlExecuteGdfArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSqlExecuteGdfArgs.query", &f_2)?;
    verify_required_field_exists("OmniSciSqlExecuteGdfArgs.device_id", &f_3)?;
    verify_required_field_exists("OmniSciSqlExecuteGdfArgs.first_n", &f_4)?;
    let ret = OmniSciSqlExecuteGdfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_gdf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 3))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 4))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSqlExecuteGdfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlExecuteGdfResult {
  result_value: Option<TDataFrame>,
  e: Option<TOmniSciException>,
}

impl OmniSciSqlExecuteGdfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlExecuteGdfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDataFrame> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSqlExecuteGdfResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSqlExecuteGdfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDataFrame> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciSqlExecuteGdf"
          )
        )
      )
    }
  }
}

//
// OmniSciDeallocateDfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDeallocateDfArgs {
  session: TSessionId,
  df: TDataFrame,
  device_type: common::TDeviceType,
  device_id: i32,
}

impl OmniSciDeallocateDfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDeallocateDfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TDataFrame> = None;
    let mut f_3: Option<common::TDeviceType> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciDeallocateDfArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciDeallocateDfArgs.df", &f_2)?;
    verify_required_field_exists("OmniSciDeallocateDfArgs.device_type", &f_3)?;
    verify_required_field_exists("OmniSciDeallocateDfArgs.device_id", &f_4)?;
    let ret = OmniSciDeallocateDfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      df: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deallocate_df_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("df", TType::Struct, 2))?;
    self.df.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 3))?;
    self.device_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 4))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciDeallocateDfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDeallocateDfResult {
  e: Option<TOmniSciException>,
}

impl OmniSciDeallocateDfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDeallocateDfResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciDeallocateDfResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciDeallocateDfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciInterruptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciInterruptArgs {
  query_session: TSessionId,
  interrupt_session: TSessionId,
}

impl OmniSciInterruptArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciInterruptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciInterruptArgs.query_session", &f_1)?;
    verify_required_field_exists("OmniSciInterruptArgs.interrupt_session", &f_2)?;
    let ret = OmniSciInterruptArgs {
      query_session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      interrupt_session: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("interrupt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_session", TType::String, 1))?;
    o_prot.write_string(&self.query_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("interrupt_session", TType::String, 2))?;
    o_prot.write_string(&self.interrupt_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciInterruptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciInterruptResult {
  e: Option<TOmniSciException>,
}

impl OmniSciInterruptResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciInterruptResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciInterruptResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciInterruptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciSqlValidateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlValidateArgs {
  session: TSessionId,
  query: String,
}

impl OmniSciSqlValidateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlValidateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSqlValidateArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSqlValidateArgs.query", &f_2)?;
    let ret = OmniSciSqlValidateArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_validate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSqlValidateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSqlValidateResult {
  result_value: Option<TRowDescriptor>,
  e: Option<TOmniSciException>,
}

impl OmniSciSqlValidateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSqlValidateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRowDescriptor> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSqlValidateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSqlValidateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRowDescriptor> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciSqlValidate"
          )
        )
      )
    }
  }
}

//
// OmniSciGetCompletionHintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetCompletionHintsArgs {
  session: TSessionId,
  sql: String,
  cursor: i32,
}

impl OmniSciGetCompletionHintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetCompletionHintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetCompletionHintsArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetCompletionHintsArgs.sql", &f_2)?;
    verify_required_field_exists("OmniSciGetCompletionHintsArgs.cursor", &f_3)?;
    let ret = OmniSciGetCompletionHintsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sql: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cursor: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_completion_hints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 2))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cursor", TType::I32, 3))?;
    o_prot.write_i32(self.cursor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetCompletionHintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetCompletionHintsResult {
  result_value: Option<Vec<completion_hints::TCompletionHint>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetCompletionHintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetCompletionHintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<completion_hints::TCompletionHint>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<completion_hints::TCompletionHint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = completion_hints::TCompletionHint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetCompletionHintsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetCompletionHintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<completion_hints::TCompletionHint>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetCompletionHints"
          )
        )
      )
    }
  }
}

//
// OmniSciSetExecutionModeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetExecutionModeArgs {
  session: TSessionId,
  mode: TExecuteMode,
}

impl OmniSciSetExecutionModeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetExecutionModeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TExecuteMode> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TExecuteMode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSetExecutionModeArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSetExecutionModeArgs.mode", &f_2)?;
    let ret = OmniSciSetExecutionModeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mode: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_execution_mode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mode", TType::I32, 2))?;
    self.mode.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSetExecutionModeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetExecutionModeResult {
  e: Option<TOmniSciException>,
}

impl OmniSciSetExecutionModeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetExecutionModeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSetExecutionModeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSetExecutionModeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciRenderVegaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciRenderVegaArgs {
  session: TSessionId,
  widget_id: i64,
  vega_json: String,
  compression_level: i32,
  nonce: String,
}

impl OmniSciRenderVegaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciRenderVegaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciRenderVegaArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciRenderVegaArgs.widget_id", &f_2)?;
    verify_required_field_exists("OmniSciRenderVegaArgs.vega_json", &f_3)?;
    verify_required_field_exists("OmniSciRenderVegaArgs.compression_level", &f_4)?;
    verify_required_field_exists("OmniSciRenderVegaArgs.nonce", &f_5)?;
    let ret = OmniSciRenderVegaArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      vega_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      compression_level: f_4.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("render_vega_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("vega_json", TType::String, 3))?;
    o_prot.write_string(&self.vega_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compression_level", TType::I32, 4))?;
    o_prot.write_i32(self.compression_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 5))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciRenderVegaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciRenderVegaResult {
  result_value: Option<TRenderResult>,
  e: Option<TOmniSciException>,
}

impl OmniSciRenderVegaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciRenderVegaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenderResult> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenderResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciRenderVegaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciRenderVegaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenderResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciRenderVega"
          )
        )
      )
    }
  }
}

//
// OmniSciGetResultRowForPixelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetResultRowForPixelArgs {
  session: TSessionId,
  widget_id: i64,
  pixel: TPixel,
  table_col_names: BTreeMap<String, Vec<String>>,
  column_format: bool,
  pixel_radius: i32,
  nonce: String,
}

impl OmniSciGetResultRowForPixelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetResultRowForPixelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<TPixel> = None;
    let mut f_4: Option<BTreeMap<String, Vec<String>>> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TPixel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<String>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_50 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_51: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_52 = i_prot.read_string()?;
              map_val_51.push(list_elem_52);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_50, map_val_51);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.widget_id", &f_2)?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.pixel", &f_3)?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.table_col_names", &f_4)?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.column_format", &f_5)?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.pixel_radius", &f_6)?;
    verify_required_field_exists("OmniSciGetResultRowForPixelArgs.nonce", &f_7)?;
    let ret = OmniSciGetResultRowForPixelArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pixel: f_3.expect("auto-generated code should have checked for presence of required fields"),
      table_col_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
      column_format: f_5.expect("auto-generated code should have checked for presence of required fields"),
      pixel_radius: f_6.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_result_row_for_pixel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pixel", TType::Struct, 3))?;
    self.pixel.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_col_names", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, self.table_col_names.len() as i32))?;
    for (k, v) in &self.table_col_names {
      o_prot.write_string(k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, v.len() as i32))?;
      for e in v {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_format", TType::Bool, 5))?;
    o_prot.write_bool(self.column_format)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pixelRadius", TType::I32, 6))?;
    o_prot.write_i32(self.pixel_radius)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 7))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetResultRowForPixelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetResultRowForPixelResult {
  result_value: Option<TPixelTableRowResult>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetResultRowForPixelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetResultRowForPixelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPixelTableRowResult> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPixelTableRowResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetResultRowForPixelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetResultRowForPixelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPixelTableRowResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetRowForPixelResult"
          )
        )
      )
    }
  }
}

//
// OmniSciGetDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl OmniSciGetDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDashboardArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetDashboardArgs.dashboard_id", &f_2)?;
    let ret = OmniSciGetDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDashboardResult {
  result_value: Option<TDashboard>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDashboard> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDashboard::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDashboardResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDashboard> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDashboard"
          )
        )
      )
    }
  }
}

//
// OmniSciGetDashboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDashboardsArgs {
  session: TSessionId,
}

impl OmniSciGetDashboardsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDashboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDashboardsArgs.session", &f_1)?;
    let ret = OmniSciGetDashboardsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDashboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDashboardsResult {
  result_value: Option<Vec<TDashboard>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDashboardsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDashboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDashboard>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDashboard> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_53 = TDashboard::read_from_in_protocol(i_prot)?;
            val.push(list_elem_53);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDashboardsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDashboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDashboard>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDashboards"
          )
        )
      )
    }
  }
}

//
// OmniSciCreateDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCreateDashboardArgs {
  session: TSessionId,
  dashboard_name: String,
  dashboard_state: String,
  image_hash: String,
  dashboard_metadata: String,
}

impl OmniSciCreateDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCreateDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciCreateDashboardArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciCreateDashboardArgs.dashboard_name", &f_2)?;
    verify_required_field_exists("OmniSciCreateDashboardArgs.dashboard_state", &f_3)?;
    verify_required_field_exists("OmniSciCreateDashboardArgs.image_hash", &f_4)?;
    verify_required_field_exists("OmniSciCreateDashboardArgs.dashboard_metadata", &f_5)?;
    let ret = OmniSciCreateDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_state: f_3.expect("auto-generated code should have checked for presence of required fields"),
      image_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_metadata: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 2))?;
    o_prot.write_string(&self.dashboard_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 3))?;
    o_prot.write_string(&self.dashboard_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 4))?;
    o_prot.write_string(&self.image_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 5))?;
    o_prot.write_string(&self.dashboard_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciCreateDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCreateDashboardResult {
  result_value: Option<i32>,
  e: Option<TOmniSciException>,
}

impl OmniSciCreateDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCreateDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciCreateDashboardResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciCreateDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciCreateDashboard"
          )
        )
      )
    }
  }
}

//
// OmniSciReplaceDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciReplaceDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  dashboard_name: String,
  dashboard_owner: String,
  dashboard_state: String,
  image_hash: String,
  dashboard_metadata: String,
}

impl OmniSciReplaceDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciReplaceDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.dashboard_name", &f_3)?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.dashboard_owner", &f_4)?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.dashboard_state", &f_5)?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.image_hash", &f_6)?;
    verify_required_field_exists("OmniSciReplaceDashboardArgs.dashboard_metadata", &f_7)?;
    let ret = OmniSciReplaceDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_owner: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_state: f_5.expect("auto-generated code should have checked for presence of required fields"),
      image_hash: f_6.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_metadata: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("replace_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 3))?;
    o_prot.write_string(&self.dashboard_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_owner", TType::String, 4))?;
    o_prot.write_string(&self.dashboard_owner)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 5))?;
    o_prot.write_string(&self.dashboard_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 6))?;
    o_prot.write_string(&self.image_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 7))?;
    o_prot.write_string(&self.dashboard_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciReplaceDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciReplaceDashboardResult {
  e: Option<TOmniSciException>,
}

impl OmniSciReplaceDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciReplaceDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciReplaceDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciReplaceDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciDeleteDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDeleteDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl OmniSciDeleteDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDeleteDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciDeleteDashboardArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciDeleteDashboardArgs.dashboard_id", &f_2)?;
    let ret = OmniSciDeleteDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciDeleteDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDeleteDashboardResult {
  e: Option<TOmniSciException>,
}

impl OmniSciDeleteDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDeleteDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciDeleteDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciDeleteDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciShareDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciShareDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  groups: Vec<String>,
  objects: Vec<String>,
  permissions: TDashboardPermissions,
  grant_role: bool,
}

impl OmniSciShareDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciShareDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<TDashboardPermissions> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = i_prot.read_string()?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = i_prot.read_string()?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciShareDashboardArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciShareDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("OmniSciShareDashboardArgs.groups", &f_3)?;
    verify_required_field_exists("OmniSciShareDashboardArgs.objects", &f_4)?;
    verify_required_field_exists("OmniSciShareDashboardArgs.permissions", &f_5)?;
    verify_required_field_exists("OmniSciShareDashboardArgs.grant_role", &f_6)?;
    let ret = OmniSciShareDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      objects: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
      grant_role: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("share_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objects", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.objects.len() as i32))?;
    for e in &self.objects {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grant_role", TType::Bool, 6))?;
    o_prot.write_bool(self.grant_role)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciShareDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciShareDashboardResult {
  e: Option<TOmniSciException>,
}

impl OmniSciShareDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciShareDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciShareDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciShareDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciUnshareDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciUnshareDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  groups: Vec<String>,
  objects: Vec<String>,
  permissions: TDashboardPermissions,
}

impl OmniSciUnshareDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciUnshareDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = i_prot.read_string()?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = i_prot.read_string()?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciUnshareDashboardArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciUnshareDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("OmniSciUnshareDashboardArgs.groups", &f_3)?;
    verify_required_field_exists("OmniSciUnshareDashboardArgs.objects", &f_4)?;
    verify_required_field_exists("OmniSciUnshareDashboardArgs.permissions", &f_5)?;
    let ret = OmniSciUnshareDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      objects: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unshare_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objects", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.objects.len() as i32))?;
    for e in &self.objects {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciUnshareDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciUnshareDashboardResult {
  e: Option<TOmniSciException>,
}

impl OmniSciUnshareDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciUnshareDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciUnshareDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciUnshareDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciGetDashboardGranteesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDashboardGranteesArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl OmniSciGetDashboardGranteesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDashboardGranteesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDashboardGranteesArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetDashboardGranteesArgs.dashboard_id", &f_2)?;
    let ret = OmniSciGetDashboardGranteesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboard_grantees_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDashboardGranteesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDashboardGranteesResult {
  result_value: Option<Vec<TDashboardGrantees>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDashboardGranteesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDashboardGranteesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDashboardGrantees>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDashboardGrantees> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = TDashboardGrantees::read_from_in_protocol(i_prot)?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDashboardGranteesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDashboardGranteesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDashboardGrantees>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDashboardGrantees"
          )
        )
      )
    }
  }
}

//
// OmniSciGetLinkViewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetLinkViewArgs {
  session: TSessionId,
  link: String,
}

impl OmniSciGetLinkViewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetLinkViewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetLinkViewArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetLinkViewArgs.link", &f_2)?;
    let ret = OmniSciGetLinkViewArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      link: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_link_view_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("link", TType::String, 2))?;
    o_prot.write_string(&self.link)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetLinkViewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetLinkViewResult {
  result_value: Option<TFrontendView>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetLinkViewResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetLinkViewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TFrontendView> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TFrontendView::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetLinkViewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetLinkViewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TFrontendView> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetLinkView"
          )
        )
      )
    }
  }
}

//
// OmniSciCreateLinkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCreateLinkArgs {
  session: TSessionId,
  view_state: String,
  view_metadata: String,
}

impl OmniSciCreateLinkArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCreateLinkArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciCreateLinkArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciCreateLinkArgs.view_state", &f_2)?;
    verify_required_field_exists("OmniSciCreateLinkArgs.view_metadata", &f_3)?;
    let ret = OmniSciCreateLinkArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      view_state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      view_metadata: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_link_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("view_state", TType::String, 2))?;
    o_prot.write_string(&self.view_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("view_metadata", TType::String, 3))?;
    o_prot.write_string(&self.view_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciCreateLinkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCreateLinkResult {
  result_value: Option<String>,
  e: Option<TOmniSciException>,
}

impl OmniSciCreateLinkResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCreateLinkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciCreateLinkResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciCreateLinkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciCreateLink"
          )
        )
      )
    }
  }
}

//
// OmniSciLoadTableBinaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableBinaryArgs {
  session: TSessionId,
  table_name: String,
  rows: Vec<TRow>,
}

impl OmniSciLoadTableBinaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableBinaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TRow>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciLoadTableBinaryArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciLoadTableBinaryArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciLoadTableBinaryArgs.rows", &f_3)?;
    let ret = OmniSciLoadTableBinaryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciLoadTableBinaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableBinaryResult {
  e: Option<TOmniSciException>,
}

impl OmniSciLoadTableBinaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableBinaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciLoadTableBinaryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciLoadTableBinaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciLoadTableBinaryColumnarArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableBinaryColumnarArgs {
  session: TSessionId,
  table_name: String,
  cols: Vec<TColumn>,
}

impl OmniSciLoadTableBinaryColumnarArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableBinaryColumnarArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TColumn>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciLoadTableBinaryColumnarArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciLoadTableBinaryColumnarArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciLoadTableBinaryColumnarArgs.cols", &f_3)?;
    let ret = OmniSciLoadTableBinaryColumnarArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cols: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_columnar_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.cols.len() as i32))?;
    for e in &self.cols {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciLoadTableBinaryColumnarResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableBinaryColumnarResult {
  e: Option<TOmniSciException>,
}

impl OmniSciLoadTableBinaryColumnarResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableBinaryColumnarResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciLoadTableBinaryColumnarResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciLoadTableBinaryColumnarResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciLoadTableBinaryArrowArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableBinaryArrowArgs {
  session: TSessionId,
  table_name: String,
  arrow_stream: Vec<u8>,
}

impl OmniSciLoadTableBinaryArrowArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableBinaryArrowArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciLoadTableBinaryArrowArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciLoadTableBinaryArrowArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciLoadTableBinaryArrowArgs.arrow_stream", &f_3)?;
    let ret = OmniSciLoadTableBinaryArrowArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      arrow_stream: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_arrow_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("arrow_stream", TType::String, 3))?;
    o_prot.write_bytes(&self.arrow_stream)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciLoadTableBinaryArrowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableBinaryArrowResult {
  e: Option<TOmniSciException>,
}

impl OmniSciLoadTableBinaryArrowResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableBinaryArrowResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciLoadTableBinaryArrowResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciLoadTableBinaryArrowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciLoadTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableArgs {
  session: TSessionId,
  table_name: String,
  rows: Vec<TStringRow>,
}

impl OmniSciLoadTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TStringRow>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStringRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = TStringRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciLoadTableArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciLoadTableArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciLoadTableArgs.rows", &f_3)?;
    let ret = OmniSciLoadTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciLoadTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciLoadTableResult {
  e: Option<TOmniSciException>,
}

impl OmniSciLoadTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciLoadTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciLoadTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciLoadTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciDetectColumnTypesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDetectColumnTypesArgs {
  session: TSessionId,
  file_name: String,
  copy_params: TCopyParams,
}

impl OmniSciDetectColumnTypesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDetectColumnTypesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciDetectColumnTypesArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciDetectColumnTypesArgs.file_name", &f_2)?;
    verify_required_field_exists("OmniSciDetectColumnTypesArgs.copy_params", &f_3)?;
    let ret = OmniSciDetectColumnTypesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("detect_column_types_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 2))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciDetectColumnTypesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciDetectColumnTypesResult {
  result_value: Option<TDetectResult>,
  e: Option<TOmniSciException>,
}

impl OmniSciDetectColumnTypesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciDetectColumnTypesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDetectResult> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDetectResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciDetectColumnTypesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciDetectColumnTypesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDetectResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciDetectColumnTypes"
          )
        )
      )
    }
  }
}

//
// OmniSciCreateTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCreateTableArgs {
  session: TSessionId,
  table_name: String,
  row_desc: TRowDescriptor,
  file_type: TFileType,
  create_params: TCreateParams,
}

impl OmniSciCreateTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCreateTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TRowDescriptor> = None;
    let mut f_4: Option<TFileType> = None;
    let mut f_5: Option<TCreateParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TFileType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TCreateParams::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciCreateTableArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciCreateTableArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciCreateTableArgs.row_desc", &f_3)?;
    verify_required_field_exists("OmniSciCreateTableArgs.file_type", &f_4)?;
    verify_required_field_exists("OmniSciCreateTableArgs.create_params", &f_5)?;
    let ret = OmniSciCreateTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_3.expect("auto-generated code should have checked for presence of required fields"),
      file_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      create_params: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 4))?;
    self.file_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("create_params", TType::Struct, 5))?;
    self.create_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciCreateTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCreateTableResult {
  e: Option<TOmniSciException>,
}

impl OmniSciCreateTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCreateTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciCreateTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciCreateTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciImportTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciImportTableArgs {
  session: TSessionId,
  table_name: String,
  file_name: String,
  copy_params: TCopyParams,
}

impl OmniSciImportTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciImportTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciImportTableArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciImportTableArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciImportTableArgs.file_name", &f_3)?;
    verify_required_field_exists("OmniSciImportTableArgs.copy_params", &f_4)?;
    let ret = OmniSciImportTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 3))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 4))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciImportTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciImportTableResult {
  e: Option<TOmniSciException>,
}

impl OmniSciImportTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciImportTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciImportTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciImportTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciImportGeoTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciImportGeoTableArgs {
  session: TSessionId,
  table_name: String,
  file_name: String,
  copy_params: TCopyParams,
  row_desc: TRowDescriptor,
  create_params: TCreateParams,
}

impl OmniSciImportGeoTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciImportGeoTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TCopyParams> = None;
    let mut f_5: Option<TRowDescriptor> = None;
    let mut f_6: Option<TCreateParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = TCreateParams::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciImportGeoTableArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciImportGeoTableArgs.table_name", &f_2)?;
    verify_required_field_exists("OmniSciImportGeoTableArgs.file_name", &f_3)?;
    verify_required_field_exists("OmniSciImportGeoTableArgs.copy_params", &f_4)?;
    verify_required_field_exists("OmniSciImportGeoTableArgs.row_desc", &f_5)?;
    verify_required_field_exists("OmniSciImportGeoTableArgs.create_params", &f_6)?;
    let ret = OmniSciImportGeoTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_5.expect("auto-generated code should have checked for presence of required fields"),
      create_params: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_geo_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 3))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 4))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("create_params", TType::Struct, 6))?;
    self.create_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciImportGeoTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciImportGeoTableResult {
  e: Option<TOmniSciException>,
}

impl OmniSciImportGeoTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciImportGeoTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciImportGeoTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciImportGeoTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciImportTableStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciImportTableStatusArgs {
  session: TSessionId,
  import_id: String,
}

impl OmniSciImportTableStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciImportTableStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciImportTableStatusArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciImportTableStatusArgs.import_id", &f_2)?;
    let ret = OmniSciImportTableStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      import_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_table_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("import_id", TType::String, 2))?;
    o_prot.write_string(&self.import_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciImportTableStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciImportTableStatusResult {
  result_value: Option<TImportStatus>,
  e: Option<TOmniSciException>,
}

impl OmniSciImportTableStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciImportTableStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TImportStatus> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TImportStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciImportTableStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciImportTableStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TImportStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciImportTableStatus"
          )
        )
      )
    }
  }
}

//
// OmniSciGetFirstGeoFileInArchiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetFirstGeoFileInArchiveArgs {
  session: TSessionId,
  archive_path: String,
  copy_params: TCopyParams,
}

impl OmniSciGetFirstGeoFileInArchiveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetFirstGeoFileInArchiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetFirstGeoFileInArchiveArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetFirstGeoFileInArchiveArgs.archive_path", &f_2)?;
    verify_required_field_exists("OmniSciGetFirstGeoFileInArchiveArgs.copy_params", &f_3)?;
    let ret = OmniSciGetFirstGeoFileInArchiveArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      archive_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_first_geo_file_in_archive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("archive_path", TType::String, 2))?;
    o_prot.write_string(&self.archive_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetFirstGeoFileInArchiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetFirstGeoFileInArchiveResult {
  result_value: Option<String>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetFirstGeoFileInArchiveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetFirstGeoFileInArchiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetFirstGeoFileInArchiveResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetFirstGeoFileInArchiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetFirstGeoFileInArchive"
          )
        )
      )
    }
  }
}

//
// OmniSciGetAllFilesInArchiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetAllFilesInArchiveArgs {
  session: TSessionId,
  archive_path: String,
  copy_params: TCopyParams,
}

impl OmniSciGetAllFilesInArchiveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetAllFilesInArchiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetAllFilesInArchiveArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetAllFilesInArchiveArgs.archive_path", &f_2)?;
    verify_required_field_exists("OmniSciGetAllFilesInArchiveArgs.copy_params", &f_3)?;
    let ret = OmniSciGetAllFilesInArchiveArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      archive_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_files_in_archive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("archive_path", TType::String, 2))?;
    o_prot.write_string(&self.archive_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetAllFilesInArchiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetAllFilesInArchiveResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetAllFilesInArchiveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetAllFilesInArchiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_64 = i_prot.read_string()?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetAllFilesInArchiveResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetAllFilesInArchiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetAllFilesInArchive"
          )
        )
      )
    }
  }
}

//
// OmniSciGetLayersInGeoFileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetLayersInGeoFileArgs {
  session: TSessionId,
  file_name: String,
  copy_params: TCopyParams,
}

impl OmniSciGetLayersInGeoFileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetLayersInGeoFileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetLayersInGeoFileArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetLayersInGeoFileArgs.file_name", &f_2)?;
    verify_required_field_exists("OmniSciGetLayersInGeoFileArgs.copy_params", &f_3)?;
    let ret = OmniSciGetLayersInGeoFileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_layers_in_geo_file_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 2))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetLayersInGeoFileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetLayersInGeoFileResult {
  result_value: Option<Vec<TGeoFileLayerInfo>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetLayersInGeoFileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetLayersInGeoFileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TGeoFileLayerInfo>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TGeoFileLayerInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_65 = TGeoFileLayerInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_65);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetLayersInGeoFileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetLayersInGeoFileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TGeoFileLayerInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetLayersInGeoFile"
          )
        )
      )
    }
  }
}

//
// OmniSciQueryGetOuterFragmentCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciQueryGetOuterFragmentCountArgs {
  session: TSessionId,
  query: String,
}

impl OmniSciQueryGetOuterFragmentCountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciQueryGetOuterFragmentCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciQueryGetOuterFragmentCountArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciQueryGetOuterFragmentCountArgs.query", &f_2)?;
    let ret = OmniSciQueryGetOuterFragmentCountArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("query_get_outer_fragment_count_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciQueryGetOuterFragmentCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciQueryGetOuterFragmentCountResult {
  result_value: Option<i64>,
  e: Option<TOmniSciException>,
}

impl OmniSciQueryGetOuterFragmentCountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciQueryGetOuterFragmentCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciQueryGetOuterFragmentCountResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciQueryGetOuterFragmentCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciQueryGetOuterFragmentCount"
          )
        )
      )
    }
  }
}

//
// OmniSciCheckTableConsistencyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCheckTableConsistencyArgs {
  session: TSessionId,
  table_id: i32,
}

impl OmniSciCheckTableConsistencyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCheckTableConsistencyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciCheckTableConsistencyArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciCheckTableConsistencyArgs.table_id", &f_2)?;
    let ret = OmniSciCheckTableConsistencyArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("check_table_consistency_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciCheckTableConsistencyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCheckTableConsistencyResult {
  result_value: Option<TTableMeta>,
  e: Option<TOmniSciException>,
}

impl OmniSciCheckTableConsistencyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCheckTableConsistencyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableMeta> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableMeta::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciCheckTableConsistencyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciCheckTableConsistencyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableMeta> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciCheckTableConsistency"
          )
        )
      )
    }
  }
}

//
// OmniSciStartQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStartQueryArgs {
  leaf_session: TSessionId,
  parent_session: TSessionId,
  query_ra: String,
  just_explain: bool,
  outer_fragment_indices: Vec<i64>,
}

impl OmniSciStartQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStartQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TSessionId> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = i_prot.read_i64()?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciStartQueryArgs.leaf_session", &f_1)?;
    verify_required_field_exists("OmniSciStartQueryArgs.parent_session", &f_2)?;
    verify_required_field_exists("OmniSciStartQueryArgs.query_ra", &f_3)?;
    verify_required_field_exists("OmniSciStartQueryArgs.just_explain", &f_4)?;
    verify_required_field_exists("OmniSciStartQueryArgs.outer_fragment_indices", &f_5)?;
    let ret = OmniSciStartQueryArgs {
      leaf_session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parent_session: f_2.expect("auto-generated code should have checked for presence of required fields"),
      query_ra: f_3.expect("auto-generated code should have checked for presence of required fields"),
      just_explain: f_4.expect("auto-generated code should have checked for presence of required fields"),
      outer_fragment_indices: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaf_session", TType::String, 1))?;
    o_prot.write_string(&self.leaf_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parent_session", TType::String, 2))?;
    o_prot.write_string(&self.parent_session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_ra", TType::String, 3))?;
    o_prot.write_string(&self.query_ra)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("just_explain", TType::Bool, 4))?;
    o_prot.write_bool(self.just_explain)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("outer_fragment_indices", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.outer_fragment_indices.len() as i32))?;
    for e in &self.outer_fragment_indices {
      o_prot.write_i64(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciStartQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStartQueryResult {
  result_value: Option<TPendingQuery>,
  e: Option<TOmniSciException>,
}

impl OmniSciStartQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStartQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPendingQuery> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPendingQuery::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciStartQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciStartQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPendingQuery> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciStartQuery"
          )
        )
      )
    }
  }
}

//
// OmniSciExecuteQueryStepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciExecuteQueryStepArgs {
  pending_query: TPendingQuery,
}

impl OmniSciExecuteQueryStepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciExecuteQueryStepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPendingQuery> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPendingQuery::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciExecuteQueryStepArgs.pending_query", &f_1)?;
    let ret = OmniSciExecuteQueryStepArgs {
      pending_query: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("execute_query_step_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pending_query", TType::Struct, 1))?;
    self.pending_query.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciExecuteQueryStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciExecuteQueryStepResult {
  result_value: Option<TStepResult>,
  e: Option<TOmniSciException>,
}

impl OmniSciExecuteQueryStepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciExecuteQueryStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TStepResult> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TStepResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciExecuteQueryStepResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciExecuteQueryStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TStepResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciExecuteQueryStep"
          )
        )
      )
    }
  }
}

//
// OmniSciBroadcastSerializedRowsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciBroadcastSerializedRowsArgs {
  serialized_rows: serialized_result_set::TSerializedRows,
  row_desc: TRowDescriptor,
  query_id: TQueryId,
}

impl OmniSciBroadcastSerializedRowsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciBroadcastSerializedRowsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<serialized_result_set::TSerializedRows> = None;
    let mut f_2: Option<TRowDescriptor> = None;
    let mut f_3: Option<TQueryId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = serialized_result_set::TSerializedRows::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciBroadcastSerializedRowsArgs.serialized_rows", &f_1)?;
    verify_required_field_exists("OmniSciBroadcastSerializedRowsArgs.row_desc", &f_2)?;
    verify_required_field_exists("OmniSciBroadcastSerializedRowsArgs.query_id", &f_3)?;
    let ret = OmniSciBroadcastSerializedRowsArgs {
      serialized_rows: f_1.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_2.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("broadcast_serialized_rows_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialized_rows", TType::Struct, 1))?;
    self.serialized_rows.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::I64, 3))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciBroadcastSerializedRowsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciBroadcastSerializedRowsResult {
  e: Option<TOmniSciException>,
}

impl OmniSciBroadcastSerializedRowsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciBroadcastSerializedRowsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciBroadcastSerializedRowsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciBroadcastSerializedRowsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciStartRenderQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStartRenderQueryArgs {
  session: TSessionId,
  widget_id: i64,
  node_idx: i16,
  vega_json: String,
}

impl OmniSciStartRenderQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStartRenderQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i16> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciStartRenderQueryArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciStartRenderQueryArgs.widget_id", &f_2)?;
    verify_required_field_exists("OmniSciStartRenderQueryArgs.node_idx", &f_3)?;
    verify_required_field_exists("OmniSciStartRenderQueryArgs.vega_json", &f_4)?;
    let ret = OmniSciStartRenderQueryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      node_idx: f_3.expect("auto-generated code should have checked for presence of required fields"),
      vega_json: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_render_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_idx", TType::I16, 3))?;
    o_prot.write_i16(self.node_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("vega_json", TType::String, 4))?;
    o_prot.write_string(&self.vega_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciStartRenderQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciStartRenderQueryResult {
  result_value: Option<TPendingRenderQuery>,
  e: Option<TOmniSciException>,
}

impl OmniSciStartRenderQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciStartRenderQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPendingRenderQuery> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPendingRenderQuery::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciStartRenderQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciStartRenderQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPendingRenderQuery> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciStartRenderQuery"
          )
        )
      )
    }
  }
}

//
// OmniSciExecuteNextRenderStepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciExecuteNextRenderStepArgs {
  pending_render: TPendingRenderQuery,
  merged_data: TRenderAggDataMap,
}

impl OmniSciExecuteNextRenderStepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciExecuteNextRenderStepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPendingRenderQuery> = None;
    let mut f_2: Option<TRenderAggDataMap> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPendingRenderQuery::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_68 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_69: BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_70 = i_prot.read_string()?;
              let map_ident = i_prot.read_map_begin()?;
              let mut map_val_71: BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>> = BTreeMap::new();
              for _ in 0..map_ident.size {
                let map_key_72 = i_prot.read_string()?;
                let map_ident = i_prot.read_map_begin()?;
                let mut map_val_73: BTreeMap<String, Vec<TRenderDatum>> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_74 = i_prot.read_string()?;
                  let list_ident = i_prot.read_list_begin()?;
                  let mut map_val_75: Vec<TRenderDatum> = Vec::with_capacity(list_ident.size as usize);
                  for _ in 0..list_ident.size {
                    let list_elem_76 = TRenderDatum::read_from_in_protocol(i_prot)?;
                    map_val_75.push(list_elem_76);
                  }
                  i_prot.read_list_end()?;
                  map_val_73.insert(map_key_74, map_val_75);
                }
                i_prot.read_map_end()?;
                map_val_71.insert(map_key_72, map_val_73);
              }
              i_prot.read_map_end()?;
              map_val_69.insert(map_key_70, map_val_71);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_68, map_val_69);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciExecuteNextRenderStepArgs.pending_render", &f_1)?;
    verify_required_field_exists("OmniSciExecuteNextRenderStepArgs.merged_data", &f_2)?;
    let ret = OmniSciExecuteNextRenderStepArgs {
      pending_render: f_1.expect("auto-generated code should have checked for presence of required fields"),
      merged_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("execute_next_render_step_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pending_render", TType::Struct, 1))?;
    self.pending_render.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("merged_data", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, self.merged_data.len() as i32))?;
    for (k, v) in &self.merged_data {
      o_prot.write_string(k)?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
      for (k, v) in v {
        o_prot.write_string(k)?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
        for (k, v) in v {
          o_prot.write_string(k)?;
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
          for (k, v) in v {
            o_prot.write_string(k)?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
            for e in v {
              e.write_to_out_protocol(o_prot)?;
              o_prot.write_list_end()?;
            }
            o_prot.write_map_end()?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciExecuteNextRenderStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciExecuteNextRenderStepResult {
  result_value: Option<TRenderStepResult>,
  e: Option<TOmniSciException>,
}

impl OmniSciExecuteNextRenderStepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciExecuteNextRenderStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenderStepResult> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenderStepResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciExecuteNextRenderStepResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciExecuteNextRenderStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenderStepResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciExecuteNextRenderStep"
          )
        )
      )
    }
  }
}

//
// OmniSciInsertDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciInsertDataArgs {
  session: TSessionId,
  insert_data: TInsertData,
}

impl OmniSciInsertDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciInsertDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TInsertData> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TInsertData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciInsertDataArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciInsertDataArgs.insert_data", &f_2)?;
    let ret = OmniSciInsertDataArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      insert_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insert_data_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("insert_data", TType::Struct, 2))?;
    self.insert_data.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciInsertDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciInsertDataResult {
  e: Option<TOmniSciException>,
}

impl OmniSciInsertDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciInsertDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciInsertDataResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciInsertDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciCheckpointArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCheckpointArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
}

impl OmniSciCheckpointArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCheckpointArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciCheckpointArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciCheckpointArgs.db_id", &f_2)?;
    verify_required_field_exists("OmniSciCheckpointArgs.table_id", &f_3)?;
    let ret = OmniSciCheckpointArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkpoint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciCheckpointResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciCheckpointResult {
  e: Option<TOmniSciException>,
}

impl OmniSciCheckpointResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciCheckpointResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciCheckpointResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciCheckpointResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// OmniSciGetRolesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetRolesArgs {
  session: TSessionId,
}

impl OmniSciGetRolesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetRolesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetRolesArgs.session", &f_1)?;
    let ret = OmniSciGetRolesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_roles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetRolesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetRolesResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetRolesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetRolesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_77 = i_prot.read_string()?;
            val.push(list_elem_77);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetRolesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetRolesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetRoles"
          )
        )
      )
    }
  }
}

//
// OmniSciGetDbObjectsForGranteeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDbObjectsForGranteeArgs {
  session: TSessionId,
  role_name: String,
}

impl OmniSciGetDbObjectsForGranteeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDbObjectsForGranteeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDbObjectsForGranteeArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetDbObjectsForGranteeArgs.role_name", &f_2)?;
    let ret = OmniSciGetDbObjectsForGranteeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      role_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_db_objects_for_grantee_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 2))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDbObjectsForGranteeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDbObjectsForGranteeResult {
  result_value: Option<Vec<TDBObject>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDbObjectsForGranteeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDbObjectsForGranteeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBObject>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBObject> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_78 = TDBObject::read_from_in_protocol(i_prot)?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDbObjectsForGranteeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDbObjectsForGranteeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBObject>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDbObjectsForGrantee"
          )
        )
      )
    }
  }
}

//
// OmniSciGetDbObjectPrivsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDbObjectPrivsArgs {
  session: TSessionId,
  object_name: String,
  type_: TDBObjectType,
}

impl OmniSciGetDbObjectPrivsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDbObjectPrivsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TDBObjectType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDbObjectPrivsArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetDbObjectPrivsArgs.object_name", &f_2)?;
    verify_required_field_exists("OmniSciGetDbObjectPrivsArgs.type_", &f_3)?;
    let ret = OmniSciGetDbObjectPrivsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      object_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_db_object_privs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 2))?;
    o_prot.write_string(&self.object_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDbObjectPrivsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDbObjectPrivsResult {
  result_value: Option<Vec<TDBObject>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDbObjectPrivsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDbObjectPrivsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBObject>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBObject> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_79 = TDBObject::read_from_in_protocol(i_prot)?;
            val.push(list_elem_79);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDbObjectPrivsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDbObjectPrivsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBObject>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDbObjectPrivs"
          )
        )
      )
    }
  }
}

//
// OmniSciGetAllRolesForUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetAllRolesForUserArgs {
  session: TSessionId,
  user_name: String,
}

impl OmniSciGetAllRolesForUserArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetAllRolesForUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetAllRolesForUserArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetAllRolesForUserArgs.user_name", &f_2)?;
    let ret = OmniSciGetAllRolesForUserArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_roles_for_user_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 2))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetAllRolesForUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetAllRolesForUserResult {
  result_value: Option<Vec<String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetAllRolesForUserResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetAllRolesForUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_80 = i_prot.read_string()?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetAllRolesForUserResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetAllRolesForUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetAllRolesForUser"
          )
        )
      )
    }
  }
}

//
// OmniSciHasRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciHasRoleArgs {
  session: TSessionId,
  grantee_name: String,
  role_name: String,
}

impl OmniSciHasRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciHasRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciHasRoleArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciHasRoleArgs.grantee_name", &f_2)?;
    verify_required_field_exists("OmniSciHasRoleArgs.role_name", &f_3)?;
    let ret = OmniSciHasRoleArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      grantee_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("granteeName", TType::String, 2))?;
    o_prot.write_string(&self.grantee_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 3))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciHasRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciHasRoleResult {
  result_value: Option<bool>,
  e: Option<TOmniSciException>,
}

impl OmniSciHasRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciHasRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciHasRoleResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciHasRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciHasRole"
          )
        )
      )
    }
  }
}

//
// OmniSciHasObjectPrivilegeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciHasObjectPrivilegeArgs {
  session: TSessionId,
  grantee_name: String,
  object_name: String,
  object_type: TDBObjectType,
  permissions: TDBObjectPermissions,
}

impl OmniSciHasObjectPrivilegeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciHasObjectPrivilegeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TDBObjectType> = None;
    let mut f_5: Option<TDBObjectPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDBObjectPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciHasObjectPrivilegeArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciHasObjectPrivilegeArgs.grantee_name", &f_2)?;
    verify_required_field_exists("OmniSciHasObjectPrivilegeArgs.object_name", &f_3)?;
    verify_required_field_exists("OmniSciHasObjectPrivilegeArgs.object_type", &f_4)?;
    verify_required_field_exists("OmniSciHasObjectPrivilegeArgs.permissions", &f_5)?;
    let ret = OmniSciHasObjectPrivilegeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      grantee_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      object_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      object_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_object_privilege_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("granteeName", TType::String, 2))?;
    o_prot.write_string(&self.grantee_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ObjectName", TType::String, 3))?;
    o_prot.write_string(&self.object_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 4))?;
    self.object_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciHasObjectPrivilegeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciHasObjectPrivilegeResult {
  result_value: Option<bool>,
  e: Option<TOmniSciException>,
}

impl OmniSciHasObjectPrivilegeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciHasObjectPrivilegeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciHasObjectPrivilegeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciHasObjectPrivilegeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciHasObjectPrivilege"
          )
        )
      )
    }
  }
}

//
// OmniSciSetLicenseKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetLicenseKeyArgs {
  session: TSessionId,
  key: String,
  nonce: String,
}

impl OmniSciSetLicenseKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetLicenseKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciSetLicenseKeyArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciSetLicenseKeyArgs.key", &f_2)?;
    verify_required_field_exists("OmniSciSetLicenseKeyArgs.nonce", &f_3)?;
    let ret = OmniSciSetLicenseKeyArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_license_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 3))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciSetLicenseKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciSetLicenseKeyResult {
  result_value: Option<TLicenseInfo>,
  e: Option<TOmniSciException>,
}

impl OmniSciSetLicenseKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciSetLicenseKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TLicenseInfo> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TLicenseInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciSetLicenseKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciSetLicenseKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TLicenseInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciSetLicenseKey"
          )
        )
      )
    }
  }
}

//
// OmniSciGetLicenseClaimsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetLicenseClaimsArgs {
  session: TSessionId,
  nonce: String,
}

impl OmniSciGetLicenseClaimsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetLicenseClaimsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetLicenseClaimsArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciGetLicenseClaimsArgs.nonce", &f_2)?;
    let ret = OmniSciGetLicenseClaimsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_license_claims_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 2))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetLicenseClaimsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetLicenseClaimsResult {
  result_value: Option<TLicenseInfo>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetLicenseClaimsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetLicenseClaimsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TLicenseInfo> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TLicenseInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetLicenseClaimsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetLicenseClaimsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TLicenseInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetLicenseClaims"
          )
        )
      )
    }
  }
}

//
// OmniSciGetDeviceParametersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDeviceParametersArgs {
  session: TSessionId,
}

impl OmniSciGetDeviceParametersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDeviceParametersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciGetDeviceParametersArgs.session", &f_1)?;
    let ret = OmniSciGetDeviceParametersArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_device_parameters_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciGetDeviceParametersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciGetDeviceParametersResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TOmniSciException>,
}

impl OmniSciGetDeviceParametersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciGetDeviceParametersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_81 = i_prot.read_string()?;
            let map_val_82 = i_prot.read_string()?;
            val.insert(map_key_81, map_val_82);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciGetDeviceParametersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciGetDeviceParametersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for OmniSciGetDeviceParameters"
          )
        )
      )
    }
  }
}

//
// OmniSciRegisterRuntimeExtensionFunctionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciRegisterRuntimeExtensionFunctionsArgs {
  session: TSessionId,
  udfs: Vec<extension_functions::TUserDefinedFunction>,
  udtfs: Vec<extension_functions::TUserDefinedTableFunction>,
  device_ir_map: BTreeMap<String, String>,
}

impl OmniSciRegisterRuntimeExtensionFunctionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciRegisterRuntimeExtensionFunctionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<extension_functions::TUserDefinedFunction>> = None;
    let mut f_3: Option<Vec<extension_functions::TUserDefinedTableFunction>> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = extension_functions::TUserDefinedFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedTableFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = extension_functions::TUserDefinedTableFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_85 = i_prot.read_string()?;
            let map_val_86 = i_prot.read_string()?;
            val.insert(map_key_85, map_val_86);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OmniSciRegisterRuntimeExtensionFunctionsArgs.session", &f_1)?;
    verify_required_field_exists("OmniSciRegisterRuntimeExtensionFunctionsArgs.udfs", &f_2)?;
    verify_required_field_exists("OmniSciRegisterRuntimeExtensionFunctionsArgs.udtfs", &f_3)?;
    verify_required_field_exists("OmniSciRegisterRuntimeExtensionFunctionsArgs.device_ir_map", &f_4)?;
    let ret = OmniSciRegisterRuntimeExtensionFunctionsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      udfs: f_2.expect("auto-generated code should have checked for presence of required fields"),
      udtfs: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_ir_map: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("register_runtime_extension_functions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udfs", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.udfs.len() as i32))?;
    for e in &self.udfs {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udtfs", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.udtfs.len() as i32))?;
    for e in &self.udtfs {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_ir_map", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.device_ir_map.len() as i32))?;
    for (k, v) in &self.device_ir_map {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OmniSciRegisterRuntimeExtensionFunctionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct OmniSciRegisterRuntimeExtensionFunctionsResult {
  e: Option<TOmniSciException>,
}

impl OmniSciRegisterRuntimeExtensionFunctionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OmniSciRegisterRuntimeExtensionFunctionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TOmniSciException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TOmniSciException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = OmniSciRegisterRuntimeExtensionFunctionsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OmniSciRegisterRuntimeExtensionFunctionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}
