// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(clippy::too_many_arguments, clippy::type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::common;
use crate::completion_hints;
use crate::extension_functions;
use crate::serialized_result_set;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TExecuteMode {
  Gpu = 1,
  Cpu = 2,
}

impl TExecuteMode {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExecuteMode> {
    let enum_value = i_prot.read_i32()?;
    TExecuteMode::try_from(enum_value)  }
}

impl TryFrom<i32> for TExecuteMode {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      1 => Ok(TExecuteMode::Gpu),
      2 => Ok(TExecuteMode::Cpu),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TExecuteMode", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TFileType {
  Delimited = 0,
  Polygon = 1,
  Parquet = 2,
}

impl TFileType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileType> {
    let enum_value = i_prot.read_i32()?;
    TFileType::try_from(enum_value)  }
}

impl TryFrom<i32> for TFileType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TFileType::Delimited),
      1 => Ok(TFileType::Polygon),
      2 => Ok(TFileType::Parquet),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TFileType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TPartitionDetail {
  Default = 0,
  Replicated = 1,
  Sharded = 2,
  Other = 3,
}

impl TPartitionDetail {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionDetail> {
    let enum_value = i_prot.read_i32()?;
    TPartitionDetail::try_from(enum_value)  }
}

impl TryFrom<i32> for TPartitionDetail {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TPartitionDetail::Default),
      1 => Ok(TPartitionDetail::Replicated),
      2 => Ok(TPartitionDetail::Sharded),
      3 => Ok(TPartitionDetail::Other),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TPartitionDetail", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TGeoFileLayerContents {
  Empty = 0,
  Geo = 1,
  NonGeo = 2,
  UnsupportedGeo = 3,
}

impl TGeoFileLayerContents {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGeoFileLayerContents> {
    let enum_value = i_prot.read_i32()?;
    TGeoFileLayerContents::try_from(enum_value)  }
}

impl TryFrom<i32> for TGeoFileLayerContents {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TGeoFileLayerContents::Empty),
      1 => Ok(TGeoFileLayerContents::Geo),
      2 => Ok(TGeoFileLayerContents::NonGeo),
      3 => Ok(TGeoFileLayerContents::UnsupportedGeo),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TGeoFileLayerContents", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TImportHeaderRow {
  Autodetect = 0,
  NoHeader = 1,
  HasHeader = 2,
}

impl TImportHeaderRow {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TImportHeaderRow> {
    let enum_value = i_prot.read_i32()?;
    TImportHeaderRow::try_from(enum_value)  }
}

impl TryFrom<i32> for TImportHeaderRow {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TImportHeaderRow::Autodetect),
      1 => Ok(TImportHeaderRow::NoHeader),
      2 => Ok(TImportHeaderRow::HasHeader),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TImportHeaderRow", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TRole {
  Server = 0,
  Aggregator = 1,
  Leaf = 2,
  StringDictionary = 3,
}

impl TRole {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRole> {
    let enum_value = i_prot.read_i32()?;
    TRole::try_from(enum_value)  }
}

impl TryFrom<i32> for TRole {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TRole::Server),
      1 => Ok(TRole::Aggregator),
      2 => Ok(TRole::Leaf),
      3 => Ok(TRole::StringDictionary),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TRole", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TMergeType {
  Union = 0,
  Reduce = 1,
}

impl TMergeType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMergeType> {
    let enum_value = i_prot.read_i32()?;
    TMergeType::try_from(enum_value)  }
}

impl TryFrom<i32> for TMergeType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TMergeType::Union),
      1 => Ok(TMergeType::Reduce),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TMergeType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TExpressionRangeType {
  Invalid = 0,
  Integer = 1,
  Float = 2,
  Double = 3,
}

impl TExpressionRangeType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExpressionRangeType> {
    let enum_value = i_prot.read_i32()?;
    TExpressionRangeType::try_from(enum_value)  }
}

impl TryFrom<i32> for TExpressionRangeType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TExpressionRangeType::Invalid),
      1 => Ok(TExpressionRangeType::Integer),
      2 => Ok(TExpressionRangeType::Float),
      3 => Ok(TExpressionRangeType::Double),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TExpressionRangeType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDBObjectType {
  AbstractDBObjectType = 0,
  DatabaseDBObjectType = 1,
  TableDBObjectType = 2,
  DashboardDBObjectType = 3,
  ViewDBObjectType = 4,
}

impl TDBObjectType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObjectType> {
    let enum_value = i_prot.read_i32()?;
    TDBObjectType::try_from(enum_value)  }
}

impl TryFrom<i32> for TDBObjectType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TDBObjectType::AbstractDBObjectType),
      1 => Ok(TDBObjectType::DatabaseDBObjectType),
      2 => Ok(TDBObjectType::TableDBObjectType),
      3 => Ok(TDBObjectType::DashboardDBObjectType),
      4 => Ok(TDBObjectType::ViewDBObjectType),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TDBObjectType", i)
            )
          )
        )
      },
    }
  }
}

pub type TRowDescriptor = Vec<TColumnType>;

pub type TTableDescriptor = BTreeMap<String, TColumnType>;

pub type TSessionId = String;

pub type TKrb5Token = String;

pub type TQueryId = i64;

pub type TRenderPassMap = BTreeMap<i32, TRawRenderPassDataResult>;

pub type TRenderAggDataMap = BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>>;

//
// TDatumVal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatumVal {
  pub int_val: Option<i64>,
  pub real_val: Option<OrderedFloat<f64>>,
  pub str_val: Option<String>,
  pub arr_val: Option<Vec<Box<TDatum>>>,
}

impl TDatumVal {
  pub fn new<F1, F2, F3, F4>(int_val: F1, real_val: F2, str_val: F3, arr_val: F4) -> TDatumVal where F1: Into<Option<i64>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<String>>, F4: Into<Option<Vec<Box<TDatum>>>> {
    TDatumVal {
      int_val: int_val.into(),
      real_val: real_val.into(),
      str_val: str_val.into(),
      arr_val: arr_val.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatumVal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<Box<TDatum>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TDatum>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TDatum::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatumVal {
      int_val: f_1,
      real_val: f_2,
      str_val: f_3,
      arr_val: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatumVal");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.int_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_val", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.real_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("real_val", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.str_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_val", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.arr_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("arr_val", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatumVal {
  fn default() -> Self {
    TDatumVal{
      int_val: Some(0),
      real_val: Some(OrderedFloat::from(0.0)),
      str_val: Some("".to_owned()),
      arr_val: Some(Vec::new()),
    }
  }
}

//
// TDatum
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatum {
  pub val: Option<TDatumVal>,
  pub is_null: Option<bool>,
}

impl TDatum {
  pub fn new<F1, F2>(val: F1, is_null: F2) -> TDatum where F1: Into<Option<TDatumVal>>, F2: Into<Option<bool>> {
    TDatum {
      val: val.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatum> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDatumVal> = None;
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatumVal::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatum {
      val: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatum");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.val {
      o_prot.write_field_begin(&TFieldIdentifier::new("val", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatum {
  fn default() -> Self {
    TDatum{
      val: None,
      is_null: Some(false),
    }
  }
}

//
// TStringValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringValue {
  pub str_val: Option<String>,
  pub is_null: Option<bool>,
}

impl TStringValue {
  pub fn new<F1, F2>(str_val: F1, is_null: F2) -> TStringValue where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    TStringValue {
      str_val: str_val.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringValue {
      str_val: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.str_val {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_val", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringValue {
  fn default() -> Self {
    TStringValue{
      str_val: Some("".to_owned()),
      is_null: Some(false),
    }
  }
}

//
// TColumnType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnType {
  pub col_name: Option<String>,
  pub col_type: Option<common::TTypeInfo>,
  pub is_reserved_keyword: Option<bool>,
  pub src_name: Option<String>,
  pub is_system: Option<bool>,
  pub is_physical: Option<bool>,
  pub col_id: Option<i64>,
}

impl TColumnType {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(col_name: F1, col_type: F2, is_reserved_keyword: F3, src_name: F4, is_system: F5, is_physical: F6, col_id: F7) -> TColumnType where F1: Into<Option<String>>, F2: Into<Option<common::TTypeInfo>>, F3: Into<Option<bool>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<i64>> {
    TColumnType {
      col_name: col_name.into(),
      col_type: col_type.into(),
      is_reserved_keyword: is_reserved_keyword.into(),
      src_name: src_name.into(),
      is_system: is_system.into(),
      is_physical: is_physical.into(),
      col_id: col_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<common::TTypeInfo> = None;
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = common::TTypeInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnType {
      col_name: f_1,
      col_type: f_2,
      is_reserved_keyword: f_3,
      src_name: f_4,
      is_system: f_5,
      is_physical: f_6,
      col_id: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.col_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_type", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_reserved_keyword {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_reserved_keyword", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.src_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("src_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_system {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_system", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_physical {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_physical", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.col_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_id", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnType {
  fn default() -> Self {
    TColumnType{
      col_name: Some("".to_owned()),
      col_type: None,
      is_reserved_keyword: Some(false),
      src_name: Some("".to_owned()),
      is_system: Some(false),
      is_physical: Some(false),
      col_id: Some(0),
    }
  }
}

//
// TRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRow {
  pub cols: Option<Vec<TDatum>>,
}

impl TRow {
  pub fn new<F1>(cols: F1) -> TRow where F1: Into<Option<Vec<TDatum>>> {
    TRow {
      cols: cols.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TDatum>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDatum> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = TDatum::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRow {
      cols: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRow");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRow {
  fn default() -> Self {
    TRow{
      cols: Some(Vec::new()),
    }
  }
}

//
// TColumnData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnData {
  pub int_col: Option<Vec<i64>>,
  pub real_col: Option<Vec<OrderedFloat<f64>>>,
  pub str_col: Option<Vec<String>>,
  pub arr_col: Option<Vec<Box<TColumn>>>,
}

impl TColumnData {
  pub fn new<F1, F2, F3, F4>(int_col: F1, real_col: F2, str_col: F3, arr_col: F4) -> TColumnData where F1: Into<Option<Vec<i64>>>, F2: Into<Option<Vec<OrderedFloat<f64>>>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<Vec<Box<TColumn>>>> {
    TColumnData {
      int_col: int_col.into(),
      real_col: real_col.into(),
      str_col: str_col.into(),
      arr_col: arr_col.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = Some(Vec::new());
    let mut f_2: Option<Vec<OrderedFloat<f64>>> = Some(Vec::new());
    let mut f_3: Option<Vec<String>> = Some(Vec::new());
    let mut f_4: Option<Vec<Box<TColumn>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_i64()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<OrderedFloat<f64>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = OrderedFloat::from(i_prot.read_double()?);
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TColumn>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = Box::new(TColumn::read_from_in_protocol(i_prot)?);
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnData {
      int_col: f_1,
      real_col: f_2,
      str_col: f_3,
      arr_col: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.int_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_col", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.real_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("real_col", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_double((*e).into())?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.str_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_col", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.arr_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("arr_col", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnData {
  fn default() -> Self {
    TColumnData{
      int_col: Some(Vec::new()),
      real_col: Some(Vec::new()),
      str_col: Some(Vec::new()),
      arr_col: Some(Vec::new()),
    }
  }
}

//
// TColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumn {
  pub data: Option<TColumnData>,
  pub nulls: Option<Vec<bool>>,
}

impl TColumn {
  pub fn new<F1, F2>(data: F1, nulls: F2) -> TColumn where F1: Into<Option<TColumnData>>, F2: Into<Option<Vec<bool>>> {
    TColumn {
      data: data.into(),
      nulls: nulls.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TColumnData> = None;
    let mut f_2: Option<Vec<bool>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TColumnData::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_bool()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumn {
      data: f_1,
      nulls: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("nulls", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumn {
  fn default() -> Self {
    TColumn{
      data: None,
      nulls: Some(Vec::new()),
    }
  }
}

//
// TStringRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringRow {
  pub cols: Option<Vec<TStringValue>>,
}

impl TStringRow {
  pub fn new<F1>(cols: F1) -> TStringRow where F1: Into<Option<Vec<TStringValue>>> {
    TStringRow {
      cols: cols.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TStringValue>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStringValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = TStringValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStringRow {
      cols: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringRow");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStringRow {
  fn default() -> Self {
    TStringRow{
      cols: Some(Vec::new()),
    }
  }
}

//
// TKrb5Session
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TKrb5Session {
  pub session_id: Option<TSessionId>,
  pub krb_token: Option<TKrb5Token>,
}

impl TKrb5Session {
  pub fn new<F1, F2>(session_id: F1, krb_token: F2) -> TKrb5Session where F1: Into<Option<TSessionId>>, F2: Into<Option<TKrb5Token>> {
    TKrb5Session {
      session_id: session_id.into(),
      krb_token: krb_token.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TKrb5Session> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = Some("".to_owned());
    let mut f_2: Option<TKrb5Token> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TKrb5Session {
      session_id: f_1,
      krb_token: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TKrb5Session");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.krb_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("krbToken", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TKrb5Session {
  fn default() -> Self {
    TKrb5Session{
      session_id: Some("".to_owned()),
      krb_token: Some("".to_owned()),
    }
  }
}

//
// TStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStepResult {
  pub serialized_rows: Option<serialized_result_set::TSerializedRows>,
  pub execution_finished: Option<bool>,
  pub merge_type: Option<TMergeType>,
  pub sharded: Option<bool>,
  pub row_desc: Option<TRowDescriptor>,
  pub node_id: Option<i32>,
}

impl TStepResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(serialized_rows: F1, execution_finished: F2, merge_type: F3, sharded: F4, row_desc: F5, node_id: F6) -> TStepResult where F1: Into<Option<serialized_result_set::TSerializedRows>>, F2: Into<Option<bool>>, F3: Into<Option<TMergeType>>, F4: Into<Option<bool>>, F5: Into<Option<TRowDescriptor>>, F6: Into<Option<i32>> {
    TStepResult {
      serialized_rows: serialized_rows.into(),
      execution_finished: execution_finished.into(),
      merge_type: merge_type.into(),
      sharded: sharded.into(),
      row_desc: row_desc.into(),
      node_id: node_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<serialized_result_set::TSerializedRows> = None;
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<TMergeType> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_6: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = serialized_result_set::TSerializedRows::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TMergeType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStepResult {
      serialized_rows: f_1,
      execution_finished: f_2,
      merge_type: f_3,
      sharded: f_4,
      row_desc: f_5,
      node_id: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.serialized_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_rows", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_finished {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_finished", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.merge_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sharded {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharded", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.node_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TStepResult {
  fn default() -> Self {
    TStepResult{
      serialized_rows: None,
      execution_finished: Some(false),
      merge_type: None,
      sharded: Some(false),
      row_desc: Some(Vec::new()),
      node_id: Some(0),
    }
  }
}

//
// TRowSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRowSet {
  pub row_desc: Option<TRowDescriptor>,
  pub rows: Option<Vec<TRow>>,
  pub columns: Option<Vec<TColumn>>,
  pub is_columnar: Option<bool>,
}

impl TRowSet {
  pub fn new<F1, F2, F3, F4>(row_desc: F1, rows: F2, columns: F3, is_columnar: F4) -> TRowSet where F1: Into<Option<TRowDescriptor>>, F2: Into<Option<Vec<TRow>>>, F3: Into<Option<Vec<TColumn>>>, F4: Into<Option<bool>> {
    TRowSet {
      row_desc: row_desc.into(),
      rows: rows.into(),
      columns: columns.into(),
      is_columnar: is_columnar.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRowSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_2: Option<Vec<TRow>> = Some(Vec::new());
    let mut f_3: Option<Vec<TColumn>> = Some(Vec::new());
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRowSet {
      row_desc: f_1,
      rows: f_2,
      columns: f_3,
      is_columnar: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRowSet");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_columnar {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_columnar", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRowSet {
  fn default() -> Self {
    TRowSet{
      row_desc: Some(Vec::new()),
      rows: Some(Vec::new()),
      columns: Some(Vec::new()),
      is_columnar: Some(false),
    }
  }
}

//
// TQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryResult {
  pub row_set: Option<TRowSet>,
  pub execution_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
  pub nonce: Option<String>,
}

impl TQueryResult {
  pub fn new<F1, F2, F3, F4>(row_set: F1, execution_time_ms: F2, total_time_ms: F3, nonce: F4) -> TQueryResult where F1: Into<Option<TRowSet>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<String>> {
    TQueryResult {
      row_set: row_set.into(),
      execution_time_ms: execution_time_ms.into(),
      total_time_ms: total_time_ms.into(),
      nonce: nonce.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowSet> = None;
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TQueryResult {
      row_set: f_1,
      execution_time_ms: f_2,
      total_time_ms: f_3,
      nonce: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TQueryResult {
  fn default() -> Self {
    TQueryResult{
      row_set: None,
      execution_time_ms: Some(0),
      total_time_ms: Some(0),
      nonce: Some("".to_owned()),
    }
  }
}

//
// TDataFrame
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataFrame {
  pub sm_handle: Option<Vec<u8>>,
  pub sm_size: Option<i64>,
  pub df_handle: Option<Vec<u8>>,
  pub df_size: Option<i64>,
  pub execution_time_ms: Option<i64>,
  pub arrow_conversion_time_ms: Option<i64>,
}

impl TDataFrame {
  pub fn new<F1, F2, F3, F4, F5, F6>(sm_handle: F1, sm_size: F2, df_handle: F3, df_size: F4, execution_time_ms: F5, arrow_conversion_time_ms: F6) -> TDataFrame where F1: Into<Option<Vec<u8>>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<i64>> {
    TDataFrame {
      sm_handle: sm_handle.into(),
      sm_size: sm_size.into(),
      df_handle: df_handle.into(),
      df_size: df_size.into(),
      execution_time_ms: execution_time_ms.into(),
      arrow_conversion_time_ms: arrow_conversion_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataFrame> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDataFrame {
      sm_handle: f_1,
      sm_size: f_2,
      df_handle: f_3,
      df_size: f_4,
      execution_time_ms: f_5,
      arrow_conversion_time_ms: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataFrame");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.sm_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("sm_handle", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sm_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("sm_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.df_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_handle", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.df_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("df_size", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.arrow_conversion_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("arrow_conversion_time_ms", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDataFrame {
  fn default() -> Self {
    TDataFrame{
      sm_handle: Some(Vec::new()),
      sm_size: Some(0),
      df_handle: Some(Vec::new()),
      df_size: Some(0),
      execution_time_ms: Some(0),
      arrow_conversion_time_ms: Some(0),
    }
  }
}

//
// TDBInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBInfo {
  pub db_name: Option<String>,
  pub db_owner: Option<String>,
}

impl TDBInfo {
  pub fn new<F1, F2>(db_name: F1, db_owner: F2) -> TDBInfo where F1: Into<Option<String>>, F2: Into<Option<String>> {
    TDBInfo {
      db_name: db_name.into(),
      db_owner: db_owner.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBInfo {
      db_name: f_1,
      db_owner: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.db_owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_owner", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBInfo {
  fn default() -> Self {
    TDBInfo{
      db_name: Some("".to_owned()),
      db_owner: Some("".to_owned()),
    }
  }
}

//
// TMapDException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMapDException {
  pub error_msg: Option<String>,
}

impl TMapDException {
  pub fn new<F1>(error_msg: F1) -> TMapDException where F1: Into<Option<String>> {
    TMapDException {
      error_msg: error_msg.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMapDException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMapDException {
      error_msg: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMapDException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.error_msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("error_msg", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMapDException {
  fn default() -> Self {
    TMapDException{
      error_msg: Some("".to_owned()),
    }
  }
}

impl Error for TMapDException {
  fn description(&self) -> &str {
    "remote service threw TMapDException"
  }
}

impl From<TMapDException> for thrift::Error {
  fn from(e: TMapDException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TMapDException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// TCopyParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCopyParams {
  pub delimiter: Option<String>,
  pub null_str: Option<String>,
  pub has_header: Option<TImportHeaderRow>,
  pub quoted: Option<bool>,
  pub quote: Option<String>,
  pub escape: Option<String>,
  pub line_delim: Option<String>,
  pub array_delim: Option<String>,
  pub array_begin: Option<String>,
  pub array_end: Option<String>,
  pub threads: Option<i32>,
  pub file_type: Option<TFileType>,
  pub s3_access_key: Option<String>,
  pub s3_secret_key: Option<String>,
  pub s3_region: Option<String>,
  pub geo_coords_encoding: Option<common::TEncodingType>,
  pub geo_coords_comp_param: Option<i32>,
  pub geo_coords_type: Option<common::TDatumType>,
  pub geo_coords_srid: Option<i32>,
  pub sanitize_column_names: Option<bool>,
  pub geo_layer_name: Option<String>,
  pub s3_endpoint: Option<String>,
  pub geo_assign_render_groups: Option<bool>,
  pub geo_explode_collections: Option<bool>,
}

impl TCopyParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24>(delimiter: F1, null_str: F2, has_header: F3, quoted: F4, quote: F5, escape: F6, line_delim: F7, array_delim: F8, array_begin: F9, array_end: F10, threads: F11, file_type: F12, s3_access_key: F13, s3_secret_key: F14, s3_region: F15, geo_coords_encoding: F16, geo_coords_comp_param: F17, geo_coords_type: F18, geo_coords_srid: F19, sanitize_column_names: F20, geo_layer_name: F21, s3_endpoint: F22, geo_assign_render_groups: F23, geo_explode_collections: F24) -> TCopyParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<TImportHeaderRow>>, F4: Into<Option<bool>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<i32>>, F12: Into<Option<TFileType>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<String>>, F16: Into<Option<common::TEncodingType>>, F17: Into<Option<i32>>, F18: Into<Option<common::TDatumType>>, F19: Into<Option<i32>>, F20: Into<Option<bool>>, F21: Into<Option<String>>, F22: Into<Option<String>>, F23: Into<Option<bool>>, F24: Into<Option<bool>> {
    TCopyParams {
      delimiter: delimiter.into(),
      null_str: null_str.into(),
      has_header: has_header.into(),
      quoted: quoted.into(),
      quote: quote.into(),
      escape: escape.into(),
      line_delim: line_delim.into(),
      array_delim: array_delim.into(),
      array_begin: array_begin.into(),
      array_end: array_end.into(),
      threads: threads.into(),
      file_type: file_type.into(),
      s3_access_key: s3_access_key.into(),
      s3_secret_key: s3_secret_key.into(),
      s3_region: s3_region.into(),
      geo_coords_encoding: geo_coords_encoding.into(),
      geo_coords_comp_param: geo_coords_comp_param.into(),
      geo_coords_type: geo_coords_type.into(),
      geo_coords_srid: geo_coords_srid.into(),
      sanitize_column_names: sanitize_column_names.into(),
      geo_layer_name: geo_layer_name.into(),
      s3_endpoint: s3_endpoint.into(),
      geo_assign_render_groups: geo_assign_render_groups.into(),
      geo_explode_collections: geo_explode_collections.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCopyParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<TImportHeaderRow> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<i32> = Some(0);
    let mut f_12: Option<TFileType> = None;
    let mut f_13: Option<String> = Some("".to_owned());
    let mut f_14: Option<String> = Some("".to_owned());
    let mut f_15: Option<String> = Some("".to_owned());
    let mut f_16: Option<common::TEncodingType> = None;
    let mut f_17: Option<i32> = Some(0);
    let mut f_18: Option<common::TDatumType> = None;
    let mut f_19: Option<i32> = Some(0);
    let mut f_20: Option<bool> = Some(false);
    let mut f_21: Option<String> = Some("".to_owned());
    let mut f_22: Option<String> = Some("".to_owned());
    let mut f_23: Option<bool> = Some(false);
    let mut f_24: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TImportHeaderRow::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TFileType::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let val = common::TEncodingType::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = common::TDatumType::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i32()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_bool()?;
          f_24 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCopyParams {
      delimiter: f_1,
      null_str: f_2,
      has_header: f_3,
      quoted: f_4,
      quote: f_5,
      escape: f_6,
      line_delim: f_7,
      array_delim: f_8,
      array_begin: f_9,
      array_end: f_10,
      threads: f_11,
      file_type: f_12,
      s3_access_key: f_13,
      s3_secret_key: f_14,
      s3_region: f_15,
      geo_coords_encoding: f_16,
      geo_coords_comp_param: f_17,
      geo_coords_type: f_18,
      geo_coords_srid: f_19,
      sanitize_column_names: f_20,
      geo_layer_name: f_21,
      s3_endpoint: f_22,
      geo_assign_render_groups: f_23,
      geo_explode_collections: f_24,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCopyParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("delimiter", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.null_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_str", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.has_header {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_header", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.quoted {
      o_prot.write_field_begin(&TFieldIdentifier::new("quoted", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.quote {
      o_prot.write_field_begin(&TFieldIdentifier::new("quote", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.escape {
      o_prot.write_field_begin(&TFieldIdentifier::new("escape", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.line_delim {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delim", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.array_delim {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_delim", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.array_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_begin", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.array_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("array_end", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.threads {
      o_prot.write_field_begin(&TFieldIdentifier::new("threads", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.file_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_access_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_access_key", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_secret_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_secret_key", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_region {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_region", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.geo_coords_encoding {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_encoding", TType::I32, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_coords_comp_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_comp_param", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.geo_coords_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_type", TType::I32, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_coords_srid {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_coords_srid", TType::I32, 19))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sanitize_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("sanitize_column_names", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.geo_layer_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_layer_name", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s3_endpoint {
      o_prot.write_field_begin(&TFieldIdentifier::new("s3_endpoint", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_assign_render_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_assign_render_groups", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.geo_explode_collections {
      o_prot.write_field_begin(&TFieldIdentifier::new("geo_explode_collections", TType::Bool, 24))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCopyParams {
  fn default() -> Self {
    TCopyParams{
      delimiter: Some("".to_owned()),
      null_str: Some("".to_owned()),
      has_header: None,
      quoted: Some(false),
      quote: Some("".to_owned()),
      escape: Some("".to_owned()),
      line_delim: Some("".to_owned()),
      array_delim: Some("".to_owned()),
      array_begin: Some("".to_owned()),
      array_end: Some("".to_owned()),
      threads: Some(0),
      file_type: None,
      s3_access_key: Some("".to_owned()),
      s3_secret_key: Some("".to_owned()),
      s3_region: Some("".to_owned()),
      geo_coords_encoding: None,
      geo_coords_comp_param: Some(0),
      geo_coords_type: None,
      geo_coords_srid: Some(0),
      sanitize_column_names: Some(false),
      geo_layer_name: Some("".to_owned()),
      s3_endpoint: Some("".to_owned()),
      geo_assign_render_groups: Some(false),
      geo_explode_collections: Some(false),
    }
  }
}

//
// TCreateParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCreateParams {
  pub is_replicated: Option<bool>,
}

impl TCreateParams {
  pub fn new<F1>(is_replicated: F1) -> TCreateParams where F1: Into<Option<bool>> {
    TCreateParams {
      is_replicated: is_replicated.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCreateParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TCreateParams {
      is_replicated: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCreateParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_replicated {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_replicated", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TCreateParams {
  fn default() -> Self {
    TCreateParams{
      is_replicated: Some(false),
    }
  }
}

//
// TDetectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDetectResult {
  pub row_set: Option<TRowSet>,
  pub copy_params: Option<TCopyParams>,
}

impl TDetectResult {
  pub fn new<F1, F2>(row_set: F1, copy_params: F2) -> TDetectResult where F1: Into<Option<TRowSet>>, F2: Into<Option<TCopyParams>> {
    TDetectResult {
      row_set: row_set.into(),
      copy_params: copy_params.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDetectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowSet> = None;
    let mut f_2: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDetectResult {
      row_set: f_1,
      copy_params: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDetectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.copy_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDetectResult {
  fn default() -> Self {
    TDetectResult{
      row_set: None,
      copy_params: None,
    }
  }
}

//
// TImportStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TImportStatus {
  pub elapsed: Option<i64>,
  pub rows_completed: Option<i64>,
  pub rows_estimated: Option<i64>,
  pub rows_rejected: Option<i64>,
}

impl TImportStatus {
  pub fn new<F1, F2, F3, F4>(elapsed: F1, rows_completed: F2, rows_estimated: F3, rows_rejected: F4) -> TImportStatus where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    TImportStatus {
      elapsed: elapsed.into(),
      rows_completed: rows_completed.into(),
      rows_estimated: rows_estimated.into(),
      rows_rejected: rows_rejected.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TImportStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TImportStatus {
      elapsed: f_1,
      rows_completed: f_2,
      rows_estimated: f_3,
      rows_rejected: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TImportStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.elapsed {
      o_prot.write_field_begin(&TFieldIdentifier::new("elapsed", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rows_completed {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_completed", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rows_estimated {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_estimated", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rows_rejected {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_rejected", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TImportStatus {
  fn default() -> Self {
    TImportStatus{
      elapsed: Some(0),
      rows_completed: Some(0),
      rows_estimated: Some(0),
      rows_rejected: Some(0),
    }
  }
}

//
// TFrontendView
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFrontendView {
  pub view_name: Option<String>,
  pub view_state: Option<String>,
  pub image_hash: Option<String>,
  pub update_time: Option<String>,
  pub view_metadata: Option<String>,
}

impl TFrontendView {
  pub fn new<F1, F2, F3, F4, F5>(view_name: F1, view_state: F2, image_hash: F3, update_time: F4, view_metadata: F5) -> TFrontendView where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    TFrontendView {
      view_name: view_name.into(),
      view_state: view_state.into(),
      image_hash: image_hash.into(),
      update_time: update_time.into(),
      view_metadata: view_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFrontendView> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFrontendView {
      view_name: f_1,
      view_state: f_2,
      image_hash: f_3,
      update_time: f_4,
      view_metadata: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFrontendView");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.view_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.view_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_state", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.image_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_time", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.view_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_metadata", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TFrontendView {
  fn default() -> Self {
    TFrontendView{
      view_name: Some("".to_owned()),
      view_state: Some("".to_owned()),
      image_hash: Some("".to_owned()),
      update_time: Some("".to_owned()),
      view_metadata: Some("".to_owned()),
    }
  }
}

//
// TDashboard
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboard {
  pub dashboard_name: Option<String>,
  pub dashboard_state: Option<String>,
  pub image_hash: Option<String>,
  pub update_time: Option<String>,
  pub dashboard_metadata: Option<String>,
  pub dashboard_id: Option<i32>,
  pub dashboard_owner: Option<String>,
  pub is_dash_shared: Option<bool>,
}

impl TDashboard {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(dashboard_name: F1, dashboard_state: F2, image_hash: F3, update_time: F4, dashboard_metadata: F5, dashboard_id: F6, dashboard_owner: F7, is_dash_shared: F8) -> TDashboard where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<String>>, F8: Into<Option<bool>> {
    TDashboard {
      dashboard_name: dashboard_name.into(),
      dashboard_state: dashboard_state.into(),
      image_hash: image_hash.into(),
      update_time: update_time.into(),
      dashboard_metadata: dashboard_metadata.into(),
      dashboard_id: dashboard_id.into(),
      dashboard_owner: dashboard_owner.into(),
      is_dash_shared: is_dash_shared.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboard> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboard {
      dashboard_name: f_1,
      dashboard_state: f_2,
      image_hash: f_3,
      update_time: f_4,
      dashboard_metadata: f_5,
      dashboard_id: f_6,
      dashboard_owner: f_7,
      is_dash_shared: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboard");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dashboard_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dashboard_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.image_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_time", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dashboard_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.dashboard_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dashboard_owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_owner", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_dash_shared {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_dash_shared", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboard {
  fn default() -> Self {
    TDashboard{
      dashboard_name: Some("".to_owned()),
      dashboard_state: Some("".to_owned()),
      image_hash: Some("".to_owned()),
      update_time: Some("".to_owned()),
      dashboard_metadata: Some("".to_owned()),
      dashboard_id: Some(0),
      dashboard_owner: Some("".to_owned()),
      is_dash_shared: Some(false),
    }
  }
}

//
// TServerStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TServerStatus {
  pub read_only: Option<bool>,
  pub version: Option<String>,
  pub rendering_enabled: Option<bool>,
  pub start_time: Option<i64>,
  pub edition: Option<String>,
  pub host_name: Option<String>,
  pub poly_rendering_enabled: Option<bool>,
  pub role: Option<TRole>,
}

impl TServerStatus {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(read_only: F1, version: F2, rendering_enabled: F3, start_time: F4, edition: F5, host_name: F6, poly_rendering_enabled: F7, role: F8) -> TServerStatus where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<bool>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<TRole>> {
    TServerStatus {
      read_only: read_only.into(),
      version: version.into(),
      rendering_enabled: rendering_enabled.into(),
      start_time: start_time.into(),
      edition: edition.into(),
      host_name: host_name.into(),
      poly_rendering_enabled: poly_rendering_enabled.into(),
      role: role.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TServerStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<TRole> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = TRole::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TServerStatus {
      read_only: f_1,
      version: f_2,
      rendering_enabled: f_3,
      start_time: f_4,
      edition: f_5,
      host_name: f_6,
      poly_rendering_enabled: f_7,
      role: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TServerStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_only", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rendering_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("rendering_enabled", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_time", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.edition {
      o_prot.write_field_begin(&TFieldIdentifier::new("edition", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.poly_rendering_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("poly_rendering_enabled", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.role {
      o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TServerStatus {
  fn default() -> Self {
    TServerStatus{
      read_only: Some(false),
      version: Some("".to_owned()),
      rendering_enabled: Some(false),
      start_time: Some(0),
      edition: Some("".to_owned()),
      host_name: Some("".to_owned()),
      poly_rendering_enabled: Some(false),
      role: None,
    }
  }
}

//
// TPixel
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPixel {
  pub x: Option<i64>,
  pub y: Option<i64>,
}

impl TPixel {
  pub fn new<F1, F2>(x: F1, y: F2) -> TPixel where F1: Into<Option<i64>>, F2: Into<Option<i64>> {
    TPixel {
      x: x.into(),
      y: y.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPixel> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPixel {
      x: f_1,
      y: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPixel");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.x {
      o_prot.write_field_begin(&TFieldIdentifier::new("x", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.y {
      o_prot.write_field_begin(&TFieldIdentifier::new("y", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPixel {
  fn default() -> Self {
    TPixel{
      x: Some(0),
      y: Some(0),
    }
  }
}

//
// TPixelTableRowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPixelTableRowResult {
  pub pixel: Option<TPixel>,
  pub vega_table_name: Option<String>,
  pub table_id: Option<Vec<i64>>,
  pub row_id: Option<Vec<i64>>,
  pub row_set: Option<TRowSet>,
  pub nonce: Option<String>,
}

impl TPixelTableRowResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(pixel: F1, vega_table_name: F2, table_id: F3, row_id: F4, row_set: F5, nonce: F6) -> TPixelTableRowResult where F1: Into<Option<TPixel>>, F2: Into<Option<String>>, F3: Into<Option<Vec<i64>>>, F4: Into<Option<Vec<i64>>>, F5: Into<Option<TRowSet>>, F6: Into<Option<String>> {
    TPixelTableRowResult {
      pixel: pixel.into(),
      vega_table_name: vega_table_name.into(),
      table_id: table_id.into(),
      row_id: row_id.into(),
      row_set: row_set.into(),
      nonce: nonce.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPixelTableRowResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPixel> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Vec<i64>> = Some(Vec::new());
    let mut f_4: Option<Vec<i64>> = Some(Vec::new());
    let mut f_5: Option<TRowSet> = None;
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPixel::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_i64()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = i_prot.read_i64()?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TRowSet::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPixelTableRowResult {
      pixel: f_1,
      vega_table_name: f_2,
      table_id: f_3,
      row_id: f_4,
      row_set: f_5,
      nonce: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPixelTableRowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pixel {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixel", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.vega_table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("vega_table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_id", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_set", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPixelTableRowResult {
  fn default() -> Self {
    TPixelTableRowResult{
      pixel: None,
      vega_table_name: Some("".to_owned()),
      table_id: Some(Vec::new()),
      row_id: Some(Vec::new()),
      row_set: None,
      nonce: Some("".to_owned()),
    }
  }
}

//
// TRenderResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderResult {
  pub image: Option<Vec<u8>>,
  pub nonce: Option<String>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
  pub vega_metadata: Option<String>,
}

impl TRenderResult {
  pub fn new<F1, F2, F3, F4, F5, F6>(image: F1, nonce: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5, vega_metadata: F6) -> TRenderResult where F1: Into<Option<Vec<u8>>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<String>> {
    TRenderResult {
      image: image.into(),
      nonce: nonce.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
      vega_metadata: vega_metadata.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderResult {
      image: f_1,
      nonce: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
      vega_metadata: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.image {
      o_prot.write_field_begin(&TFieldIdentifier::new("image", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nonce {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.vega_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("vega_metadata", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderResult {
  fn default() -> Self {
    TRenderResult{
      image: Some(Vec::new()),
      nonce: Some("".to_owned()),
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
      vega_metadata: Some("".to_owned()),
    }
  }
}

//
// TGpuSpecification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGpuSpecification {
  pub num_sm: Option<i32>,
  pub clock_frequency_k_hz: Option<i64>,
  pub memory: Option<i64>,
  pub compute_capability_major: Option<i16>,
  pub compute_capability_minor: Option<i16>,
}

impl TGpuSpecification {
  pub fn new<F1, F2, F3, F4, F5>(num_sm: F1, clock_frequency_k_hz: F2, memory: F3, compute_capability_major: F4, compute_capability_minor: F5) -> TGpuSpecification where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i16>>, F5: Into<Option<i16>> {
    TGpuSpecification {
      num_sm: num_sm.into(),
      clock_frequency_k_hz: clock_frequency_k_hz.into(),
      memory: memory.into(),
      compute_capability_major: compute_capability_major.into(),
      compute_capability_minor: compute_capability_minor.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGpuSpecification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i16> = Some(0);
    let mut f_5: Option<i16> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i16()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGpuSpecification {
      num_sm: f_1,
      clock_frequency_k_hz: f_2,
      memory: f_3,
      compute_capability_major: f_4,
      compute_capability_minor: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGpuSpecification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_sm {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_sm", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.clock_frequency_k_hz {
      o_prot.write_field_begin(&TFieldIdentifier::new("clock_frequency_kHz", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.memory {
      o_prot.write_field_begin(&TFieldIdentifier::new("memory", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.compute_capability_major {
      o_prot.write_field_begin(&TFieldIdentifier::new("compute_capability_major", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.compute_capability_minor {
      o_prot.write_field_begin(&TFieldIdentifier::new("compute_capability_minor", TType::I16, 5))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TGpuSpecification {
  fn default() -> Self {
    TGpuSpecification{
      num_sm: Some(0),
      clock_frequency_k_hz: Some(0),
      memory: Some(0),
      compute_capability_major: Some(0),
      compute_capability_minor: Some(0),
    }
  }
}

//
// THardwareInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THardwareInfo {
  pub num_gpu_hw: Option<i16>,
  pub num_cpu_hw: Option<i16>,
  pub num_gpu_allocated: Option<i16>,
  pub start_gpu: Option<i16>,
  pub host_name: Option<String>,
  pub gpu_info: Option<Vec<TGpuSpecification>>,
}

impl THardwareInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(num_gpu_hw: F1, num_cpu_hw: F2, num_gpu_allocated: F3, start_gpu: F4, host_name: F5, gpu_info: F6) -> THardwareInfo where F1: Into<Option<i16>>, F2: Into<Option<i16>>, F3: Into<Option<i16>>, F4: Into<Option<i16>>, F5: Into<Option<String>>, F6: Into<Option<Vec<TGpuSpecification>>> {
    THardwareInfo {
      num_gpu_hw: num_gpu_hw.into(),
      num_cpu_hw: num_cpu_hw.into(),
      num_gpu_allocated: num_gpu_allocated.into(),
      start_gpu: start_gpu.into(),
      host_name: host_name.into(),
      gpu_info: gpu_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THardwareInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i16> = Some(0);
    let mut f_2: Option<i16> = Some(0);
    let mut f_3: Option<i16> = Some(0);
    let mut f_4: Option<i16> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<Vec<TGpuSpecification>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i16()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TGpuSpecification> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = TGpuSpecification::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THardwareInfo {
      num_gpu_hw: f_1,
      num_cpu_hw: f_2,
      num_gpu_allocated: f_3,
      start_gpu: f_4,
      host_name: f_5,
      gpu_info: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THardwareInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_gpu_hw {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_gpu_hw", TType::I16, 1))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_cpu_hw {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_cpu_hw", TType::I16, 2))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_gpu_allocated {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_gpu_allocated", TType::I16, 3))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_gpu {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_gpu", TType::I16, 4))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.gpu_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("gpu_info", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for THardwareInfo {
  fn default() -> Self {
    THardwareInfo{
      num_gpu_hw: Some(0),
      num_cpu_hw: Some(0),
      num_gpu_allocated: Some(0),
      start_gpu: Some(0),
      host_name: Some("".to_owned()),
      gpu_info: Some(Vec::new()),
    }
  }
}

//
// TClusterHardwareInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TClusterHardwareInfo {
  pub hardware_info: Option<Vec<THardwareInfo>>,
}

impl TClusterHardwareInfo {
  pub fn new<F1>(hardware_info: F1) -> TClusterHardwareInfo where F1: Into<Option<Vec<THardwareInfo>>> {
    TClusterHardwareInfo {
      hardware_info: hardware_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TClusterHardwareInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<THardwareInfo>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<THardwareInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = THardwareInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TClusterHardwareInfo {
      hardware_info: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TClusterHardwareInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hardware_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("hardware_info", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TClusterHardwareInfo {
  fn default() -> Self {
    TClusterHardwareInfo{
      hardware_info: Some(Vec::new()),
    }
  }
}

//
// TMemoryData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMemoryData {
  pub slab: Option<i64>,
  pub start_page: Option<i32>,
  pub num_pages: Option<i64>,
  pub touch: Option<i32>,
  pub chunk_key: Option<Vec<i64>>,
  pub buffer_epoch: Option<i32>,
  pub is_free: Option<bool>,
}

impl TMemoryData {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(slab: F1, start_page: F2, num_pages: F3, touch: F4, chunk_key: F5, buffer_epoch: F6, is_free: F7) -> TMemoryData where F1: Into<Option<i64>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<i32>>, F5: Into<Option<Vec<i64>>>, F6: Into<Option<i32>>, F7: Into<Option<bool>> {
    TMemoryData {
      slab: slab.into(),
      start_page: start_page.into(),
      num_pages: num_pages.into(),
      touch: touch.into(),
      chunk_key: chunk_key.into(),
      buffer_epoch: buffer_epoch.into(),
      is_free: is_free.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMemoryData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<Vec<i64>> = Some(Vec::new());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_i64()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMemoryData {
      slab: f_1,
      start_page: f_2,
      num_pages: f_3,
      touch: f_4,
      chunk_key: f_5,
      buffer_epoch: f_6,
      is_free: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMemoryData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.slab {
      o_prot.write_field_begin(&TFieldIdentifier::new("slab", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_page {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_page", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_pages {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pages", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.touch {
      o_prot.write_field_begin(&TFieldIdentifier::new("touch", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.chunk_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("chunk_key", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.buffer_epoch {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffer_epoch", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_free {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_free", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TMemoryData {
  fn default() -> Self {
    TMemoryData{
      slab: Some(0),
      start_page: Some(0),
      num_pages: Some(0),
      touch: Some(0),
      chunk_key: Some(Vec::new()),
      buffer_epoch: Some(0),
      is_free: Some(false),
    }
  }
}

//
// TNodeMemoryInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeMemoryInfo {
  pub host_name: Option<String>,
  pub page_size: Option<i64>,
  pub max_num_pages: Option<i64>,
  pub num_pages_allocated: Option<i64>,
  pub is_allocation_capped: Option<bool>,
  pub node_memory_data: Option<Vec<TMemoryData>>,
}

impl TNodeMemoryInfo {
  pub fn new<F1, F2, F3, F4, F5, F6>(host_name: F1, page_size: F2, max_num_pages: F3, num_pages_allocated: F4, is_allocation_capped: F5, node_memory_data: F6) -> TNodeMemoryInfo where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<bool>>, F6: Into<Option<Vec<TMemoryData>>> {
    TNodeMemoryInfo {
      host_name: host_name.into(),
      page_size: page_size.into(),
      max_num_pages: max_num_pages.into(),
      num_pages_allocated: num_pages_allocated.into(),
      is_allocation_capped: is_allocation_capped.into(),
      node_memory_data: node_memory_data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeMemoryInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<Vec<TMemoryData>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TMemoryData> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = TMemoryData::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TNodeMemoryInfo {
      host_name: f_1,
      page_size: f_2,
      max_num_pages: f_3,
      num_pages_allocated: f_4,
      is_allocation_capped: f_5,
      node_memory_data: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeMemoryInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("host_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("page_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_num_pages {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_num_pages", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_pages_allocated {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pages_allocated", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_allocation_capped {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_allocation_capped", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.node_memory_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_memory_data", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TNodeMemoryInfo {
  fn default() -> Self {
    TNodeMemoryInfo{
      host_name: Some("".to_owned()),
      page_size: Some(0),
      max_num_pages: Some(0),
      num_pages_allocated: Some(0),
      is_allocation_capped: Some(false),
      node_memory_data: Some(Vec::new()),
    }
  }
}

//
// TTableMeta
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableMeta {
  pub table_name: Option<String>,
  pub num_cols: Option<i64>,
  pub is_view: Option<bool>,
  pub is_replicated: Option<bool>,
  pub shard_count: Option<i64>,
  pub max_rows: Option<i64>,
  pub table_id: Option<i64>,
  pub max_table_id: Option<i64>,
  pub col_types: Option<Vec<common::TTypeInfo>>,
  pub col_names: Option<Vec<String>>,
}

impl TTableMeta {
  pub fn new<F1, F2, F4, F5, F6, F7, F8, F9, F10, F11>(table_name: F1, num_cols: F2, is_view: F4, is_replicated: F5, shard_count: F6, max_rows: F7, table_id: F8, max_table_id: F9, col_types: F10, col_names: F11) -> TTableMeta where F1: Into<Option<String>>, F2: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<i64>>, F10: Into<Option<Vec<common::TTypeInfo>>>, F11: Into<Option<Vec<String>>> {
    TTableMeta {
      table_name: table_name.into(),
      num_cols: num_cols.into(),
      is_view: is_view.into(),
      is_replicated: is_replicated.into(),
      shard_count: shard_count.into(),
      max_rows: max_rows.into(),
      table_id: table_id.into(),
      max_table_id: max_table_id.into(),
      col_types: col_types.into(),
      col_names: col_names.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableMeta> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<i64> = Some(0);
    let mut f_9: Option<i64> = Some(0);
    let mut f_10: Option<Vec<common::TTypeInfo>> = Some(Vec::new());
    let mut f_11: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common::TTypeInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = common::TTypeInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableMeta {
      table_name: f_1,
      num_cols: f_2,
      is_view: f_4,
      is_replicated: f_5,
      shard_count: f_6,
      max_rows: f_7,
      table_id: f_8,
      max_table_id: f_9,
      col_types: f_10,
      col_names: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableMeta");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_cols", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_view {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_view", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_replicated {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_replicated", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("shard_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_rows", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_table_id", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_types", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_names", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableMeta {
  fn default() -> Self {
    TTableMeta{
      table_name: Some("".to_owned()),
      num_cols: Some(0),
      is_view: Some(false),
      is_replicated: Some(false),
      shard_count: Some(0),
      max_rows: Some(0),
      table_id: Some(0),
      max_table_id: Some(0),
      col_types: Some(Vec::new()),
      col_names: Some(Vec::new()),
    }
  }
}

//
// TTableDetails
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableDetails {
  pub row_desc: Option<TRowDescriptor>,
  pub fragment_size: Option<i64>,
  pub page_size: Option<i64>,
  pub max_rows: Option<i64>,
  pub view_sql: Option<String>,
  pub shard_count: Option<i64>,
  pub key_metainfo: Option<String>,
  pub is_temporary: Option<bool>,
  pub partition_detail: Option<TPartitionDetail>,
}

impl TTableDetails {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(row_desc: F1, fragment_size: F2, page_size: F3, max_rows: F4, view_sql: F5, shard_count: F6, key_metainfo: F7, is_temporary: F8, partition_detail: F9) -> TTableDetails where F1: Into<Option<TRowDescriptor>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<String>>, F6: Into<Option<i64>>, F7: Into<Option<String>>, F8: Into<Option<bool>>, F9: Into<Option<TPartitionDetail>> {
    TTableDetails {
      row_desc: row_desc.into(),
      fragment_size: fragment_size.into(),
      page_size: page_size.into(),
      max_rows: max_rows.into(),
      view_sql: view_sql.into(),
      shard_count: shard_count.into(),
      key_metainfo: key_metainfo.into(),
      is_temporary: is_temporary.into(),
      partition_detail: partition_detail.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableDetails> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRowDescriptor> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<TPartitionDetail> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TPartitionDetail::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableDetails {
      row_desc: f_1,
      fragment_size: f_2,
      page_size: f_3,
      max_rows: f_4,
      view_sql: f_5,
      shard_count: f_6,
      key_metainfo: f_7,
      is_temporary: f_8,
      partition_detail: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableDetails");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.row_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fragment_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_size", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("page_size", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_rows", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.view_sql {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_sql", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("shard_count", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key_metainfo {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_metainfo", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_temporary {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_temporary", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.partition_detail {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_detail", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableDetails {
  fn default() -> Self {
    TTableDetails{
      row_desc: Some(Vec::new()),
      fragment_size: Some(0),
      page_size: Some(0),
      max_rows: Some(0),
      view_sql: Some("".to_owned()),
      shard_count: Some(0),
      key_metainfo: Some("".to_owned()),
      is_temporary: Some(false),
      partition_detail: None,
    }
  }
}

//
// TColumnRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnRange {
  pub type_: Option<TExpressionRangeType>,
  pub col_id: Option<i32>,
  pub table_id: Option<i32>,
  pub has_nulls: Option<bool>,
  pub int_min: Option<i64>,
  pub int_max: Option<i64>,
  pub bucket: Option<i64>,
  pub fp_min: Option<OrderedFloat<f64>>,
  pub fp_max: Option<OrderedFloat<f64>>,
}

impl TColumnRange {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(type_: F1, col_id: F2, table_id: F3, has_nulls: F4, int_min: F5, int_max: F6, bucket: F7, fp_min: F8, fp_max: F9) -> TColumnRange where F1: Into<Option<TExpressionRangeType>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<bool>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<OrderedFloat<f64>>>, F9: Into<Option<OrderedFloat<f64>>> {
    TColumnRange {
      type_: type_.into(),
      col_id: col_id.into(),
      table_id: table_id.into(),
      has_nulls: has_nulls.into(),
      int_min: int_min.into(),
      int_max: int_max.into(),
      bucket: bucket.into(),
      fp_min: fp_min.into(),
      fp_max: fp_max.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TExpressionRangeType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<i64> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    let mut f_7: Option<i64> = Some(0);
    let mut f_8: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_9: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TExpressionRangeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_8 = Some(val);
        },
        9 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnRange {
      type_: f_1,
      col_id: f_2,
      table_id: f_3,
      has_nulls: f_4,
      int_min: f_5,
      int_max: f_6,
      bucket: f_7,
      fp_min: f_8,
      fp_max: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.col_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_nulls", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.int_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_min", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.int_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_max", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.bucket {
      o_prot.write_field_begin(&TFieldIdentifier::new("bucket", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fp_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("fp_min", TType::Double, 8))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.fp_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("fp_max", TType::Double, 9))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TColumnRange {
  fn default() -> Self {
    TColumnRange{
      type_: None,
      col_id: Some(0),
      table_id: Some(0),
      has_nulls: Some(false),
      int_min: Some(0),
      int_max: Some(0),
      bucket: Some(0),
      fp_min: Some(OrderedFloat::from(0.0)),
      fp_max: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// TDictionaryGeneration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDictionaryGeneration {
  pub dict_id: Option<i32>,
  pub entry_count: Option<i64>,
}

impl TDictionaryGeneration {
  pub fn new<F1, F2>(dict_id: F1, entry_count: F2) -> TDictionaryGeneration where F1: Into<Option<i32>>, F2: Into<Option<i64>> {
    TDictionaryGeneration {
      dict_id: dict_id.into(),
      entry_count: entry_count.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDictionaryGeneration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDictionaryGeneration {
      dict_id: f_1,
      entry_count: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDictionaryGeneration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.dict_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dict_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.entry_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("entry_count", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDictionaryGeneration {
  fn default() -> Self {
    TDictionaryGeneration{
      dict_id: Some(0),
      entry_count: Some(0),
    }
  }
}

//
// TTableGeneration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableGeneration {
  pub table_id: Option<i32>,
  pub tuple_count: Option<i64>,
  pub start_rowid: Option<i64>,
}

impl TTableGeneration {
  pub fn new<F1, F2, F3>(table_id: F1, tuple_count: F2, start_rowid: F3) -> TTableGeneration where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TTableGeneration {
      table_id: table_id.into(),
      tuple_count: tuple_count.into(),
      start_rowid: start_rowid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableGeneration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableGeneration {
      table_id: f_1,
      tuple_count: f_2,
      start_rowid: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableGeneration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.tuple_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_count", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_rowid {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_rowid", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTableGeneration {
  fn default() -> Self {
    TTableGeneration{
      table_id: Some(0),
      tuple_count: Some(0),
      start_rowid: Some(0),
    }
  }
}

//
// TPendingQuery
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPendingQuery {
  pub id: Option<TQueryId>,
  pub column_ranges: Option<Vec<TColumnRange>>,
  pub dictionary_generations: Option<Vec<TDictionaryGeneration>>,
  pub table_generations: Option<Vec<TTableGeneration>>,
}

impl TPendingQuery {
  pub fn new<F1, F2, F3, F4>(id: F1, column_ranges: F2, dictionary_generations: F3, table_generations: F4) -> TPendingQuery where F1: Into<Option<TQueryId>>, F2: Into<Option<Vec<TColumnRange>>>, F3: Into<Option<Vec<TDictionaryGeneration>>>, F4: Into<Option<Vec<TTableGeneration>>> {
    TPendingQuery {
      id: id.into(),
      column_ranges: column_ranges.into(),
      dictionary_generations: dictionary_generations.into(),
      table_generations: table_generations.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPendingQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TQueryId> = Some(0);
    let mut f_2: Option<Vec<TColumnRange>> = Some(Vec::new());
    let mut f_3: Option<Vec<TDictionaryGeneration>> = Some(Vec::new());
    let mut f_4: Option<Vec<TTableGeneration>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnRange> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = TColumnRange::read_from_in_protocol(i_prot)?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDictionaryGeneration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = TDictionaryGeneration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableGeneration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = TTableGeneration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPendingQuery {
      id: f_1,
      column_ranges: f_2,
      dictionary_generations: f_3,
      table_generations: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPendingQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.column_ranges {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ranges", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.dictionary_generations {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionary_generations", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.table_generations {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_generations", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPendingQuery {
  fn default() -> Self {
    TPendingQuery{
      id: Some(0),
      column_ranges: Some(Vec::new()),
      dictionary_generations: Some(Vec::new()),
      table_generations: Some(Vec::new()),
    }
  }
}

//
// TVarLen
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TVarLen {
  pub payload: Option<Vec<u8>>,
  pub is_null: Option<bool>,
}

impl TVarLen {
  pub fn new<F1, F2>(payload: F1, is_null: F2) -> TVarLen where F1: Into<Option<Vec<u8>>>, F2: Into<Option<bool>> {
    TVarLen {
      payload: payload.into(),
      is_null: is_null.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TVarLen> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TVarLen {
      payload: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TVarLen");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.payload {
      o_prot.write_field_begin(&TFieldIdentifier::new("payload", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TVarLen {
  fn default() -> Self {
    TVarLen{
      payload: Some(Vec::new()),
      is_null: Some(false),
    }
  }
}

//
// TDataBlockPtr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDataBlockPtr {
  FixedLenData(Vec<u8>),
  VarLenData(Vec<TVarLen>),
}

impl TDataBlockPtr {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataBlockPtr> {
    let mut ret: Option<TDataBlockPtr> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(TDataBlockPtr::FixedLenData(val));
          }
          received_field_count += 1;
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TVarLen> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = TVarLen::read_from_in_protocol(i_prot)?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          if ret.is_none() {
            ret = Some(TDataBlockPtr::VarLenData(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TDataBlockPtr"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TDataBlockPtr"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataBlockPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TDataBlockPtr::FixedLenData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("fixed_len_data", TType::String, 1))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      TDataBlockPtr::VarLenData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("var_len_data", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, f.len() as i32))?;
        for e in f {
          e.write_to_out_protocol(o_prot)?;
          o_prot.write_list_end()?;
        }
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TInsertData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInsertData {
  pub db_id: Option<i32>,
  pub table_id: Option<i32>,
  pub column_ids: Option<Vec<i32>>,
  pub data: Option<Vec<TDataBlockPtr>>,
  pub num_rows: Option<i64>,
}

impl TInsertData {
  pub fn new<F1, F2, F3, F4, F5>(db_id: F1, table_id: F2, column_ids: F3, data: F4, num_rows: F5) -> TInsertData where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<i32>>>, F4: Into<Option<Vec<TDataBlockPtr>>>, F5: Into<Option<i64>> {
    TInsertData {
      db_id: db_id.into(),
      table_id: table_id.into(),
      column_ids: column_ids.into(),
      data: data.into(),
      num_rows: num_rows.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInsertData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<i32>> = Some(Vec::new());
    let mut f_4: Option<Vec<TDataBlockPtr>> = Some(Vec::new());
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_i32()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDataBlockPtr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = TDataBlockPtr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TInsertData {
      db_id: f_1,
      table_id: f_2,
      column_ids: f_3,
      data: f_4,
      num_rows: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TInsertData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.column_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ids", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_rows", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TInsertData {
  fn default() -> Self {
    TInsertData{
      db_id: Some(0),
      table_id: Some(0),
      column_ids: Some(Vec::new()),
      data: Some(Vec::new()),
      num_rows: Some(0),
    }
  }
}

//
// TPendingRenderQuery
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPendingRenderQuery {
  pub id: Option<TQueryId>,
}

impl TPendingRenderQuery {
  pub fn new<F1>(id: F1) -> TPendingRenderQuery where F1: Into<Option<TQueryId>> {
    TPendingRenderQuery {
      id: id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPendingRenderQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TQueryId> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPendingRenderQuery {
      id: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPendingRenderQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TPendingRenderQuery {
  fn default() -> Self {
    TPendingRenderQuery{
      id: Some(0),
    }
  }
}

//
// TRenderParseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderParseResult {
  pub merge_type: Option<TMergeType>,
  pub node_id: Option<i32>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
}

impl TRenderParseResult {
  pub fn new<F1, F2, F3, F4, F5>(merge_type: F1, node_id: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5) -> TRenderParseResult where F1: Into<Option<TMergeType>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    TRenderParseResult {
      merge_type: merge_type.into(),
      node_id: node_id.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderParseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMergeType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMergeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderParseResult {
      merge_type: f_1,
      node_id: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderParseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.merge_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.node_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderParseResult {
  fn default() -> Self {
    TRenderParseResult{
      merge_type: None,
      node_id: Some(0),
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
    }
  }
}

//
// TRawRenderPassDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRawRenderPassDataResult {
  pub num_pixel_channels: Option<i32>,
  pub num_pixel_samples: Option<i32>,
  pub pixels: Option<Vec<u8>>,
  pub row_ids_a: Option<Vec<u8>>,
  pub row_ids_b: Option<Vec<u8>>,
  pub table_ids: Option<Vec<u8>>,
  pub accum_data: Option<Vec<u8>>,
}

impl TRawRenderPassDataResult {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(num_pixel_channels: F1, num_pixel_samples: F2, pixels: F3, row_ids_a: F4, row_ids_b: F5, table_ids: F6, accum_data: F7) -> TRawRenderPassDataResult where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<Vec<u8>>>, F7: Into<Option<Vec<u8>>> {
    TRawRenderPassDataResult {
      num_pixel_channels: num_pixel_channels.into(),
      num_pixel_samples: num_pixel_samples.into(),
      pixels: pixels.into(),
      row_ids_a: row_ids_a.into(),
      row_ids_b: row_ids_b.into(),
      table_ids: table_ids.into(),
      accum_data: accum_data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRawRenderPassDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<Vec<u8>> = Some(Vec::new());
    let mut f_7: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bytes()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRawRenderPassDataResult {
      num_pixel_channels: f_1,
      num_pixel_samples: f_2,
      pixels: f_3,
      row_ids_a: f_4,
      row_ids_b: f_5,
      table_ids: f_6,
      accum_data: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRawRenderPassDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_pixel_channels {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pixel_channels", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.num_pixel_samples {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_pixel_samples", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pixels {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixels", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_ids_a {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_ids_A", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.row_ids_b {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_ids_B", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.table_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_ids", TType::String, 6))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.accum_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("accum_data", TType::String, 7))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRawRenderPassDataResult {
  fn default() -> Self {
    TRawRenderPassDataResult{
      num_pixel_channels: Some(0),
      num_pixel_samples: Some(0),
      pixels: Some(Vec::new()),
      row_ids_a: Some(Vec::new()),
      row_ids_b: Some(Vec::new()),
      table_ids: Some(Vec::new()),
      accum_data: Some(Vec::new()),
    }
  }
}

//
// TRawPixelData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRawPixelData {
  pub width: Option<i32>,
  pub height: Option<i32>,
  pub render_pass_map: Option<TRenderPassMap>,
}

impl TRawPixelData {
  pub fn new<F1, F2, F3>(width: F1, height: F2, render_pass_map: F3) -> TRawPixelData where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<TRenderPassMap>> {
    TRawPixelData {
      width: width.into(),
      height: height.into(),
      render_pass_map: render_pass_map.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRawPixelData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<TRenderPassMap> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, TRawRenderPassDataResult> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_27 = i_prot.read_i32()?;
            let map_val_28 = TRawRenderPassDataResult::read_from_in_protocol(i_prot)?;
            val.insert(map_key_27, map_val_28);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRawPixelData {
      width: f_1,
      height: f_2,
      render_pass_map: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRawPixelData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.width {
      o_prot.write_field_begin(&TFieldIdentifier::new("width", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.height {
      o_prot.write_field_begin(&TFieldIdentifier::new("height", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.render_pass_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_pass_map", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRawPixelData {
  fn default() -> Self {
    TRawPixelData{
      width: Some(0),
      height: Some(0),
      render_pass_map: Some(BTreeMap::new()),
    }
  }
}

//
// TRenderDatum
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderDatum {
  pub type_: Option<common::TDatumType>,
  pub cnt: Option<i32>,
  pub value: Option<Vec<u8>>,
}

impl TRenderDatum {
  pub fn new<F1, F2, F3>(type_: F1, cnt: F2, value: F3) -> TRenderDatum where F1: Into<Option<common::TDatumType>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>> {
    TRenderDatum {
      type_: type_.into(),
      cnt: cnt.into(),
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderDatum> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TDatumType> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TDatumType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderDatum {
      type_: f_1,
      cnt: f_2,
      value: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderDatum");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cnt {
      o_prot.write_field_begin(&TFieldIdentifier::new("cnt", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderDatum {
  fn default() -> Self {
    TRenderDatum{
      type_: None,
      cnt: Some(0),
      value: Some(Vec::new()),
    }
  }
}

//
// TRenderStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRenderStepResult {
  pub merge_data: Option<TRenderAggDataMap>,
  pub raw_pixel_data: Option<TRawPixelData>,
  pub execution_time_ms: Option<i64>,
  pub render_time_ms: Option<i64>,
  pub total_time_ms: Option<i64>,
}

impl TRenderStepResult {
  pub fn new<F1, F2, F3, F4, F5>(merge_data: F1, raw_pixel_data: F2, execution_time_ms: F3, render_time_ms: F4, total_time_ms: F5) -> TRenderStepResult where F1: Into<Option<TRenderAggDataMap>>, F2: Into<Option<TRawPixelData>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    TRenderStepResult {
      merge_data: merge_data.into(),
      raw_pixel_data: raw_pixel_data.into(),
      execution_time_ms: execution_time_ms.into(),
      render_time_ms: render_time_ms.into(),
      total_time_ms: total_time_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRenderStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRenderAggDataMap> = Some(BTreeMap::new());
    let mut f_2: Option<TRawPixelData> = None;
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_29 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_30: BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_31 = i_prot.read_string()?;
              let map_ident = i_prot.read_map_begin()?;
              let mut map_val_32: BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>> = BTreeMap::new();
              for _ in 0..map_ident.size {
                let map_key_33 = i_prot.read_string()?;
                let map_ident = i_prot.read_map_begin()?;
                let mut map_val_34: BTreeMap<String, Vec<TRenderDatum>> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_35 = i_prot.read_string()?;
                  let list_ident = i_prot.read_list_begin()?;
                  let mut map_val_36: Vec<TRenderDatum> = Vec::with_capacity(list_ident.size as usize);
                  for _ in 0..list_ident.size {
                    let list_elem_37 = TRenderDatum::read_from_in_protocol(i_prot)?;
                    map_val_36.push(list_elem_37);
                  }
                  i_prot.read_list_end()?;
                  map_val_34.insert(map_key_35, map_val_36);
                }
                i_prot.read_map_end()?;
                map_val_32.insert(map_key_33, map_val_34);
              }
              i_prot.read_map_end()?;
              map_val_30.insert(map_key_31, map_val_32);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_29, map_val_30);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TRawPixelData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRenderStepResult {
      merge_data: f_1,
      raw_pixel_data: f_2,
      execution_time_ms: f_3,
      render_time_ms: f_4,
      total_time_ms: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRenderStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.merge_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_data", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
        for (k, v) in v {
          o_prot.write_string(k)?;
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
          for (k, v) in v {
            o_prot.write_string(k)?;
            o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
            for (k, v) in v {
              o_prot.write_string(k)?;
              o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
              for e in v {
                e.write_to_out_protocol(o_prot)?;
                o_prot.write_list_end()?;
              }
              o_prot.write_map_end()?;
            }
            o_prot.write_map_end()?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.raw_pixel_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("raw_pixel_data", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.execution_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_time_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.render_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("render_time_ms", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_time_ms", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TRenderStepResult {
  fn default() -> Self {
    TRenderStepResult{
      merge_data: Some(BTreeMap::new()),
      raw_pixel_data: None,
      execution_time_ms: Some(0),
      render_time_ms: Some(0),
      total_time_ms: Some(0),
    }
  }
}

//
// TDatabasePermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatabasePermissions {
  pub create_: Option<bool>,
  pub delete_: Option<bool>,
  pub view_sql_editor_: Option<bool>,
  pub access_: Option<bool>,
}

impl TDatabasePermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, delete_: F2, view_sql_editor_: F3, access_: F4) -> TDatabasePermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TDatabasePermissions {
      create_: create_.into(),
      delete_: delete_.into(),
      view_sql_editor_: view_sql_editor_.into(),
      access_: access_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatabasePermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDatabasePermissions {
      create_: f_1,
      delete_: f_2,
      view_sql_editor_: f_3,
      access_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDatabasePermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.view_sql_editor_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_sql_editor_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.access_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("access_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDatabasePermissions {
  fn default() -> Self {
    TDatabasePermissions{
      create_: Some(false),
      delete_: Some(false),
      view_sql_editor_: Some(false),
      access_: Some(false),
    }
  }
}

//
// TTablePermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTablePermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub select_: Option<bool>,
  pub insert_: Option<bool>,
  pub update_: Option<bool>,
  pub delete_: Option<bool>,
  pub truncate_: Option<bool>,
  pub alter_: Option<bool>,
}

impl TTablePermissions {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(create_: F1, drop_: F2, select_: F3, insert_: F4, update_: F5, delete_: F6, truncate_: F7, alter_: F8) -> TTablePermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    TTablePermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      select_: select_.into(),
      insert_: insert_.into(),
      update_: update_.into(),
      delete_: delete_.into(),
      truncate_: truncate_.into(),
      alter_: alter_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTablePermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTablePermissions {
      create_: f_1,
      drop_: f_2,
      select_: f_3,
      insert_: f_4,
      update_: f_5,
      delete_: f_6,
      truncate_: f_7,
      alter_: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTablePermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.select_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("select_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.insert_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.update_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.truncate_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("truncate_", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.alter_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("alter_", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTablePermissions {
  fn default() -> Self {
    TTablePermissions{
      create_: Some(false),
      drop_: Some(false),
      select_: Some(false),
      insert_: Some(false),
      update_: Some(false),
      delete_: Some(false),
      truncate_: Some(false),
      alter_: Some(false),
    }
  }
}

//
// TDashboardPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboardPermissions {
  pub create_: Option<bool>,
  pub delete_: Option<bool>,
  pub view_: Option<bool>,
  pub edit_: Option<bool>,
}

impl TDashboardPermissions {
  pub fn new<F1, F2, F3, F4>(create_: F1, delete_: F2, view_: F3, edit_: F4) -> TDashboardPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    TDashboardPermissions {
      create_: create_.into(),
      delete_: delete_.into(),
      view_: view_.into(),
      edit_: edit_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboardPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboardPermissions {
      create_: f_1,
      delete_: f_2,
      view_: f_3,
      edit_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboardPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.view_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("view_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.edit_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("edit_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboardPermissions {
  fn default() -> Self {
    TDashboardPermissions{
      create_: Some(false),
      delete_: Some(false),
      view_: Some(false),
      edit_: Some(false),
    }
  }
}

//
// TViewPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TViewPermissions {
  pub create_: Option<bool>,
  pub drop_: Option<bool>,
  pub select_: Option<bool>,
  pub insert_: Option<bool>,
  pub update_: Option<bool>,
  pub delete_: Option<bool>,
}

impl TViewPermissions {
  pub fn new<F1, F2, F3, F4, F5, F6>(create_: F1, drop_: F2, select_: F3, insert_: F4, update_: F5, delete_: F6) -> TViewPermissions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>> {
    TViewPermissions {
      create_: create_.into(),
      drop_: drop_.into(),
      select_: select_.into(),
      insert_: insert_.into(),
      update_: update_.into(),
      delete_: delete_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TViewPermissions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TViewPermissions {
      create_: f_1,
      drop_: f_2,
      select_: f_3,
      insert_: f_4,
      update_: f_5,
      delete_: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TViewPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("create_", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.drop_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop_", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.select_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("select_", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.insert_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.update_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.delete_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TViewPermissions {
  fn default() -> Self {
    TViewPermissions{
      create_: Some(false),
      drop_: Some(false),
      select_: Some(false),
      insert_: Some(false),
      update_: Some(false),
      delete_: Some(false),
    }
  }
}

//
// TDBObjectPermissions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TDBObjectPermissions {
  DatabasePermissions(TDatabasePermissions),
  TablePermissions(TTablePermissions),
  DashboardPermissions(TDashboardPermissions),
  ViewPermissions(TViewPermissions),
}

impl TDBObjectPermissions {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObjectPermissions> {
    let mut ret: Option<TDBObjectPermissions> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatabasePermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::DatabasePermissions(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TTablePermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::TablePermissions(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::DashboardPermissions(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TViewPermissions::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TDBObjectPermissions::ViewPermissions(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TDBObjectPermissions"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TDBObjectPermissions"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBObjectPermissions");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TDBObjectPermissions::DatabasePermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("database_permissions_", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::TablePermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("table_permissions_", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::DashboardPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_permissions_", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TDBObjectPermissions::ViewPermissions(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("view_permissions_", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDBObject
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDBObject {
  pub object_name: Option<String>,
  pub object_type: Option<TDBObjectType>,
  pub privs: Option<Vec<bool>>,
  pub grantee: Option<String>,
  pub privilege_object_type: Option<TDBObjectType>,
}

impl TDBObject {
  pub fn new<F1, F2, F3, F4, F5>(object_name: F1, object_type: F2, privs: F3, grantee: F4, privilege_object_type: F5) -> TDBObject where F1: Into<Option<String>>, F2: Into<Option<TDBObjectType>>, F3: Into<Option<Vec<bool>>>, F4: Into<Option<String>>, F5: Into<Option<TDBObjectType>> {
    TDBObject {
      object_name: object_name.into(),
      object_type: object_type.into(),
      privs: privs.into(),
      grantee: grantee.into(),
      privilege_object_type: privilege_object_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDBObject> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TDBObjectType> = None;
    let mut f_3: Option<Vec<bool>> = Some(Vec::new());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<TDBObjectType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = i_prot.read_bool()?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDBObject {
      object_name: f_1,
      object_type: f_2,
      privs: f_3,
      grantee: f_4,
      privilege_object_type: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDBObject");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.object_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.privs {
      o_prot.write_field_begin(&TFieldIdentifier::new("privs", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.grantee {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantee", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.privilege_object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilegeObjectType", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDBObject {
  fn default() -> Self {
    TDBObject{
      object_name: Some("".to_owned()),
      object_type: None,
      privs: Some(Vec::new()),
      grantee: Some("".to_owned()),
      privilege_object_type: None,
    }
  }
}

//
// TDashboardGrantees
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDashboardGrantees {
  pub name: Option<String>,
  pub is_user: Option<bool>,
  pub permissions: Option<TDashboardPermissions>,
}

impl TDashboardGrantees {
  pub fn new<F1, F2, F3>(name: F1, is_user: F2, permissions: F3) -> TDashboardGrantees where F1: Into<Option<String>>, F2: Into<Option<bool>>, F3: Into<Option<TDashboardPermissions>> {
    TDashboardGrantees {
      name: name.into(),
      is_user: is_user.into(),
      permissions: permissions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDashboardGrantees> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDashboardGrantees {
      name: f_1,
      is_user: f_2,
      permissions: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDashboardGrantees");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_user {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_user", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.permissions {
      o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TDashboardGrantees {
  fn default() -> Self {
    TDashboardGrantees{
      name: Some("".to_owned()),
      is_user: Some(false),
      permissions: None,
    }
  }
}

//
// TLicenseInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLicenseInfo {
  pub claims: Option<Vec<String>>,
}

impl TLicenseInfo {
  pub fn new<F1>(claims: F1) -> TLicenseInfo where F1: Into<Option<Vec<String>>> {
    TLicenseInfo {
      claims: claims.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLicenseInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = i_prot.read_string()?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TLicenseInfo {
      claims: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLicenseInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.claims {
      o_prot.write_field_begin(&TFieldIdentifier::new("claims", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TLicenseInfo {
  fn default() -> Self {
    TLicenseInfo{
      claims: Some(Vec::new()),
    }
  }
}

//
// TSessionInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSessionInfo {
  pub user: Option<String>,
  pub database: Option<String>,
  pub start_time: Option<i64>,
  pub is_super: Option<bool>,
}

impl TSessionInfo {
  pub fn new<F1, F2, F3, F4>(user: F1, database: F2, start_time: F3, is_super: F4) -> TSessionInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<bool>> {
    TSessionInfo {
      user: user.into(),
      database: database.into(),
      start_time: start_time.into(),
      is_super: is_super.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSessionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSessionInfo {
      user: f_1,
      database: f_2,
      start_time: f_3,
      is_super: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSessionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_time", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_super {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_super", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSessionInfo {
  fn default() -> Self {
    TSessionInfo{
      user: Some("".to_owned()),
      database: Some("".to_owned()),
      start_time: Some(0),
      is_super: Some(false),
    }
  }
}

//
// TGeoFileLayerInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGeoFileLayerInfo {
  pub name: Option<String>,
  pub contents: Option<TGeoFileLayerContents>,
}

impl TGeoFileLayerInfo {
  pub fn new<F1, F2>(name: F1, contents: F2) -> TGeoFileLayerInfo where F1: Into<Option<String>>, F2: Into<Option<TGeoFileLayerContents>> {
    TGeoFileLayerInfo {
      name: name.into(),
      contents: contents.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGeoFileLayerInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TGeoFileLayerContents> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TGeoFileLayerContents::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGeoFileLayerInfo {
      name: f_1,
      contents: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGeoFileLayerInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contents {
      o_prot.write_field_begin(&TFieldIdentifier::new("contents", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TGeoFileLayerInfo {
  fn default() -> Self {
    TGeoFileLayerInfo{
      name: Some("".to_owned()),
      contents: None,
    }
  }
}

//
// MapD service client
//

pub trait TMapDSyncClient {
  fn connect(&mut self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId>;
  fn krb5_connect(&mut self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session>;
  fn disconnect(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn switch_database(&mut self, session: TSessionId, dbname: String) -> thrift::Result<()>;
  fn get_server_status(&mut self, session: TSessionId) -> thrift::Result<TServerStatus>;
  fn get_status(&mut self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>>;
  fn get_hardware_info(&mut self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo>;
  fn get_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_physical_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_views(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_tables_meta(&mut self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>>;
  fn get_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn get_internal_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn get_users(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_databases(&mut self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>>;
  fn get_version(&mut self) -> thrift::Result<String>;
  fn start_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn stop_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn get_heap_profile(&mut self, session: TSessionId) -> thrift::Result<String>;
  fn get_memory(&mut self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>>;
  fn clear_cpu_memory(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn clear_gpu_memory(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn set_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()>;
  fn set_table_epoch_by_name(&mut self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()>;
  fn get_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32>;
  fn get_table_epoch_by_name(&mut self, session: TSessionId, table_name: String) -> thrift::Result<i32>;
  fn get_session_info(&mut self, session: TSessionId) -> thrift::Result<TSessionInfo>;
  fn sql_execute(&mut self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult>;
  fn sql_execute_df(&mut self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn sql_execute_gdf(&mut self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn deallocate_df(&mut self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()>;
  fn interrupt(&mut self, session: TSessionId) -> thrift::Result<()>;
  fn sql_validate(&mut self, session: TSessionId, query: String) -> thrift::Result<TTableDescriptor>;
  fn get_completion_hints(&mut self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>>;
  fn set_execution_mode(&mut self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()>;
  fn render_vega(&mut self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult>;
  fn get_result_row_for_pixel(&mut self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult>;
  fn get_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard>;
  fn get_dashboards(&mut self, session: TSessionId) -> thrift::Result<Vec<TDashboard>>;
  fn create_dashboard(&mut self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32>;
  fn replace_dashboard(&mut self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()>;
  fn delete_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()>;
  fn share_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()>;
  fn unshare_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn get_dashboard_grantees(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>>;
  fn get_link_view(&mut self, session: TSessionId, link: String) -> thrift::Result<TFrontendView>;
  fn create_link(&mut self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String>;
  fn load_table_binary(&mut self, session: TSessionId, table_name: String, rows: Vec<TRow>) -> thrift::Result<()>;
  fn load_table_binary_columnar(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>) -> thrift::Result<()>;
  fn load_table_binary_arrow(&mut self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>) -> thrift::Result<()>;
  fn load_table(&mut self, session: TSessionId, table_name: String, rows: Vec<TStringRow>) -> thrift::Result<()>;
  fn detect_column_types(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult>;
  fn create_table(&mut self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, file_type: TFileType, create_params: TCreateParams) -> thrift::Result<()>;
  fn import_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()>;
  fn import_geo_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn import_table_status(&mut self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus>;
  fn get_first_geo_file_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String>;
  fn get_all_files_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>>;
  fn get_layers_in_geo_file(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>>;
  fn check_table_consistency(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta>;
  fn start_query(&mut self, session: TSessionId, query_ra: String, just_explain: bool) -> thrift::Result<TPendingQuery>;
  fn execute_query_step(&mut self, pending_query: TPendingQuery) -> thrift::Result<TStepResult>;
  fn broadcast_serialized_rows(&mut self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId) -> thrift::Result<()>;
  fn start_render_query(&mut self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery>;
  fn execute_next_render_step(&mut self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult>;
  fn insert_data(&mut self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()>;
  fn checkpoint(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<()>;
  fn get_roles(&mut self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn get_db_objects_for_grantee(&mut self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>>;
  fn get_db_object_privs(&mut self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>>;
  fn get_all_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn has_role(&mut self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool>;
  fn has_object_privilege(&mut self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool>;
  fn set_license_key(&mut self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn get_license_claims(&mut self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn get_device_parameters(&mut self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>>;
  fn register_runtime_extension_functions(&mut self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()>;
}

pub trait TMapDSyncClientMarker {}

pub struct MapDSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> MapDSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> MapDSyncClient<IP, OP> {
    MapDSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for MapDSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TMapDSyncClientMarker for MapDSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TMapDSyncClientMarker> TMapDSyncClient for C {
  fn connect(&mut self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connect", TMessageType::Call, self.sequence_number());
        let call_args = MapDConnectArgs { user: user, passwd: passwd, dbname: dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDConnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn krb5_connect(&mut self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Call, self.sequence_number());
        let call_args = MapDKrb5ConnectArgs { input_token: input_token, dbname: dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("krb5_connect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDKrb5ConnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn disconnect(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Call, self.sequence_number());
        let call_args = MapDDisconnectArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("disconnect", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDDisconnectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn switch_database(&mut self, session: TSessionId, dbname: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Call, self.sequence_number());
        let call_args = MapDSwitchDatabaseArgs { session: session, dbname: dbname };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("switch_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSwitchDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_server_status(&mut self, session: TSessionId) -> thrift::Result<TServerStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetServerStatusArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_server_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetServerStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_status(&mut self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_status", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetStatusArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_hardware_info(&mut self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetHardwareInfoArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_hardware_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetHardwareInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetTablesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_physical_tables(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetPhysicalTablesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_physical_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetPhysicalTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_views(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_views", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetViewsArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_views", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetViewsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables_meta(&mut self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetTablesMetaArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables_meta", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetTablesMetaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetTableDetailsArgs { session: session, table_name: table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetTableDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_internal_table_details(&mut self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetInternalTableDetailsArgs { session: session, table_name: table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_internal_table_details", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetInternalTableDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_users(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_users", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetUsersArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_users", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetUsersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_databases(&mut self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDatabasesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_databases", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDatabasesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_version(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_version", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetVersionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = MapDStartHeapProfileArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDStartHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn stop_heap_profile(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = MapDStopHeapProfileArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("stop_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDStopHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_heap_profile(&mut self, session: TSessionId) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetHeapProfileArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_heap_profile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetHeapProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_memory(&mut self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetMemoryArgs { session: session, memory_level: memory_level };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_cpu_memory(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Call, self.sequence_number());
        let call_args = MapDClearCpuMemoryArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_cpu_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDClearCpuMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_gpu_memory(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Call, self.sequence_number());
        let call_args = MapDClearGpuMemoryArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_gpu_memory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDClearGpuMemoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Call, self.sequence_number());
        let call_args = MapDSetTableEpochArgs { session: session, db_id: db_id, table_id: table_id, new_epoch: new_epoch };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epoch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSetTableEpochResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_table_epoch_by_name(&mut self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Call, self.sequence_number());
        let call_args = MapDSetTableEpochByNameArgs { session: session, table_name: table_name, new_epoch: new_epoch };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_table_epoch_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSetTableEpochByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epoch(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetTableEpochArgs { session: session, db_id: db_id, table_id: table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epoch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetTableEpochResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_epoch_by_name(&mut self, session: TSessionId, table_name: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetTableEpochByNameArgs { session: session, table_name: table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_epoch_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetTableEpochByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_session_info(&mut self, session: TSessionId) -> thrift::Result<TSessionInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetSessionInfoArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_session_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetSessionInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute(&mut self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Call, self.sequence_number());
        let call_args = MapDSqlExecuteArgs { session: session, query: query, column_format: column_format, nonce: nonce, first_n: first_n, at_most_n: at_most_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSqlExecuteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute_df(&mut self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Call, self.sequence_number());
        let call_args = MapDSqlExecuteDfArgs { session: session, query: query, device_type: device_type, device_id: device_id, first_n: first_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute_df", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSqlExecuteDfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_execute_gdf(&mut self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Call, self.sequence_number());
        let call_args = MapDSqlExecuteGdfArgs { session: session, query: query, device_id: device_id, first_n: first_n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_execute_gdf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSqlExecuteGdfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn deallocate_df(&mut self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Call, self.sequence_number());
        let call_args = MapDDeallocateDfArgs { session: session, df: df, device_type: device_type, device_id: device_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deallocate_df", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDDeallocateDfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn interrupt(&mut self, session: TSessionId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Call, self.sequence_number());
        let call_args = MapDInterruptArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("interrupt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDInterruptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_validate(&mut self, session: TSessionId, query: String) -> thrift::Result<TTableDescriptor> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Call, self.sequence_number());
        let call_args = MapDSqlValidateArgs { session: session, query: query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_validate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSqlValidateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_completion_hints(&mut self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetCompletionHintsArgs { session: session, sql: sql, cursor: cursor };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_completion_hints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetCompletionHintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_execution_mode(&mut self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Call, self.sequence_number());
        let call_args = MapDSetExecutionModeArgs { session: session, mode: mode };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_execution_mode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSetExecutionModeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn render_vega(&mut self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Call, self.sequence_number());
        let call_args = MapDRenderVegaArgs { session: session, widget_id: widget_id, vega_json: vega_json, compression_level: compression_level, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("render_vega", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDRenderVegaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_result_row_for_pixel(&mut self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetResultRowForPixelArgs { session: session, widget_id: widget_id, pixel: pixel, table_col_names: table_col_names, column_format: column_format, pixel_radius: pixel_radius, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_result_row_for_pixel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetResultRowForPixelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDashboardArgs { session: session, dashboard_id: dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboards(&mut self, session: TSessionId) -> thrift::Result<Vec<TDashboard>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDashboardsArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDashboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_dashboard(&mut self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = MapDCreateDashboardArgs { session: session, dashboard_name: dashboard_name, dashboard_state: dashboard_state, image_hash: image_hash, dashboard_metadata: dashboard_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDCreateDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn replace_dashboard(&mut self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = MapDReplaceDashboardArgs { session: session, dashboard_id: dashboard_id, dashboard_name: dashboard_name, dashboard_owner: dashboard_owner, dashboard_state: dashboard_state, image_hash: image_hash, dashboard_metadata: dashboard_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("replace_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDReplaceDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_dashboard(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = MapDDeleteDashboardArgs { session: session, dashboard_id: dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDDeleteDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn share_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = MapDShareDashboardArgs { session: session, dashboard_id: dashboard_id, groups: groups, objects: objects, permissions: permissions, grant_role: grant_role };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("share_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDShareDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unshare_dashboard(&mut self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Call, self.sequence_number());
        let call_args = MapDUnshareDashboardArgs { session: session, dashboard_id: dashboard_id, groups: groups, objects: objects, permissions: permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unshare_dashboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDUnshareDashboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_dashboard_grantees(&mut self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDashboardGranteesArgs { session: session, dashboard_id: dashboard_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_dashboard_grantees", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDashboardGranteesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_link_view(&mut self, session: TSessionId, link: String) -> thrift::Result<TFrontendView> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetLinkViewArgs { session: session, link: link };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_link_view", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetLinkViewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_link(&mut self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_link", TMessageType::Call, self.sequence_number());
        let call_args = MapDCreateLinkArgs { session: session, view_state: view_state, view_metadata: view_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_link", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDCreateLinkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary(&mut self, session: TSessionId, table_name: String, rows: Vec<TRow>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Call, self.sequence_number());
        let call_args = MapDLoadTableBinaryArgs { session: session, table_name: table_name, rows: rows };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDLoadTableBinaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_columnar(&mut self, session: TSessionId, table_name: String, cols: Vec<TColumn>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Call, self.sequence_number());
        let call_args = MapDLoadTableBinaryColumnarArgs { session: session, table_name: table_name, cols: cols };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_columnar", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDLoadTableBinaryColumnarResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table_binary_arrow(&mut self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Call, self.sequence_number());
        let call_args = MapDLoadTableBinaryArrowArgs { session: session, table_name: table_name, arrow_stream: arrow_stream };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table_binary_arrow", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDLoadTableBinaryArrowResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn load_table(&mut self, session: TSessionId, table_name: String, rows: Vec<TStringRow>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("load_table", TMessageType::Call, self.sequence_number());
        let call_args = MapDLoadTableArgs { session: session, table_name: table_name, rows: rows };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("load_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDLoadTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn detect_column_types(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Call, self.sequence_number());
        let call_args = MapDDetectColumnTypesArgs { session: session, file_name: file_name, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("detect_column_types", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDDetectColumnTypesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_table(&mut self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, file_type: TFileType, create_params: TCreateParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Call, self.sequence_number());
        let call_args = MapDCreateTableArgs { session: session, table_name: table_name, row_desc: row_desc, file_type: file_type, create_params: create_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDCreateTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_table", TMessageType::Call, self.sequence_number());
        let call_args = MapDImportTableArgs { session: session, table_name: table_name, file_name: file_name, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDImportTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_geo_table(&mut self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Call, self.sequence_number());
        let call_args = MapDImportGeoTableArgs { session: session, table_name: table_name, file_name: file_name, copy_params: copy_params, row_desc: row_desc, create_params: create_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_geo_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDImportGeoTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_table_status(&mut self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Call, self.sequence_number());
        let call_args = MapDImportTableStatusArgs { session: session, import_id: import_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_table_status", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDImportTableStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_first_geo_file_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetFirstGeoFileInArchiveArgs { session: session, archive_path: archive_path, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_first_geo_file_in_archive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetFirstGeoFileInArchiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_files_in_archive(&mut self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetAllFilesInArchiveArgs { session: session, archive_path: archive_path, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_files_in_archive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetAllFilesInArchiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_layers_in_geo_file(&mut self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetLayersInGeoFileArgs { session: session, file_name: file_name, copy_params: copy_params };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_layers_in_geo_file", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetLayersInGeoFileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_table_consistency(&mut self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Call, self.sequence_number());
        let call_args = MapDCheckTableConsistencyArgs { session: session, table_id: table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("check_table_consistency", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDCheckTableConsistencyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_query(&mut self, session: TSessionId, query_ra: String, just_explain: bool) -> thrift::Result<TPendingQuery> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_query", TMessageType::Call, self.sequence_number());
        let call_args = MapDStartQueryArgs { session: session, query_ra: query_ra, just_explain: just_explain };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDStartQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_query_step(&mut self, pending_query: TPendingQuery) -> thrift::Result<TStepResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Call, self.sequence_number());
        let call_args = MapDExecuteQueryStepArgs { pending_query: pending_query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("execute_query_step", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDExecuteQueryStepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn broadcast_serialized_rows(&mut self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Call, self.sequence_number());
        let call_args = MapDBroadcastSerializedRowsArgs { serialized_rows: serialized_rows, row_desc: row_desc, query_id: query_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("broadcast_serialized_rows", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDBroadcastSerializedRowsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_render_query(&mut self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Call, self.sequence_number());
        let call_args = MapDStartRenderQueryArgs { session: session, widget_id: widget_id, node_idx: node_idx, vega_json: vega_json };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("start_render_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDStartRenderQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_next_render_step(&mut self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Call, self.sequence_number());
        let call_args = MapDExecuteNextRenderStepArgs { pending_render: pending_render, merged_data: merged_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("execute_next_render_step", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDExecuteNextRenderStepResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_data(&mut self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Call, self.sequence_number());
        let call_args = MapDInsertDataArgs { session: session, insert_data: insert_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insert_data", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDInsertDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn checkpoint(&mut self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Call, self.sequence_number());
        let call_args = MapDCheckpointArgs { session: session, db_id: db_id, table_id: table_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkpoint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDCheckpointResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_roles(&mut self, session: TSessionId) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetRolesArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_roles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetRolesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_db_objects_for_grantee(&mut self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDbObjectsForGranteeArgs { session: session, role_name: role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_db_objects_for_grantee", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDbObjectsForGranteeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_db_object_privs(&mut self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDbObjectPrivsArgs { session: session, object_name: object_name, type_: type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_db_object_privs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDbObjectPrivsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_roles_for_user(&mut self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetAllRolesForUserArgs { session: session, user_name: user_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_roles_for_user", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetAllRolesForUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_role(&mut self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_role", TMessageType::Call, self.sequence_number());
        let call_args = MapDHasRoleArgs { session: session, grantee_name: grantee_name, role_name: role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDHasRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_object_privilege(&mut self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Call, self.sequence_number());
        let call_args = MapDHasObjectPrivilegeArgs { session: session, grantee_name: grantee_name, object_name: object_name, object_type: object_type, permissions: permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_object_privilege", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDHasObjectPrivilegeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_license_key(&mut self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Call, self.sequence_number());
        let call_args = MapDSetLicenseKeyArgs { session: session, key: key, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_license_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDSetLicenseKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_license_claims(&mut self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetLicenseClaimsArgs { session: session, nonce: nonce };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_license_claims", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetLicenseClaimsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_device_parameters(&mut self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Call, self.sequence_number());
        let call_args = MapDGetDeviceParametersArgs { session: session };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_device_parameters", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDGetDeviceParametersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn register_runtime_extension_functions(&mut self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Call, self.sequence_number());
        let call_args = MapDRegisterRuntimeExtensionFunctionsArgs { session: session, udfs: udfs, udtfs: udtfs, device_ir_map: device_ir_map };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("register_runtime_extension_functions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = MapDRegisterRuntimeExtensionFunctionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// MapD service processor
//

pub trait MapDSyncHandler {
  fn handle_connect(&self, user: String, passwd: String, dbname: String) -> thrift::Result<TSessionId>;
  fn handle_krb5_connect(&self, input_token: String, dbname: String) -> thrift::Result<TKrb5Session>;
  fn handle_disconnect(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_switch_database(&self, session: TSessionId, dbname: String) -> thrift::Result<()>;
  fn handle_get_server_status(&self, session: TSessionId) -> thrift::Result<TServerStatus>;
  fn handle_get_status(&self, session: TSessionId) -> thrift::Result<Vec<TServerStatus>>;
  fn handle_get_hardware_info(&self, session: TSessionId) -> thrift::Result<TClusterHardwareInfo>;
  fn handle_get_tables(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_physical_tables(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_views(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_tables_meta(&self, session: TSessionId) -> thrift::Result<Vec<TTableMeta>>;
  fn handle_get_table_details(&self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_internal_table_details(&self, session: TSessionId, table_name: String) -> thrift::Result<TTableDetails>;
  fn handle_get_users(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_databases(&self, session: TSessionId) -> thrift::Result<Vec<TDBInfo>>;
  fn handle_get_version(&self) -> thrift::Result<String>;
  fn handle_start_heap_profile(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_stop_heap_profile(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_get_heap_profile(&self, session: TSessionId) -> thrift::Result<String>;
  fn handle_get_memory(&self, session: TSessionId, memory_level: String) -> thrift::Result<Vec<TNodeMemoryInfo>>;
  fn handle_clear_cpu_memory(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_clear_gpu_memory(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_set_table_epoch(&self, session: TSessionId, db_id: i32, table_id: i32, new_epoch: i32) -> thrift::Result<()>;
  fn handle_set_table_epoch_by_name(&self, session: TSessionId, table_name: String, new_epoch: i32) -> thrift::Result<()>;
  fn handle_get_table_epoch(&self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<i32>;
  fn handle_get_table_epoch_by_name(&self, session: TSessionId, table_name: String) -> thrift::Result<i32>;
  fn handle_get_session_info(&self, session: TSessionId) -> thrift::Result<TSessionInfo>;
  fn handle_sql_execute(&self, session: TSessionId, query: String, column_format: bool, nonce: String, first_n: i32, at_most_n: i32) -> thrift::Result<TQueryResult>;
  fn handle_sql_execute_df(&self, session: TSessionId, query: String, device_type: common::TDeviceType, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn handle_sql_execute_gdf(&self, session: TSessionId, query: String, device_id: i32, first_n: i32) -> thrift::Result<TDataFrame>;
  fn handle_deallocate_df(&self, session: TSessionId, df: TDataFrame, device_type: common::TDeviceType, device_id: i32) -> thrift::Result<()>;
  fn handle_interrupt(&self, session: TSessionId) -> thrift::Result<()>;
  fn handle_sql_validate(&self, session: TSessionId, query: String) -> thrift::Result<TTableDescriptor>;
  fn handle_get_completion_hints(&self, session: TSessionId, sql: String, cursor: i32) -> thrift::Result<Vec<completion_hints::TCompletionHint>>;
  fn handle_set_execution_mode(&self, session: TSessionId, mode: TExecuteMode) -> thrift::Result<()>;
  fn handle_render_vega(&self, session: TSessionId, widget_id: i64, vega_json: String, compression_level: i32, nonce: String) -> thrift::Result<TRenderResult>;
  fn handle_get_result_row_for_pixel(&self, session: TSessionId, widget_id: i64, pixel: TPixel, table_col_names: BTreeMap<String, Vec<String>>, column_format: bool, pixel_radius: i32, nonce: String) -> thrift::Result<TPixelTableRowResult>;
  fn handle_get_dashboard(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<TDashboard>;
  fn handle_get_dashboards(&self, session: TSessionId) -> thrift::Result<Vec<TDashboard>>;
  fn handle_create_dashboard(&self, session: TSessionId, dashboard_name: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<i32>;
  fn handle_replace_dashboard(&self, session: TSessionId, dashboard_id: i32, dashboard_name: String, dashboard_owner: String, dashboard_state: String, image_hash: String, dashboard_metadata: String) -> thrift::Result<()>;
  fn handle_delete_dashboard(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<()>;
  fn handle_share_dashboard(&self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions, grant_role: bool) -> thrift::Result<()>;
  fn handle_unshare_dashboard(&self, session: TSessionId, dashboard_id: i32, groups: Vec<String>, objects: Vec<String>, permissions: TDashboardPermissions) -> thrift::Result<()>;
  fn handle_get_dashboard_grantees(&self, session: TSessionId, dashboard_id: i32) -> thrift::Result<Vec<TDashboardGrantees>>;
  fn handle_get_link_view(&self, session: TSessionId, link: String) -> thrift::Result<TFrontendView>;
  fn handle_create_link(&self, session: TSessionId, view_state: String, view_metadata: String) -> thrift::Result<String>;
  fn handle_load_table_binary(&self, session: TSessionId, table_name: String, rows: Vec<TRow>) -> thrift::Result<()>;
  fn handle_load_table_binary_columnar(&self, session: TSessionId, table_name: String, cols: Vec<TColumn>) -> thrift::Result<()>;
  fn handle_load_table_binary_arrow(&self, session: TSessionId, table_name: String, arrow_stream: Vec<u8>) -> thrift::Result<()>;
  fn handle_load_table(&self, session: TSessionId, table_name: String, rows: Vec<TStringRow>) -> thrift::Result<()>;
  fn handle_detect_column_types(&self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<TDetectResult>;
  fn handle_create_table(&self, session: TSessionId, table_name: String, row_desc: TRowDescriptor, file_type: TFileType, create_params: TCreateParams) -> thrift::Result<()>;
  fn handle_import_table(&self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams) -> thrift::Result<()>;
  fn handle_import_geo_table(&self, session: TSessionId, table_name: String, file_name: String, copy_params: TCopyParams, row_desc: TRowDescriptor, create_params: TCreateParams) -> thrift::Result<()>;
  fn handle_import_table_status(&self, session: TSessionId, import_id: String) -> thrift::Result<TImportStatus>;
  fn handle_get_first_geo_file_in_archive(&self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<String>;
  fn handle_get_all_files_in_archive(&self, session: TSessionId, archive_path: String, copy_params: TCopyParams) -> thrift::Result<Vec<String>>;
  fn handle_get_layers_in_geo_file(&self, session: TSessionId, file_name: String, copy_params: TCopyParams) -> thrift::Result<Vec<TGeoFileLayerInfo>>;
  fn handle_check_table_consistency(&self, session: TSessionId, table_id: i32) -> thrift::Result<TTableMeta>;
  fn handle_start_query(&self, session: TSessionId, query_ra: String, just_explain: bool) -> thrift::Result<TPendingQuery>;
  fn handle_execute_query_step(&self, pending_query: TPendingQuery) -> thrift::Result<TStepResult>;
  fn handle_broadcast_serialized_rows(&self, serialized_rows: serialized_result_set::TSerializedRows, row_desc: TRowDescriptor, query_id: TQueryId) -> thrift::Result<()>;
  fn handle_start_render_query(&self, session: TSessionId, widget_id: i64, node_idx: i16, vega_json: String) -> thrift::Result<TPendingRenderQuery>;
  fn handle_execute_next_render_step(&self, pending_render: TPendingRenderQuery, merged_data: TRenderAggDataMap) -> thrift::Result<TRenderStepResult>;
  fn handle_insert_data(&self, session: TSessionId, insert_data: TInsertData) -> thrift::Result<()>;
  fn handle_checkpoint(&self, session: TSessionId, db_id: i32, table_id: i32) -> thrift::Result<()>;
  fn handle_get_roles(&self, session: TSessionId) -> thrift::Result<Vec<String>>;
  fn handle_get_db_objects_for_grantee(&self, session: TSessionId, role_name: String) -> thrift::Result<Vec<TDBObject>>;
  fn handle_get_db_object_privs(&self, session: TSessionId, object_name: String, type_: TDBObjectType) -> thrift::Result<Vec<TDBObject>>;
  fn handle_get_all_roles_for_user(&self, session: TSessionId, user_name: String) -> thrift::Result<Vec<String>>;
  fn handle_has_role(&self, session: TSessionId, grantee_name: String, role_name: String) -> thrift::Result<bool>;
  fn handle_has_object_privilege(&self, session: TSessionId, grantee_name: String, object_name: String, object_type: TDBObjectType, permissions: TDBObjectPermissions) -> thrift::Result<bool>;
  fn handle_set_license_key(&self, session: TSessionId, key: String, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn handle_get_license_claims(&self, session: TSessionId, nonce: String) -> thrift::Result<TLicenseInfo>;
  fn handle_get_device_parameters(&self, session: TSessionId) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_register_runtime_extension_functions(&self, session: TSessionId, udfs: Vec<extension_functions::TUserDefinedFunction>, udtfs: Vec<extension_functions::TUserDefinedTableFunction>, device_ir_map: BTreeMap<String, String>) -> thrift::Result<()>;
}

pub struct MapDSyncProcessor<H: MapDSyncHandler> {
  handler: H,
}

impl <H: MapDSyncHandler> MapDSyncProcessor<H> {
  pub fn new(handler: H) -> MapDSyncProcessor<H> {
    MapDSyncProcessor {
      handler,
    }
  }
  fn process_connect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_connect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_krb5_connect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_krb5_connect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_disconnect(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_disconnect(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_switch_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_switch_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_server_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_server_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_hardware_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_hardware_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_physical_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_physical_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_views(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_views(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables_meta(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_tables_meta(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_table_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_internal_table_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_internal_table_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_users(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_users(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_databases(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_databases(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_start_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_stop_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_stop_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_heap_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_heap_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_cpu_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_clear_cpu_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_gpu_memory(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_clear_gpu_memory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epoch(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_set_table_epoch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_table_epoch_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_set_table_epoch_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epoch(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_table_epoch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_epoch_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_table_epoch_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_session_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_session_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_sql_execute(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute_df(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_sql_execute_df(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_execute_gdf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_sql_execute_gdf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_deallocate_df(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_deallocate_df(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_interrupt(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_interrupt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_validate(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_sql_validate(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_completion_hints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_completion_hints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_execution_mode(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_set_execution_mode(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_render_vega(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_render_vega(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_result_row_for_pixel(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_result_row_for_pixel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboards(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_dashboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_create_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_replace_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_replace_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_delete_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_share_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_share_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unshare_dashboard(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_unshare_dashboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_dashboard_grantees(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_dashboard_grantees(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_link_view(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_link_view(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_link(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_create_link(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_load_table_binary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_columnar(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_load_table_binary_columnar(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table_binary_arrow(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_load_table_binary_arrow(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_load_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_load_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_detect_column_types(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_detect_column_types(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_create_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_import_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_geo_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_import_geo_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_table_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_import_table_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_first_geo_file_in_archive(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_first_geo_file_in_archive(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_files_in_archive(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_all_files_in_archive(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_layers_in_geo_file(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_layers_in_geo_file(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_table_consistency(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_check_table_consistency(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_start_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_query_step(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_execute_query_step(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_broadcast_serialized_rows(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_broadcast_serialized_rows(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_render_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_start_render_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_next_render_step(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_execute_next_render_step(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_insert_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_checkpoint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_checkpoint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_roles(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_roles(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_db_objects_for_grantee(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_db_objects_for_grantee(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_db_object_privs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_db_object_privs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_roles_for_user(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_all_roles_for_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_has_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_object_privilege(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_has_object_privilege(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_license_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_set_license_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_license_claims(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_license_claims(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_device_parameters(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_get_device_parameters(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_register_runtime_extension_functions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TMapDProcessFunctions::process_register_runtime_extension_functions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TMapDProcessFunctions;

impl TMapDProcessFunctions {
  pub fn process_connect<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDConnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connect(args.user, args.passwd, args.dbname) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDConnectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDConnectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_krb5_connect<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDKrb5ConnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_krb5_connect(args.input_token, args.dbname) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDKrb5ConnectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDKrb5ConnectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("krb5_connect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_disconnect<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDDisconnectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_disconnect(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDDisconnectResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDDisconnectResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("disconnect", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_switch_database<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSwitchDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_switch_database(args.session, args.dbname) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSwitchDatabaseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSwitchDatabaseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("switch_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_server_status<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetServerStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_server_status(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetServerStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetServerStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_server_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_status<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_status(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_hardware_info<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetHardwareInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_hardware_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetHardwareInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetHardwareInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_hardware_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetTablesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetTablesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_physical_tables<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetPhysicalTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_physical_tables(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetPhysicalTablesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetPhysicalTablesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_physical_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_views<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetViewsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_views(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_views", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetViewsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetViewsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_views", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_views", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables_meta<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetTablesMetaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables_meta(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetTablesMetaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetTablesMetaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_details<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetTableDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_details(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetTableDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetTableDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_internal_table_details<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetInternalTableDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_internal_table_details(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetInternalTableDetailsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetInternalTableDetailsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_internal_table_details", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_users<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetUsersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_users(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_users", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetUsersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetUsersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_users", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_users", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_databases<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDatabasesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_databases(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDatabasesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDatabasesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_version<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = MapDGetVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_version() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetVersionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetVersionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_heap_profile<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDStartHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_heap_profile(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDStartHeapProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDStartHeapProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("start_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_stop_heap_profile<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDStopHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_stop_heap_profile(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDStopHeapProfileResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDStopHeapProfileResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("stop_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_heap_profile<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetHeapProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_heap_profile(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetHeapProfileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetHeapProfileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_heap_profile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_memory<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_memory(args.session, args.memory_level) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetMemoryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetMemoryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_cpu_memory<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDClearCpuMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_cpu_memory(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDClearCpuMemoryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDClearCpuMemoryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_cpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_gpu_memory<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDClearGpuMemoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_gpu_memory(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDClearGpuMemoryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDClearGpuMemoryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_gpu_memory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epoch<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSetTableEpochArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSetTableEpochResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSetTableEpochResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_table_epoch_by_name<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSetTableEpochByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_table_epoch_by_name(args.session, args.table_name, args.new_epoch) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSetTableEpochByNameResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSetTableEpochByNameResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epoch<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetTableEpochArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epoch(args.session, args.db_id, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetTableEpochResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epoch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_epoch_by_name<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetTableEpochByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_epoch_by_name(args.session, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetTableEpochByNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_epoch_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_session_info<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetSessionInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_session_info(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetSessionInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetSessionInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_session_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSqlExecuteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n, args.at_most_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSqlExecuteResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSqlExecuteResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute_df<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSqlExecuteDfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSqlExecuteDfResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSqlExecuteDfResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_execute_gdf<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSqlExecuteGdfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_execute_gdf(args.session, args.query, args.device_id, args.first_n) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSqlExecuteGdfResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSqlExecuteGdfResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_execute_gdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_deallocate_df<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDDeallocateDfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_deallocate_df(args.session, args.df, args.device_type, args.device_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDDeallocateDfResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDDeallocateDfResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("deallocate_df", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_interrupt<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDInterruptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_interrupt(args.session) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDInterruptResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDInterruptResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("interrupt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_validate<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSqlValidateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_validate(args.session, args.query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSqlValidateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSqlValidateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_validate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_completion_hints<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetCompletionHintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_completion_hints(args.session, args.sql, args.cursor) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetCompletionHintsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetCompletionHintsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_completion_hints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_execution_mode<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSetExecutionModeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_execution_mode(args.session, args.mode) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSetExecutionModeResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSetExecutionModeResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_execution_mode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_render_vega<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDRenderVegaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDRenderVegaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDRenderVegaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("render_vega", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_result_row_for_pixel<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetResultRowForPixelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixel_radius, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetResultRowForPixelResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetResultRowForPixelResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_result_row_for_pixel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboard<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboard(args.session, args.dashboard_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDashboardResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDashboardResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboards<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDashboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboards(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDashboardsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDashboardsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_dashboard<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDCreateDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_dashboard(args.session, args.dashboard_name, args.dashboard_state, args.image_hash, args.dashboard_metadata) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDCreateDashboardResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDCreateDashboardResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("create_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_replace_dashboard<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDReplaceDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_replace_dashboard(args.session, args.dashboard_id, args.dashboard_name, args.dashboard_owner, args.dashboard_state, args.image_hash, args.dashboard_metadata) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDReplaceDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDReplaceDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("replace_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_dashboard<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDDeleteDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_dashboard(args.session, args.dashboard_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDDeleteDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDDeleteDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_share_dashboard<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDShareDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_share_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, args.grant_role) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDShareDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDShareDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("share_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unshare_dashboard<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDUnshareDashboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unshare_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDUnshareDashboardResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDUnshareDashboardResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("unshare_dashboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_dashboard_grantees<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDashboardGranteesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_dashboard_grantees(args.session, args.dashboard_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDashboardGranteesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDashboardGranteesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_dashboard_grantees", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_link_view<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetLinkViewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_link_view(args.session, args.link) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetLinkViewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetLinkViewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_link_view", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_link<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDCreateLinkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_link(args.session, args.view_state, args.view_metadata) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_link", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDCreateLinkResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDCreateLinkResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_link", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("create_link", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDLoadTableBinaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary(args.session, args.table_name, args.rows) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDLoadTableBinaryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDLoadTableBinaryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_columnar<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDLoadTableBinaryColumnarArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_columnar(args.session, args.table_name, args.cols) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDLoadTableBinaryColumnarResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDLoadTableBinaryColumnarResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_columnar", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table_binary_arrow<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDLoadTableBinaryArrowArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table_binary_arrow(args.session, args.table_name, args.arrow_stream) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDLoadTableBinaryArrowResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDLoadTableBinaryArrowResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table_binary_arrow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_load_table<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDLoadTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_load_table(args.session, args.table_name, args.rows) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("load_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDLoadTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDLoadTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("load_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("load_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_detect_column_types<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDDetectColumnTypesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_detect_column_types(args.session, args.file_name, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDDetectColumnTypesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDDetectColumnTypesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("detect_column_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_table<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDCreateTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_table(args.session, args.table_name, args.row_desc, args.file_type, args.create_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDCreateTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDCreateTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_table<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDImportTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_table(args.session, args.table_name, args.file_name, args.copy_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("import_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDImportTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDImportTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("import_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_geo_table<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDImportGeoTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc, args.create_params) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDImportGeoTableResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDImportGeoTableResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("import_geo_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_table_status<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDImportTableStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_table_status(args.session, args.import_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDImportTableStatusResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDImportTableStatusResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("import_table_status", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_first_geo_file_in_archive<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetFirstGeoFileInArchiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_first_geo_file_in_archive(args.session, args.archive_path, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetFirstGeoFileInArchiveResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetFirstGeoFileInArchiveResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_first_geo_file_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_files_in_archive<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetAllFilesInArchiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_files_in_archive(args.session, args.archive_path, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetAllFilesInArchiveResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetAllFilesInArchiveResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_files_in_archive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_layers_in_geo_file<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetLayersInGeoFileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_layers_in_geo_file(args.session, args.file_name, args.copy_params) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetLayersInGeoFileResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetLayersInGeoFileResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_layers_in_geo_file", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_table_consistency<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDCheckTableConsistencyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_table_consistency(args.session, args.table_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDCheckTableConsistencyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDCheckTableConsistencyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("check_table_consistency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_query<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDStartQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_query(args.session, args.query_ra, args.just_explain) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("start_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDStartQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDStartQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("start_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_query_step<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDExecuteQueryStepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_query_step(args.pending_query) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDExecuteQueryStepResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDExecuteQueryStepResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("execute_query_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_broadcast_serialized_rows<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDBroadcastSerializedRowsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDBroadcastSerializedRowsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDBroadcastSerializedRowsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("broadcast_serialized_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_render_query<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDStartRenderQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_render_query(args.session, args.widget_id, args.node_idx, args.vega_json) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDStartRenderQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDStartRenderQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("start_render_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_next_render_step<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDExecuteNextRenderStepArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_next_render_step(args.pending_render, args.merged_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDExecuteNextRenderStepResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDExecuteNextRenderStepResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("execute_next_render_step", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_data<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDInsertDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_data(args.session, args.insert_data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDInsertDataResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDInsertDataResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("insert_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_checkpoint<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDCheckpointArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_checkpoint(args.session, args.db_id, args.table_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDCheckpointResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDCheckpointResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("checkpoint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_roles<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetRolesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_roles(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetRolesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetRolesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_db_objects_for_grantee<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDbObjectsForGranteeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_db_objects_for_grantee(args.session, args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDbObjectsForGranteeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDbObjectsForGranteeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_db_objects_for_grantee", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_db_object_privs<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDbObjectPrivsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_db_object_privs(args.session, args.object_name, args.type_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDbObjectPrivsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDbObjectPrivsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_db_object_privs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_roles_for_user<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetAllRolesForUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_roles_for_user(args.session, args.user_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetAllRolesForUserResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetAllRolesForUserResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_roles_for_user", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_role<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDHasRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_role(args.session, args.grantee_name, args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDHasRoleResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDHasRoleResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("has_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("has_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_object_privilege<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDHasObjectPrivilegeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_object_privilege(args.session, args.grantee_name, args.object_name, args.object_type, args.permissions) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDHasObjectPrivilegeResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDHasObjectPrivilegeResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("has_object_privilege", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_license_key<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDSetLicenseKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_license_key(args.session, args.key, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDSetLicenseKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDSetLicenseKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("set_license_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_license_claims<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetLicenseClaimsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_license_claims(args.session, args.nonce) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetLicenseClaimsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetLicenseClaimsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_license_claims", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_device_parameters<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDGetDeviceParametersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_device_parameters(args.session) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDGetDeviceParametersResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDGetDeviceParametersResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("get_device_parameters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_register_runtime_extension_functions<H: MapDSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = MapDRegisterRuntimeExtensionFunctionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_runtime_extension_functions(args.session, args.udfs, args.udtfs, args.device_ir_map) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = MapDRegisterRuntimeExtensionFunctionsResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<TMapDException>().is_some() {
              let err = usr_err.downcast::<TMapDException>().expect("downcast already checked");
              let ret_err = MapDRegisterRuntimeExtensionFunctionsResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("register_runtime_extension_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: MapDSyncHandler> TProcessor for MapDSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "connect" => {
        self.process_connect(message_ident.sequence_number, i_prot, o_prot)
      },
      "krb5_connect" => {
        self.process_krb5_connect(message_ident.sequence_number, i_prot, o_prot)
      },
      "disconnect" => {
        self.process_disconnect(message_ident.sequence_number, i_prot, o_prot)
      },
      "switch_database" => {
        self.process_switch_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_server_status" => {
        self.process_get_server_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_status" => {
        self.process_get_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_hardware_info" => {
        self.process_get_hardware_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables" => {
        self.process_get_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_physical_tables" => {
        self.process_get_physical_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_views" => {
        self.process_get_views(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables_meta" => {
        self.process_get_tables_meta(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_details" => {
        self.process_get_table_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_internal_table_details" => {
        self.process_get_internal_table_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_users" => {
        self.process_get_users(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_databases" => {
        self.process_get_databases(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_version" => {
        self.process_get_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_heap_profile" => {
        self.process_start_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "stop_heap_profile" => {
        self.process_stop_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_heap_profile" => {
        self.process_get_heap_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_memory" => {
        self.process_get_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_cpu_memory" => {
        self.process_clear_cpu_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_gpu_memory" => {
        self.process_clear_gpu_memory(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epoch" => {
        self.process_set_table_epoch(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_table_epoch_by_name" => {
        self.process_set_table_epoch_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epoch" => {
        self.process_get_table_epoch(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_epoch_by_name" => {
        self.process_get_table_epoch_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_session_info" => {
        self.process_get_session_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute" => {
        self.process_sql_execute(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute_df" => {
        self.process_sql_execute_df(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_execute_gdf" => {
        self.process_sql_execute_gdf(message_ident.sequence_number, i_prot, o_prot)
      },
      "deallocate_df" => {
        self.process_deallocate_df(message_ident.sequence_number, i_prot, o_prot)
      },
      "interrupt" => {
        self.process_interrupt(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_validate" => {
        self.process_sql_validate(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_completion_hints" => {
        self.process_get_completion_hints(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_execution_mode" => {
        self.process_set_execution_mode(message_ident.sequence_number, i_prot, o_prot)
      },
      "render_vega" => {
        self.process_render_vega(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_result_row_for_pixel" => {
        self.process_get_result_row_for_pixel(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboard" => {
        self.process_get_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboards" => {
        self.process_get_dashboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_dashboard" => {
        self.process_create_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "replace_dashboard" => {
        self.process_replace_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_dashboard" => {
        self.process_delete_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "share_dashboard" => {
        self.process_share_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "unshare_dashboard" => {
        self.process_unshare_dashboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_dashboard_grantees" => {
        self.process_get_dashboard_grantees(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_link_view" => {
        self.process_get_link_view(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_link" => {
        self.process_create_link(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary" => {
        self.process_load_table_binary(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_columnar" => {
        self.process_load_table_binary_columnar(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table_binary_arrow" => {
        self.process_load_table_binary_arrow(message_ident.sequence_number, i_prot, o_prot)
      },
      "load_table" => {
        self.process_load_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "detect_column_types" => {
        self.process_detect_column_types(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_table" => {
        self.process_create_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_table" => {
        self.process_import_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_geo_table" => {
        self.process_import_geo_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_table_status" => {
        self.process_import_table_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_first_geo_file_in_archive" => {
        self.process_get_first_geo_file_in_archive(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_files_in_archive" => {
        self.process_get_all_files_in_archive(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_layers_in_geo_file" => {
        self.process_get_layers_in_geo_file(message_ident.sequence_number, i_prot, o_prot)
      },
      "check_table_consistency" => {
        self.process_check_table_consistency(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_query" => {
        self.process_start_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "execute_query_step" => {
        self.process_execute_query_step(message_ident.sequence_number, i_prot, o_prot)
      },
      "broadcast_serialized_rows" => {
        self.process_broadcast_serialized_rows(message_ident.sequence_number, i_prot, o_prot)
      },
      "start_render_query" => {
        self.process_start_render_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "execute_next_render_step" => {
        self.process_execute_next_render_step(message_ident.sequence_number, i_prot, o_prot)
      },
      "insert_data" => {
        self.process_insert_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "checkpoint" => {
        self.process_checkpoint(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_roles" => {
        self.process_get_roles(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_db_objects_for_grantee" => {
        self.process_get_db_objects_for_grantee(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_db_object_privs" => {
        self.process_get_db_object_privs(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_roles_for_user" => {
        self.process_get_all_roles_for_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_role" => {
        self.process_has_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_object_privilege" => {
        self.process_has_object_privilege(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_license_key" => {
        self.process_set_license_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_license_claims" => {
        self.process_get_license_claims(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_device_parameters" => {
        self.process_get_device_parameters(message_ident.sequence_number, i_prot, o_prot)
      },
      "register_runtime_extension_functions" => {
        self.process_register_runtime_extension_functions(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// MapDConnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDConnectArgs {
  user: String,
  passwd: String,
  dbname: String,
}

impl MapDConnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDConnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDConnectArgs.user", &f_1)?;
    verify_required_field_exists("MapDConnectArgs.passwd", &f_2)?;
    verify_required_field_exists("MapDConnectArgs.dbname", &f_3)?;
    let ret = MapDConnectArgs {
      user: f_1.expect("auto-generated code should have checked for presence of required fields"),
      passwd: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("passwd", TType::String, 2))?;
    o_prot.write_string(&self.passwd)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 3))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDConnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDConnectResult {
  result_value: Option<TSessionId>,
  e: Option<TMapDException>,
}

impl MapDConnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDConnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionId> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDConnectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDConnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionId> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDConnect"
          )
        )
      )
    }
  }
}

//
// MapDKrb5ConnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDKrb5ConnectArgs {
  input_token: String,
  dbname: String,
}

impl MapDKrb5ConnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDKrb5ConnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDKrb5ConnectArgs.input_token", &f_1)?;
    verify_required_field_exists("MapDKrb5ConnectArgs.dbname", &f_2)?;
    let ret = MapDKrb5ConnectArgs {
      input_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("krb5_connect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("inputToken", TType::String, 1))?;
    o_prot.write_string(&self.input_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDKrb5ConnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDKrb5ConnectResult {
  result_value: Option<TKrb5Session>,
  e: Option<TMapDException>,
}

impl MapDKrb5ConnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDKrb5ConnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TKrb5Session> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TKrb5Session::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDKrb5ConnectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDKrb5ConnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TKrb5Session> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDKrb5Connect"
          )
        )
      )
    }
  }
}

//
// MapDDisconnectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDisconnectArgs {
  session: TSessionId,
}

impl MapDDisconnectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDisconnectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDDisconnectArgs.session", &f_1)?;
    let ret = MapDDisconnectArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("disconnect_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDDisconnectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDisconnectResult {
  e: Option<TMapDException>,
}

impl MapDDisconnectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDisconnectResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDDisconnectResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDDisconnectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDSwitchDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSwitchDatabaseArgs {
  session: TSessionId,
  dbname: String,
}

impl MapDSwitchDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSwitchDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSwitchDatabaseArgs.session", &f_1)?;
    verify_required_field_exists("MapDSwitchDatabaseArgs.dbname", &f_2)?;
    let ret = MapDSwitchDatabaseArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("switch_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSwitchDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSwitchDatabaseResult {
  e: Option<TMapDException>,
}

impl MapDSwitchDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSwitchDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSwitchDatabaseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSwitchDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDGetServerStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetServerStatusArgs {
  session: TSessionId,
}

impl MapDGetServerStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetServerStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetServerStatusArgs.session", &f_1)?;
    let ret = MapDGetServerStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_server_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetServerStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetServerStatusResult {
  result_value: Option<TServerStatus>,
  e: Option<TMapDException>,
}

impl MapDGetServerStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetServerStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TServerStatus> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TServerStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetServerStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetServerStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TServerStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetServerStatus"
          )
        )
      )
    }
  }
}

//
// MapDGetStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetStatusArgs {
  session: TSessionId,
}

impl MapDGetStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetStatusArgs.session", &f_1)?;
    let ret = MapDGetStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetStatusResult {
  result_value: Option<Vec<TServerStatus>>,
  e: Option<TMapDException>,
}

impl MapDGetStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TServerStatus>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TServerStatus> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = TServerStatus::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TServerStatus>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetStatus"
          )
        )
      )
    }
  }
}

//
// MapDGetHardwareInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetHardwareInfoArgs {
  session: TSessionId,
}

impl MapDGetHardwareInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetHardwareInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetHardwareInfoArgs.session", &f_1)?;
    let ret = MapDGetHardwareInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_hardware_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetHardwareInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetHardwareInfoResult {
  result_value: Option<TClusterHardwareInfo>,
  e: Option<TMapDException>,
}

impl MapDGetHardwareInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetHardwareInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TClusterHardwareInfo> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TClusterHardwareInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetHardwareInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetHardwareInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TClusterHardwareInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetHardwareInfo"
          )
        )
      )
    }
  }
}

//
// MapDGetTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTablesArgs {
  session: TSessionId,
}

impl MapDGetTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetTablesArgs.session", &f_1)?;
    let ret = MapDGetTablesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTablesResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = i_prot.read_string()?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetTablesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetTables"
          )
        )
      )
    }
  }
}

//
// MapDGetPhysicalTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetPhysicalTablesArgs {
  session: TSessionId,
}

impl MapDGetPhysicalTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetPhysicalTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetPhysicalTablesArgs.session", &f_1)?;
    let ret = MapDGetPhysicalTablesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_physical_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetPhysicalTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetPhysicalTablesResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetPhysicalTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetPhysicalTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_string()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetPhysicalTablesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetPhysicalTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetPhysicalTables"
          )
        )
      )
    }
  }
}

//
// MapDGetViewsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetViewsArgs {
  session: TSessionId,
}

impl MapDGetViewsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetViewsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetViewsArgs.session", &f_1)?;
    let ret = MapDGetViewsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_views_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetViewsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetViewsResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetViewsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetViewsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = i_prot.read_string()?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetViewsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetViewsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetViews"
          )
        )
      )
    }
  }
}

//
// MapDGetTablesMetaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTablesMetaArgs {
  session: TSessionId,
}

impl MapDGetTablesMetaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTablesMetaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetTablesMetaArgs.session", &f_1)?;
    let ret = MapDGetTablesMetaArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_meta_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetTablesMetaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTablesMetaResult {
  result_value: Option<Vec<TTableMeta>>,
  e: Option<TMapDException>,
}

impl MapDGetTablesMetaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTablesMetaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TTableMeta>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableMeta> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = TTableMeta::read_from_in_protocol(i_prot)?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetTablesMetaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetTablesMetaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TTableMeta>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetTablesMeta"
          )
        )
      )
    }
  }
}

//
// MapDGetTableDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTableDetailsArgs {
  session: TSessionId,
  table_name: String,
}

impl MapDGetTableDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTableDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetTableDetailsArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetTableDetailsArgs.table_name", &f_2)?;
    let ret = MapDGetTableDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetTableDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTableDetailsResult {
  result_value: Option<TTableDetails>,
  e: Option<TMapDException>,
}

impl MapDGetTableDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTableDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetTableDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetTableDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetTableDetails"
          )
        )
      )
    }
  }
}

//
// MapDGetInternalTableDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetInternalTableDetailsArgs {
  session: TSessionId,
  table_name: String,
}

impl MapDGetInternalTableDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetInternalTableDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetInternalTableDetailsArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetInternalTableDetailsArgs.table_name", &f_2)?;
    let ret = MapDGetInternalTableDetailsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_internal_table_details_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetInternalTableDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetInternalTableDetailsResult {
  result_value: Option<TTableDetails>,
  e: Option<TMapDException>,
}

impl MapDGetInternalTableDetailsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetInternalTableDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDetails> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableDetails::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetInternalTableDetailsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetInternalTableDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDetails> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetInternalTableDetails"
          )
        )
      )
    }
  }
}

//
// MapDGetUsersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetUsersArgs {
  session: TSessionId,
}

impl MapDGetUsersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetUsersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetUsersArgs.session", &f_1)?;
    let ret = MapDGetUsersArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_users_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetUsersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetUsersResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetUsersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetUsersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = i_prot.read_string()?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetUsersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetUsersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetUsers"
          )
        )
      )
    }
  }
}

//
// MapDGetDatabasesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDatabasesArgs {
  session: TSessionId,
}

impl MapDGetDatabasesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDatabasesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDatabasesArgs.session", &f_1)?;
    let ret = MapDGetDatabasesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_databases_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDatabasesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDatabasesResult {
  result_value: Option<Vec<TDBInfo>>,
  e: Option<TMapDException>,
}

impl MapDGetDatabasesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDatabasesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBInfo>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = TDBInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDatabasesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDatabasesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDatabases"
          )
        )
      )
    }
  }
}

//
// MapDGetVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetVersionArgs {
}

impl MapDGetVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetVersionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetVersionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetVersionResult {
  result_value: Option<String>,
  e: Option<TMapDException>,
}

impl MapDGetVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetVersionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetVersion"
          )
        )
      )
    }
  }
}

//
// MapDStartHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStartHeapProfileArgs {
  session: TSessionId,
}

impl MapDStartHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStartHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDStartHeapProfileArgs.session", &f_1)?;
    let ret = MapDStartHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDStartHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStartHeapProfileResult {
  e: Option<TMapDException>,
}

impl MapDStartHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStartHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDStartHeapProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDStartHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDStopHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStopHeapProfileArgs {
  session: TSessionId,
}

impl MapDStopHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStopHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDStopHeapProfileArgs.session", &f_1)?;
    let ret = MapDStopHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("stop_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDStopHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStopHeapProfileResult {
  e: Option<TMapDException>,
}

impl MapDStopHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStopHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDStopHeapProfileResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDStopHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDGetHeapProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetHeapProfileArgs {
  session: TSessionId,
}

impl MapDGetHeapProfileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetHeapProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetHeapProfileArgs.session", &f_1)?;
    let ret = MapDGetHeapProfileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_heap_profile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetHeapProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetHeapProfileResult {
  result_value: Option<String>,
  e: Option<TMapDException>,
}

impl MapDGetHeapProfileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetHeapProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetHeapProfileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetHeapProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetHeapProfile"
          )
        )
      )
    }
  }
}

//
// MapDGetMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetMemoryArgs {
  session: TSessionId,
  memory_level: String,
}

impl MapDGetMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetMemoryArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetMemoryArgs.memory_level", &f_2)?;
    let ret = MapDGetMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      memory_level: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("memory_level", TType::String, 2))?;
    o_prot.write_string(&self.memory_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetMemoryResult {
  result_value: Option<Vec<TNodeMemoryInfo>>,
  e: Option<TMapDException>,
}

impl MapDGetMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TNodeMemoryInfo>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TNodeMemoryInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = TNodeMemoryInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetMemoryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TNodeMemoryInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetMemory"
          )
        )
      )
    }
  }
}

//
// MapDClearCpuMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDClearCpuMemoryArgs {
  session: TSessionId,
}

impl MapDClearCpuMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDClearCpuMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDClearCpuMemoryArgs.session", &f_1)?;
    let ret = MapDClearCpuMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_cpu_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDClearCpuMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDClearCpuMemoryResult {
  e: Option<TMapDException>,
}

impl MapDClearCpuMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDClearCpuMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDClearCpuMemoryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDClearCpuMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDClearGpuMemoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDClearGpuMemoryArgs {
  session: TSessionId,
}

impl MapDClearGpuMemoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDClearGpuMemoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDClearGpuMemoryArgs.session", &f_1)?;
    let ret = MapDClearGpuMemoryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_gpu_memory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDClearGpuMemoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDClearGpuMemoryResult {
  e: Option<TMapDException>,
}

impl MapDClearGpuMemoryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDClearGpuMemoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDClearGpuMemoryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDClearGpuMemoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDSetTableEpochArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetTableEpochArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
  new_epoch: i32,
}

impl MapDSetTableEpochArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetTableEpochArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSetTableEpochArgs.session", &f_1)?;
    verify_required_field_exists("MapDSetTableEpochArgs.db_id", &f_2)?;
    verify_required_field_exists("MapDSetTableEpochArgs.table_id", &f_3)?;
    verify_required_field_exists("MapDSetTableEpochArgs.new_epoch", &f_4)?;
    let ret = MapDSetTableEpochArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      new_epoch: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epoch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_epoch", TType::I32, 4))?;
    o_prot.write_i32(self.new_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSetTableEpochResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetTableEpochResult {
  e: Option<TMapDException>,
}

impl MapDSetTableEpochResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetTableEpochResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSetTableEpochResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSetTableEpochResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDSetTableEpochByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetTableEpochByNameArgs {
  session: TSessionId,
  table_name: String,
  new_epoch: i32,
}

impl MapDSetTableEpochByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetTableEpochByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSetTableEpochByNameArgs.session", &f_1)?;
    verify_required_field_exists("MapDSetTableEpochByNameArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDSetTableEpochByNameArgs.new_epoch", &f_3)?;
    let ret = MapDSetTableEpochByNameArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_epoch: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_table_epoch_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_epoch", TType::I32, 3))?;
    o_prot.write_i32(self.new_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSetTableEpochByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetTableEpochByNameResult {
  e: Option<TMapDException>,
}

impl MapDSetTableEpochByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetTableEpochByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSetTableEpochByNameResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSetTableEpochByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDGetTableEpochArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTableEpochArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
}

impl MapDGetTableEpochArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTableEpochArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetTableEpochArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetTableEpochArgs.db_id", &f_2)?;
    verify_required_field_exists("MapDGetTableEpochArgs.table_id", &f_3)?;
    let ret = MapDGetTableEpochArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epoch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetTableEpochResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTableEpochResult {
  result_value: Option<i32>,
}

impl MapDGetTableEpochResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTableEpochResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetTableEpochResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetTableEpochResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetTableEpoch"
          )
        )
      )
    }
  }
}

//
// MapDGetTableEpochByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTableEpochByNameArgs {
  session: TSessionId,
  table_name: String,
}

impl MapDGetTableEpochByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTableEpochByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetTableEpochByNameArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetTableEpochByNameArgs.table_name", &f_2)?;
    let ret = MapDGetTableEpochByNameArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_epoch_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetTableEpochByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetTableEpochByNameResult {
  result_value: Option<i32>,
}

impl MapDGetTableEpochByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetTableEpochByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetTableEpochByNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetTableEpochByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetTableEpochByName"
          )
        )
      )
    }
  }
}

//
// MapDGetSessionInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetSessionInfoArgs {
  session: TSessionId,
}

impl MapDGetSessionInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetSessionInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetSessionInfoArgs.session", &f_1)?;
    let ret = MapDGetSessionInfoArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_session_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetSessionInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetSessionInfoResult {
  result_value: Option<TSessionInfo>,
  e: Option<TMapDException>,
}

impl MapDGetSessionInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetSessionInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSessionInfo> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSessionInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetSessionInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetSessionInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSessionInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetSessionInfo"
          )
        )
      )
    }
  }
}

//
// MapDSqlExecuteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlExecuteArgs {
  session: TSessionId,
  query: String,
  column_format: bool,
  nonce: String,
  first_n: i32,
  at_most_n: i32,
}

impl MapDSqlExecuteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlExecuteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSqlExecuteArgs.session", &f_1)?;
    verify_required_field_exists("MapDSqlExecuteArgs.query", &f_2)?;
    verify_required_field_exists("MapDSqlExecuteArgs.column_format", &f_3)?;
    verify_required_field_exists("MapDSqlExecuteArgs.nonce", &f_4)?;
    verify_required_field_exists("MapDSqlExecuteArgs.first_n", &f_5)?;
    verify_required_field_exists("MapDSqlExecuteArgs.at_most_n", &f_6)?;
    let ret = MapDSqlExecuteArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_format: f_3.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_4.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_5.expect("auto-generated code should have checked for presence of required fields"),
      at_most_n: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_format", TType::Bool, 3))?;
    o_prot.write_bool(self.column_format)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 4))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 5))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("at_most_n", TType::I32, 6))?;
    o_prot.write_i32(self.at_most_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSqlExecuteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlExecuteResult {
  result_value: Option<TQueryResult>,
  e: Option<TMapDException>,
}

impl MapDSqlExecuteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlExecuteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TQueryResult> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TQueryResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSqlExecuteResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSqlExecuteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TQueryResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDSqlExecute"
          )
        )
      )
    }
  }
}

//
// MapDSqlExecuteDfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlExecuteDfArgs {
  session: TSessionId,
  query: String,
  device_type: common::TDeviceType,
  device_id: i32,
  first_n: i32,
}

impl MapDSqlExecuteDfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlExecuteDfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<common::TDeviceType> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSqlExecuteDfArgs.session", &f_1)?;
    verify_required_field_exists("MapDSqlExecuteDfArgs.query", &f_2)?;
    verify_required_field_exists("MapDSqlExecuteDfArgs.device_type", &f_3)?;
    verify_required_field_exists("MapDSqlExecuteDfArgs.device_id", &f_4)?;
    verify_required_field_exists("MapDSqlExecuteDfArgs.first_n", &f_5)?;
    let ret = MapDSqlExecuteDfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_df_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 3))?;
    self.device_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 4))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 5))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSqlExecuteDfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlExecuteDfResult {
  result_value: Option<TDataFrame>,
  e: Option<TMapDException>,
}

impl MapDSqlExecuteDfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlExecuteDfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDataFrame> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSqlExecuteDfResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSqlExecuteDfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDataFrame> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDSqlExecuteDf"
          )
        )
      )
    }
  }
}

//
// MapDSqlExecuteGdfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlExecuteGdfArgs {
  session: TSessionId,
  query: String,
  device_id: i32,
  first_n: i32,
}

impl MapDSqlExecuteGdfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlExecuteGdfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSqlExecuteGdfArgs.session", &f_1)?;
    verify_required_field_exists("MapDSqlExecuteGdfArgs.query", &f_2)?;
    verify_required_field_exists("MapDSqlExecuteGdfArgs.device_id", &f_3)?;
    verify_required_field_exists("MapDSqlExecuteGdfArgs.first_n", &f_4)?;
    let ret = MapDSqlExecuteGdfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      first_n: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_execute_gdf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 3))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_n", TType::I32, 4))?;
    o_prot.write_i32(self.first_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSqlExecuteGdfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlExecuteGdfResult {
  result_value: Option<TDataFrame>,
  e: Option<TMapDException>,
}

impl MapDSqlExecuteGdfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlExecuteGdfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDataFrame> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSqlExecuteGdfResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSqlExecuteGdfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDataFrame> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDSqlExecuteGdf"
          )
        )
      )
    }
  }
}

//
// MapDDeallocateDfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDeallocateDfArgs {
  session: TSessionId,
  df: TDataFrame,
  device_type: common::TDeviceType,
  device_id: i32,
}

impl MapDDeallocateDfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDeallocateDfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TDataFrame> = None;
    let mut f_3: Option<common::TDeviceType> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDataFrame::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::TDeviceType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDDeallocateDfArgs.session", &f_1)?;
    verify_required_field_exists("MapDDeallocateDfArgs.df", &f_2)?;
    verify_required_field_exists("MapDDeallocateDfArgs.device_type", &f_3)?;
    verify_required_field_exists("MapDDeallocateDfArgs.device_id", &f_4)?;
    let ret = MapDDeallocateDfArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      df: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deallocate_df_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("df", TType::Struct, 2))?;
    self.df.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_type", TType::I32, 3))?;
    self.device_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_id", TType::I32, 4))?;
    o_prot.write_i32(self.device_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDDeallocateDfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDeallocateDfResult {
  e: Option<TMapDException>,
}

impl MapDDeallocateDfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDeallocateDfResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDDeallocateDfResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDDeallocateDfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDInterruptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDInterruptArgs {
  session: TSessionId,
}

impl MapDInterruptArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDInterruptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDInterruptArgs.session", &f_1)?;
    let ret = MapDInterruptArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("interrupt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDInterruptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDInterruptResult {
  e: Option<TMapDException>,
}

impl MapDInterruptResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDInterruptResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDInterruptResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDInterruptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDSqlValidateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlValidateArgs {
  session: TSessionId,
  query: String,
}

impl MapDSqlValidateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlValidateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSqlValidateArgs.session", &f_1)?;
    verify_required_field_exists("MapDSqlValidateArgs.query", &f_2)?;
    let ret = MapDSqlValidateArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_validate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSqlValidateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSqlValidateResult {
  result_value: Option<TTableDescriptor>,
  e: Option<TMapDException>,
}

impl MapDSqlValidateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSqlValidateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableDescriptor> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TColumnType> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_48 = i_prot.read_string()?;
            let map_val_49 = TColumnType::read_from_in_protocol(i_prot)?;
            val.insert(map_key_48, map_val_49);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSqlValidateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSqlValidateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableDescriptor> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDSqlValidate"
          )
        )
      )
    }
  }
}

//
// MapDGetCompletionHintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetCompletionHintsArgs {
  session: TSessionId,
  sql: String,
  cursor: i32,
}

impl MapDGetCompletionHintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetCompletionHintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetCompletionHintsArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetCompletionHintsArgs.sql", &f_2)?;
    verify_required_field_exists("MapDGetCompletionHintsArgs.cursor", &f_3)?;
    let ret = MapDGetCompletionHintsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sql: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cursor: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_completion_hints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 2))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cursor", TType::I32, 3))?;
    o_prot.write_i32(self.cursor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetCompletionHintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetCompletionHintsResult {
  result_value: Option<Vec<completion_hints::TCompletionHint>>,
  e: Option<TMapDException>,
}

impl MapDGetCompletionHintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetCompletionHintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<completion_hints::TCompletionHint>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<completion_hints::TCompletionHint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = completion_hints::TCompletionHint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetCompletionHintsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetCompletionHintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<completion_hints::TCompletionHint>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetCompletionHints"
          )
        )
      )
    }
  }
}

//
// MapDSetExecutionModeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetExecutionModeArgs {
  session: TSessionId,
  mode: TExecuteMode,
}

impl MapDSetExecutionModeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetExecutionModeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TExecuteMode> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TExecuteMode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSetExecutionModeArgs.session", &f_1)?;
    verify_required_field_exists("MapDSetExecutionModeArgs.mode", &f_2)?;
    let ret = MapDSetExecutionModeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mode: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_execution_mode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mode", TType::I32, 2))?;
    self.mode.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSetExecutionModeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetExecutionModeResult {
  e: Option<TMapDException>,
}

impl MapDSetExecutionModeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetExecutionModeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSetExecutionModeResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSetExecutionModeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDRenderVegaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDRenderVegaArgs {
  session: TSessionId,
  widget_id: i64,
  vega_json: String,
  compression_level: i32,
  nonce: String,
}

impl MapDRenderVegaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDRenderVegaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDRenderVegaArgs.session", &f_1)?;
    verify_required_field_exists("MapDRenderVegaArgs.widget_id", &f_2)?;
    verify_required_field_exists("MapDRenderVegaArgs.vega_json", &f_3)?;
    verify_required_field_exists("MapDRenderVegaArgs.compression_level", &f_4)?;
    verify_required_field_exists("MapDRenderVegaArgs.nonce", &f_5)?;
    let ret = MapDRenderVegaArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      vega_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      compression_level: f_4.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("render_vega_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("vega_json", TType::String, 3))?;
    o_prot.write_string(&self.vega_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compression_level", TType::I32, 4))?;
    o_prot.write_i32(self.compression_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 5))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDRenderVegaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDRenderVegaResult {
  result_value: Option<TRenderResult>,
  e: Option<TMapDException>,
}

impl MapDRenderVegaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDRenderVegaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenderResult> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenderResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDRenderVegaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDRenderVegaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenderResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDRenderVega"
          )
        )
      )
    }
  }
}

//
// MapDGetResultRowForPixelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetResultRowForPixelArgs {
  session: TSessionId,
  widget_id: i64,
  pixel: TPixel,
  table_col_names: BTreeMap<String, Vec<String>>,
  column_format: bool,
  pixel_radius: i32,
  nonce: String,
}

impl MapDGetResultRowForPixelArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetResultRowForPixelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<TPixel> = None;
    let mut f_4: Option<BTreeMap<String, Vec<String>>> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TPixel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<String>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_51 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_52: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_53 = i_prot.read_string()?;
              map_val_52.push(list_elem_53);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_51, map_val_52);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.widget_id", &f_2)?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.pixel", &f_3)?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.table_col_names", &f_4)?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.column_format", &f_5)?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.pixel_radius", &f_6)?;
    verify_required_field_exists("MapDGetResultRowForPixelArgs.nonce", &f_7)?;
    let ret = MapDGetResultRowForPixelArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pixel: f_3.expect("auto-generated code should have checked for presence of required fields"),
      table_col_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
      column_format: f_5.expect("auto-generated code should have checked for presence of required fields"),
      pixel_radius: f_6.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_result_row_for_pixel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pixel", TType::Struct, 3))?;
    self.pixel.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_col_names", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, self.table_col_names.len() as i32))?;
    for (k, v) in &self.table_col_names {
      o_prot.write_string(k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, v.len() as i32))?;
      for e in v {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_format", TType::Bool, 5))?;
    o_prot.write_bool(self.column_format)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pixelRadius", TType::I32, 6))?;
    o_prot.write_i32(self.pixel_radius)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 7))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetResultRowForPixelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetResultRowForPixelResult {
  result_value: Option<TPixelTableRowResult>,
  e: Option<TMapDException>,
}

impl MapDGetResultRowForPixelResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetResultRowForPixelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPixelTableRowResult> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPixelTableRowResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetResultRowForPixelResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetResultRowForPixelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPixelTableRowResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetRowForPixelResult"
          )
        )
      )
    }
  }
}

//
// MapDGetDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl MapDGetDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDashboardArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetDashboardArgs.dashboard_id", &f_2)?;
    let ret = MapDGetDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDashboardResult {
  result_value: Option<TDashboard>,
  e: Option<TMapDException>,
}

impl MapDGetDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDashboard> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDashboard::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDashboardResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDashboard> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDashboard"
          )
        )
      )
    }
  }
}

//
// MapDGetDashboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDashboardsArgs {
  session: TSessionId,
}

impl MapDGetDashboardsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDashboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDashboardsArgs.session", &f_1)?;
    let ret = MapDGetDashboardsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDashboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDashboardsResult {
  result_value: Option<Vec<TDashboard>>,
  e: Option<TMapDException>,
}

impl MapDGetDashboardsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDashboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDashboard>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDashboard> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = TDashboard::read_from_in_protocol(i_prot)?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDashboardsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDashboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDashboard>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDashboards"
          )
        )
      )
    }
  }
}

//
// MapDCreateDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCreateDashboardArgs {
  session: TSessionId,
  dashboard_name: String,
  dashboard_state: String,
  image_hash: String,
  dashboard_metadata: String,
}

impl MapDCreateDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCreateDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDCreateDashboardArgs.session", &f_1)?;
    verify_required_field_exists("MapDCreateDashboardArgs.dashboard_name", &f_2)?;
    verify_required_field_exists("MapDCreateDashboardArgs.dashboard_state", &f_3)?;
    verify_required_field_exists("MapDCreateDashboardArgs.image_hash", &f_4)?;
    verify_required_field_exists("MapDCreateDashboardArgs.dashboard_metadata", &f_5)?;
    let ret = MapDCreateDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_state: f_3.expect("auto-generated code should have checked for presence of required fields"),
      image_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_metadata: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 2))?;
    o_prot.write_string(&self.dashboard_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 3))?;
    o_prot.write_string(&self.dashboard_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 4))?;
    o_prot.write_string(&self.image_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 5))?;
    o_prot.write_string(&self.dashboard_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDCreateDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCreateDashboardResult {
  result_value: Option<i32>,
  e: Option<TMapDException>,
}

impl MapDCreateDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCreateDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDCreateDashboardResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDCreateDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDCreateDashboard"
          )
        )
      )
    }
  }
}

//
// MapDReplaceDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDReplaceDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  dashboard_name: String,
  dashboard_owner: String,
  dashboard_state: String,
  image_hash: String,
  dashboard_metadata: String,
}

impl MapDReplaceDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDReplaceDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDReplaceDashboardArgs.session", &f_1)?;
    verify_required_field_exists("MapDReplaceDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("MapDReplaceDashboardArgs.dashboard_name", &f_3)?;
    verify_required_field_exists("MapDReplaceDashboardArgs.dashboard_owner", &f_4)?;
    verify_required_field_exists("MapDReplaceDashboardArgs.dashboard_state", &f_5)?;
    verify_required_field_exists("MapDReplaceDashboardArgs.image_hash", &f_6)?;
    verify_required_field_exists("MapDReplaceDashboardArgs.dashboard_metadata", &f_7)?;
    let ret = MapDReplaceDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_owner: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_state: f_5.expect("auto-generated code should have checked for presence of required fields"),
      image_hash: f_6.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_metadata: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("replace_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_name", TType::String, 3))?;
    o_prot.write_string(&self.dashboard_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_owner", TType::String, 4))?;
    o_prot.write_string(&self.dashboard_owner)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_state", TType::String, 5))?;
    o_prot.write_string(&self.dashboard_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("image_hash", TType::String, 6))?;
    o_prot.write_string(&self.image_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_metadata", TType::String, 7))?;
    o_prot.write_string(&self.dashboard_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDReplaceDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDReplaceDashboardResult {
  e: Option<TMapDException>,
}

impl MapDReplaceDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDReplaceDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDReplaceDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDReplaceDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDDeleteDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDeleteDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl MapDDeleteDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDeleteDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDDeleteDashboardArgs.session", &f_1)?;
    verify_required_field_exists("MapDDeleteDashboardArgs.dashboard_id", &f_2)?;
    let ret = MapDDeleteDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDDeleteDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDeleteDashboardResult {
  e: Option<TMapDException>,
}

impl MapDDeleteDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDeleteDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDDeleteDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDDeleteDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDShareDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDShareDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  groups: Vec<String>,
  objects: Vec<String>,
  permissions: TDashboardPermissions,
  grant_role: bool,
}

impl MapDShareDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDShareDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<TDashboardPermissions> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = i_prot.read_string()?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = i_prot.read_string()?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDShareDashboardArgs.session", &f_1)?;
    verify_required_field_exists("MapDShareDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("MapDShareDashboardArgs.groups", &f_3)?;
    verify_required_field_exists("MapDShareDashboardArgs.objects", &f_4)?;
    verify_required_field_exists("MapDShareDashboardArgs.permissions", &f_5)?;
    verify_required_field_exists("MapDShareDashboardArgs.grant_role", &f_6)?;
    let ret = MapDShareDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      objects: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
      grant_role: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("share_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objects", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.objects.len() as i32))?;
    for e in &self.objects {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grant_role", TType::Bool, 6))?;
    o_prot.write_bool(self.grant_role)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDShareDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDShareDashboardResult {
  e: Option<TMapDException>,
}

impl MapDShareDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDShareDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDShareDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDShareDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDUnshareDashboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDUnshareDashboardArgs {
  session: TSessionId,
  dashboard_id: i32,
  groups: Vec<String>,
  objects: Vec<String>,
  permissions: TDashboardPermissions,
}

impl MapDUnshareDashboardArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDUnshareDashboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<TDashboardPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = i_prot.read_string()?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = i_prot.read_string()?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDashboardPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDUnshareDashboardArgs.session", &f_1)?;
    verify_required_field_exists("MapDUnshareDashboardArgs.dashboard_id", &f_2)?;
    verify_required_field_exists("MapDUnshareDashboardArgs.groups", &f_3)?;
    verify_required_field_exists("MapDUnshareDashboardArgs.objects", &f_4)?;
    verify_required_field_exists("MapDUnshareDashboardArgs.permissions", &f_5)?;
    let ret = MapDUnshareDashboardArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      groups: f_3.expect("auto-generated code should have checked for presence of required fields"),
      objects: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unshare_dashboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groups", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.groups.len() as i32))?;
    for e in &self.groups {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objects", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.objects.len() as i32))?;
    for e in &self.objects {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDUnshareDashboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDUnshareDashboardResult {
  e: Option<TMapDException>,
}

impl MapDUnshareDashboardResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDUnshareDashboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDUnshareDashboardResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDUnshareDashboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDGetDashboardGranteesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDashboardGranteesArgs {
  session: TSessionId,
  dashboard_id: i32,
}

impl MapDGetDashboardGranteesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDashboardGranteesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDashboardGranteesArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetDashboardGranteesArgs.dashboard_id", &f_2)?;
    let ret = MapDGetDashboardGranteesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dashboard_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_dashboard_grantees_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dashboard_id", TType::I32, 2))?;
    o_prot.write_i32(self.dashboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDashboardGranteesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDashboardGranteesResult {
  result_value: Option<Vec<TDashboardGrantees>>,
  e: Option<TMapDException>,
}

impl MapDGetDashboardGranteesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDashboardGranteesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDashboardGrantees>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDashboardGrantees> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = TDashboardGrantees::read_from_in_protocol(i_prot)?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDashboardGranteesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDashboardGranteesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDashboardGrantees>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDashboardGrantees"
          )
        )
      )
    }
  }
}

//
// MapDGetLinkViewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetLinkViewArgs {
  session: TSessionId,
  link: String,
}

impl MapDGetLinkViewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetLinkViewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetLinkViewArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetLinkViewArgs.link", &f_2)?;
    let ret = MapDGetLinkViewArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      link: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_link_view_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("link", TType::String, 2))?;
    o_prot.write_string(&self.link)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetLinkViewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetLinkViewResult {
  result_value: Option<TFrontendView>,
  e: Option<TMapDException>,
}

impl MapDGetLinkViewResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetLinkViewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TFrontendView> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TFrontendView::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetLinkViewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetLinkViewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TFrontendView> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetLinkView"
          )
        )
      )
    }
  }
}

//
// MapDCreateLinkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCreateLinkArgs {
  session: TSessionId,
  view_state: String,
  view_metadata: String,
}

impl MapDCreateLinkArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCreateLinkArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDCreateLinkArgs.session", &f_1)?;
    verify_required_field_exists("MapDCreateLinkArgs.view_state", &f_2)?;
    verify_required_field_exists("MapDCreateLinkArgs.view_metadata", &f_3)?;
    let ret = MapDCreateLinkArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      view_state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      view_metadata: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_link_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("view_state", TType::String, 2))?;
    o_prot.write_string(&self.view_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("view_metadata", TType::String, 3))?;
    o_prot.write_string(&self.view_metadata)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDCreateLinkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCreateLinkResult {
  result_value: Option<String>,
  e: Option<TMapDException>,
}

impl MapDCreateLinkResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCreateLinkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDCreateLinkResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDCreateLinkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDCreateLink"
          )
        )
      )
    }
  }
}

//
// MapDLoadTableBinaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableBinaryArgs {
  session: TSessionId,
  table_name: String,
  rows: Vec<TRow>,
}

impl MapDLoadTableBinaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableBinaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TRow>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = TRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDLoadTableBinaryArgs.session", &f_1)?;
    verify_required_field_exists("MapDLoadTableBinaryArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDLoadTableBinaryArgs.rows", &f_3)?;
    let ret = MapDLoadTableBinaryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDLoadTableBinaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableBinaryResult {
  e: Option<TMapDException>,
}

impl MapDLoadTableBinaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableBinaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDLoadTableBinaryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDLoadTableBinaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDLoadTableBinaryColumnarArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableBinaryColumnarArgs {
  session: TSessionId,
  table_name: String,
  cols: Vec<TColumn>,
}

impl MapDLoadTableBinaryColumnarArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableBinaryColumnarArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TColumn>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDLoadTableBinaryColumnarArgs.session", &f_1)?;
    verify_required_field_exists("MapDLoadTableBinaryColumnarArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDLoadTableBinaryColumnarArgs.cols", &f_3)?;
    let ret = MapDLoadTableBinaryColumnarArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cols: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_columnar_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.cols.len() as i32))?;
    for e in &self.cols {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDLoadTableBinaryColumnarResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableBinaryColumnarResult {
  e: Option<TMapDException>,
}

impl MapDLoadTableBinaryColumnarResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableBinaryColumnarResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDLoadTableBinaryColumnarResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDLoadTableBinaryColumnarResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDLoadTableBinaryArrowArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableBinaryArrowArgs {
  session: TSessionId,
  table_name: String,
  arrow_stream: Vec<u8>,
}

impl MapDLoadTableBinaryArrowArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableBinaryArrowArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDLoadTableBinaryArrowArgs.session", &f_1)?;
    verify_required_field_exists("MapDLoadTableBinaryArrowArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDLoadTableBinaryArrowArgs.arrow_stream", &f_3)?;
    let ret = MapDLoadTableBinaryArrowArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      arrow_stream: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_binary_arrow_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("arrow_stream", TType::String, 3))?;
    o_prot.write_bytes(&self.arrow_stream)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDLoadTableBinaryArrowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableBinaryArrowResult {
  e: Option<TMapDException>,
}

impl MapDLoadTableBinaryArrowResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableBinaryArrowResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDLoadTableBinaryArrowResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDLoadTableBinaryArrowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDLoadTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableArgs {
  session: TSessionId,
  table_name: String,
  rows: Vec<TStringRow>,
}

impl MapDLoadTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<TStringRow>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStringRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = TStringRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDLoadTableArgs.session", &f_1)?;
    verify_required_field_exists("MapDLoadTableArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDLoadTableArgs.rows", &f_3)?;
    let ret = MapDLoadTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("load_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.rows.len() as i32))?;
    for e in &self.rows {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDLoadTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDLoadTableResult {
  e: Option<TMapDException>,
}

impl MapDLoadTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDLoadTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDLoadTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDLoadTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDDetectColumnTypesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDetectColumnTypesArgs {
  session: TSessionId,
  file_name: String,
  copy_params: TCopyParams,
}

impl MapDDetectColumnTypesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDetectColumnTypesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDDetectColumnTypesArgs.session", &f_1)?;
    verify_required_field_exists("MapDDetectColumnTypesArgs.file_name", &f_2)?;
    verify_required_field_exists("MapDDetectColumnTypesArgs.copy_params", &f_3)?;
    let ret = MapDDetectColumnTypesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("detect_column_types_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 2))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDDetectColumnTypesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDDetectColumnTypesResult {
  result_value: Option<TDetectResult>,
  e: Option<TMapDException>,
}

impl MapDDetectColumnTypesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDDetectColumnTypesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TDetectResult> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TDetectResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDDetectColumnTypesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDDetectColumnTypesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TDetectResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDDetectColumnTypes"
          )
        )
      )
    }
  }
}

//
// MapDCreateTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCreateTableArgs {
  session: TSessionId,
  table_name: String,
  row_desc: TRowDescriptor,
  file_type: TFileType,
  create_params: TCreateParams,
}

impl MapDCreateTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCreateTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TRowDescriptor> = None;
    let mut f_4: Option<TFileType> = None;
    let mut f_5: Option<TCreateParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TFileType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TCreateParams::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDCreateTableArgs.session", &f_1)?;
    verify_required_field_exists("MapDCreateTableArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDCreateTableArgs.row_desc", &f_3)?;
    verify_required_field_exists("MapDCreateTableArgs.file_type", &f_4)?;
    verify_required_field_exists("MapDCreateTableArgs.create_params", &f_5)?;
    let ret = MapDCreateTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_3.expect("auto-generated code should have checked for presence of required fields"),
      file_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      create_params: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 4))?;
    self.file_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("create_params", TType::Struct, 5))?;
    self.create_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDCreateTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCreateTableResult {
  e: Option<TMapDException>,
}

impl MapDCreateTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCreateTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDCreateTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDCreateTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDImportTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDImportTableArgs {
  session: TSessionId,
  table_name: String,
  file_name: String,
  copy_params: TCopyParams,
}

impl MapDImportTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDImportTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDImportTableArgs.session", &f_1)?;
    verify_required_field_exists("MapDImportTableArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDImportTableArgs.file_name", &f_3)?;
    verify_required_field_exists("MapDImportTableArgs.copy_params", &f_4)?;
    let ret = MapDImportTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 3))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 4))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDImportTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDImportTableResult {
  e: Option<TMapDException>,
}

impl MapDImportTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDImportTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDImportTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDImportTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDImportGeoTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDImportGeoTableArgs {
  session: TSessionId,
  table_name: String,
  file_name: String,
  copy_params: TCopyParams,
  row_desc: TRowDescriptor,
  create_params: TCreateParams,
}

impl MapDImportGeoTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDImportGeoTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TCopyParams> = None;
    let mut f_5: Option<TRowDescriptor> = None;
    let mut f_6: Option<TCreateParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_64 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = TCreateParams::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDImportGeoTableArgs.session", &f_1)?;
    verify_required_field_exists("MapDImportGeoTableArgs.table_name", &f_2)?;
    verify_required_field_exists("MapDImportGeoTableArgs.file_name", &f_3)?;
    verify_required_field_exists("MapDImportGeoTableArgs.copy_params", &f_4)?;
    verify_required_field_exists("MapDImportGeoTableArgs.row_desc", &f_5)?;
    verify_required_field_exists("MapDImportGeoTableArgs.create_params", &f_6)?;
    let ret = MapDImportGeoTableArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_4.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_5.expect("auto-generated code should have checked for presence of required fields"),
      create_params: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_geo_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 3))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 4))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("create_params", TType::Struct, 6))?;
    self.create_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDImportGeoTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDImportGeoTableResult {
  e: Option<TMapDException>,
}

impl MapDImportGeoTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDImportGeoTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDImportGeoTableResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDImportGeoTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDImportTableStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDImportTableStatusArgs {
  session: TSessionId,
  import_id: String,
}

impl MapDImportTableStatusArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDImportTableStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDImportTableStatusArgs.session", &f_1)?;
    verify_required_field_exists("MapDImportTableStatusArgs.import_id", &f_2)?;
    let ret = MapDImportTableStatusArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      import_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_table_status_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("import_id", TType::String, 2))?;
    o_prot.write_string(&self.import_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDImportTableStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDImportTableStatusResult {
  result_value: Option<TImportStatus>,
  e: Option<TMapDException>,
}

impl MapDImportTableStatusResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDImportTableStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TImportStatus> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TImportStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDImportTableStatusResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDImportTableStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TImportStatus> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDImportTableStatus"
          )
        )
      )
    }
  }
}

//
// MapDGetFirstGeoFileInArchiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetFirstGeoFileInArchiveArgs {
  session: TSessionId,
  archive_path: String,
  copy_params: TCopyParams,
}

impl MapDGetFirstGeoFileInArchiveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetFirstGeoFileInArchiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetFirstGeoFileInArchiveArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetFirstGeoFileInArchiveArgs.archive_path", &f_2)?;
    verify_required_field_exists("MapDGetFirstGeoFileInArchiveArgs.copy_params", &f_3)?;
    let ret = MapDGetFirstGeoFileInArchiveArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      archive_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_first_geo_file_in_archive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("archive_path", TType::String, 2))?;
    o_prot.write_string(&self.archive_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetFirstGeoFileInArchiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetFirstGeoFileInArchiveResult {
  result_value: Option<String>,
  e: Option<TMapDException>,
}

impl MapDGetFirstGeoFileInArchiveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetFirstGeoFileInArchiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetFirstGeoFileInArchiveResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetFirstGeoFileInArchiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetFirstGeoFileInArchive"
          )
        )
      )
    }
  }
}

//
// MapDGetAllFilesInArchiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetAllFilesInArchiveArgs {
  session: TSessionId,
  archive_path: String,
  copy_params: TCopyParams,
}

impl MapDGetAllFilesInArchiveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetAllFilesInArchiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetAllFilesInArchiveArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetAllFilesInArchiveArgs.archive_path", &f_2)?;
    verify_required_field_exists("MapDGetAllFilesInArchiveArgs.copy_params", &f_3)?;
    let ret = MapDGetAllFilesInArchiveArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      archive_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_files_in_archive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("archive_path", TType::String, 2))?;
    o_prot.write_string(&self.archive_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetAllFilesInArchiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetAllFilesInArchiveResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetAllFilesInArchiveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetAllFilesInArchiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_65 = i_prot.read_string()?;
            val.push(list_elem_65);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetAllFilesInArchiveResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetAllFilesInArchiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetAllFilesInArchive"
          )
        )
      )
    }
  }
}

//
// MapDGetLayersInGeoFileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetLayersInGeoFileArgs {
  session: TSessionId,
  file_name: String,
  copy_params: TCopyParams,
}

impl MapDGetLayersInGeoFileArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetLayersInGeoFileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TCopyParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TCopyParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetLayersInGeoFileArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetLayersInGeoFileArgs.file_name", &f_2)?;
    verify_required_field_exists("MapDGetLayersInGeoFileArgs.copy_params", &f_3)?;
    let ret = MapDGetLayersInGeoFileArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      copy_params: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_layers_in_geo_file_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_name", TType::String, 2))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("copy_params", TType::Struct, 3))?;
    self.copy_params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetLayersInGeoFileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetLayersInGeoFileResult {
  result_value: Option<Vec<TGeoFileLayerInfo>>,
  e: Option<TMapDException>,
}

impl MapDGetLayersInGeoFileResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetLayersInGeoFileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TGeoFileLayerInfo>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TGeoFileLayerInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = TGeoFileLayerInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetLayersInGeoFileResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetLayersInGeoFileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TGeoFileLayerInfo>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetLayersInGeoFile"
          )
        )
      )
    }
  }
}

//
// MapDCheckTableConsistencyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCheckTableConsistencyArgs {
  session: TSessionId,
  table_id: i32,
}

impl MapDCheckTableConsistencyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCheckTableConsistencyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDCheckTableConsistencyArgs.session", &f_1)?;
    verify_required_field_exists("MapDCheckTableConsistencyArgs.table_id", &f_2)?;
    let ret = MapDCheckTableConsistencyArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("check_table_consistency_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 2))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDCheckTableConsistencyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCheckTableConsistencyResult {
  result_value: Option<TTableMeta>,
  e: Option<TMapDException>,
}

impl MapDCheckTableConsistencyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCheckTableConsistencyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TTableMeta> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TTableMeta::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDCheckTableConsistencyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDCheckTableConsistencyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TTableMeta> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDCheckTableConsistency"
          )
        )
      )
    }
  }
}

//
// MapDStartQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStartQueryArgs {
  session: TSessionId,
  query_ra: String,
  just_explain: bool,
}

impl MapDStartQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStartQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDStartQueryArgs.session", &f_1)?;
    verify_required_field_exists("MapDStartQueryArgs.query_ra", &f_2)?;
    verify_required_field_exists("MapDStartQueryArgs.just_explain", &f_3)?;
    let ret = MapDStartQueryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_ra: f_2.expect("auto-generated code should have checked for presence of required fields"),
      just_explain: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_ra", TType::String, 2))?;
    o_prot.write_string(&self.query_ra)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("just_explain", TType::Bool, 3))?;
    o_prot.write_bool(self.just_explain)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDStartQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStartQueryResult {
  result_value: Option<TPendingQuery>,
  e: Option<TMapDException>,
}

impl MapDStartQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStartQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPendingQuery> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPendingQuery::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDStartQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDStartQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPendingQuery> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDStartQuery"
          )
        )
      )
    }
  }
}

//
// MapDExecuteQueryStepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDExecuteQueryStepArgs {
  pending_query: TPendingQuery,
}

impl MapDExecuteQueryStepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDExecuteQueryStepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPendingQuery> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPendingQuery::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDExecuteQueryStepArgs.pending_query", &f_1)?;
    let ret = MapDExecuteQueryStepArgs {
      pending_query: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("execute_query_step_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pending_query", TType::Struct, 1))?;
    self.pending_query.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDExecuteQueryStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDExecuteQueryStepResult {
  result_value: Option<TStepResult>,
  e: Option<TMapDException>,
}

impl MapDExecuteQueryStepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDExecuteQueryStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TStepResult> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TStepResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDExecuteQueryStepResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDExecuteQueryStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TStepResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDExecuteQueryStep"
          )
        )
      )
    }
  }
}

//
// MapDBroadcastSerializedRowsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDBroadcastSerializedRowsArgs {
  serialized_rows: serialized_result_set::TSerializedRows,
  row_desc: TRowDescriptor,
  query_id: TQueryId,
}

impl MapDBroadcastSerializedRowsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDBroadcastSerializedRowsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<serialized_result_set::TSerializedRows> = None;
    let mut f_2: Option<TRowDescriptor> = None;
    let mut f_3: Option<TQueryId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = serialized_result_set::TSerializedRows::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDBroadcastSerializedRowsArgs.serialized_rows", &f_1)?;
    verify_required_field_exists("MapDBroadcastSerializedRowsArgs.row_desc", &f_2)?;
    verify_required_field_exists("MapDBroadcastSerializedRowsArgs.query_id", &f_3)?;
    let ret = MapDBroadcastSerializedRowsArgs {
      serialized_rows: f_1.expect("auto-generated code should have checked for presence of required fields"),
      row_desc: f_2.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("broadcast_serialized_rows_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialized_rows", TType::Struct, 1))?;
    self.serialized_rows.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_desc", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.row_desc.len() as i32))?;
    for e in &self.row_desc {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::I64, 3))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDBroadcastSerializedRowsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDBroadcastSerializedRowsResult {
  e: Option<TMapDException>,
}

impl MapDBroadcastSerializedRowsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDBroadcastSerializedRowsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDBroadcastSerializedRowsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDBroadcastSerializedRowsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDStartRenderQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStartRenderQueryArgs {
  session: TSessionId,
  widget_id: i64,
  node_idx: i16,
  vega_json: String,
}

impl MapDStartRenderQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStartRenderQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i16> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDStartRenderQueryArgs.session", &f_1)?;
    verify_required_field_exists("MapDStartRenderQueryArgs.widget_id", &f_2)?;
    verify_required_field_exists("MapDStartRenderQueryArgs.node_idx", &f_3)?;
    verify_required_field_exists("MapDStartRenderQueryArgs.vega_json", &f_4)?;
    let ret = MapDStartRenderQueryArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      widget_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      node_idx: f_3.expect("auto-generated code should have checked for presence of required fields"),
      vega_json: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("start_render_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("widget_id", TType::I64, 2))?;
    o_prot.write_i64(self.widget_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_idx", TType::I16, 3))?;
    o_prot.write_i16(self.node_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("vega_json", TType::String, 4))?;
    o_prot.write_string(&self.vega_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDStartRenderQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDStartRenderQueryResult {
  result_value: Option<TPendingRenderQuery>,
  e: Option<TMapDException>,
}

impl MapDStartRenderQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDStartRenderQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TPendingRenderQuery> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TPendingRenderQuery::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDStartRenderQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDStartRenderQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TPendingRenderQuery> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDStartRenderQuery"
          )
        )
      )
    }
  }
}

//
// MapDExecuteNextRenderStepArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDExecuteNextRenderStepArgs {
  pending_render: TPendingRenderQuery,
  merged_data: TRenderAggDataMap,
}

impl MapDExecuteNextRenderStepArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDExecuteNextRenderStepArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPendingRenderQuery> = None;
    let mut f_2: Option<TRenderAggDataMap> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPendingRenderQuery::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_68 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_69: BTreeMap<String, BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>>> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_70 = i_prot.read_string()?;
              let map_ident = i_prot.read_map_begin()?;
              let mut map_val_71: BTreeMap<String, BTreeMap<String, Vec<TRenderDatum>>> = BTreeMap::new();
              for _ in 0..map_ident.size {
                let map_key_72 = i_prot.read_string()?;
                let map_ident = i_prot.read_map_begin()?;
                let mut map_val_73: BTreeMap<String, Vec<TRenderDatum>> = BTreeMap::new();
                for _ in 0..map_ident.size {
                  let map_key_74 = i_prot.read_string()?;
                  let list_ident = i_prot.read_list_begin()?;
                  let mut map_val_75: Vec<TRenderDatum> = Vec::with_capacity(list_ident.size as usize);
                  for _ in 0..list_ident.size {
                    let list_elem_76 = TRenderDatum::read_from_in_protocol(i_prot)?;
                    map_val_75.push(list_elem_76);
                  }
                  i_prot.read_list_end()?;
                  map_val_73.insert(map_key_74, map_val_75);
                }
                i_prot.read_map_end()?;
                map_val_71.insert(map_key_72, map_val_73);
              }
              i_prot.read_map_end()?;
              map_val_69.insert(map_key_70, map_val_71);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_68, map_val_69);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDExecuteNextRenderStepArgs.pending_render", &f_1)?;
    verify_required_field_exists("MapDExecuteNextRenderStepArgs.merged_data", &f_2)?;
    let ret = MapDExecuteNextRenderStepArgs {
      pending_render: f_1.expect("auto-generated code should have checked for presence of required fields"),
      merged_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("execute_next_render_step_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pending_render", TType::Struct, 1))?;
    self.pending_render.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("merged_data", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, self.merged_data.len() as i32))?;
    for (k, v) in &self.merged_data {
      o_prot.write_string(k)?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
      for (k, v) in v {
        o_prot.write_string(k)?;
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, v.len() as i32))?;
        for (k, v) in v {
          o_prot.write_string(k)?;
          o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, v.len() as i32))?;
          for (k, v) in v {
            o_prot.write_string(k)?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
            for e in v {
              e.write_to_out_protocol(o_prot)?;
              o_prot.write_list_end()?;
            }
            o_prot.write_map_end()?;
          }
          o_prot.write_map_end()?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDExecuteNextRenderStepResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDExecuteNextRenderStepResult {
  result_value: Option<TRenderStepResult>,
  e: Option<TMapDException>,
}

impl MapDExecuteNextRenderStepResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDExecuteNextRenderStepResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TRenderStepResult> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TRenderStepResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDExecuteNextRenderStepResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDExecuteNextRenderStepResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TRenderStepResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDExecuteNextRenderStep"
          )
        )
      )
    }
  }
}

//
// MapDInsertDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDInsertDataArgs {
  session: TSessionId,
  insert_data: TInsertData,
}

impl MapDInsertDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDInsertDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<TInsertData> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TInsertData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDInsertDataArgs.session", &f_1)?;
    verify_required_field_exists("MapDInsertDataArgs.insert_data", &f_2)?;
    let ret = MapDInsertDataArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      insert_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insert_data_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("insert_data", TType::Struct, 2))?;
    self.insert_data.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDInsertDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDInsertDataResult {
  e: Option<TMapDException>,
}

impl MapDInsertDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDInsertDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDInsertDataResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDInsertDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDCheckpointArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCheckpointArgs {
  session: TSessionId,
  db_id: i32,
  table_id: i32,
}

impl MapDCheckpointArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCheckpointArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDCheckpointArgs.session", &f_1)?;
    verify_required_field_exists("MapDCheckpointArgs.db_id", &f_2)?;
    verify_required_field_exists("MapDCheckpointArgs.table_id", &f_3)?;
    let ret = MapDCheckpointArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkpoint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I32, 2))?;
    o_prot.write_i32(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I32, 3))?;
    o_prot.write_i32(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDCheckpointResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDCheckpointResult {
  e: Option<TMapDException>,
}

impl MapDCheckpointResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDCheckpointResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDCheckpointResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDCheckpointResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// MapDGetRolesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetRolesArgs {
  session: TSessionId,
}

impl MapDGetRolesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetRolesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetRolesArgs.session", &f_1)?;
    let ret = MapDGetRolesArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_roles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetRolesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetRolesResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetRolesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetRolesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_77 = i_prot.read_string()?;
            val.push(list_elem_77);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetRolesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetRolesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetRoles"
          )
        )
      )
    }
  }
}

//
// MapDGetDbObjectsForGranteeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDbObjectsForGranteeArgs {
  session: TSessionId,
  role_name: String,
}

impl MapDGetDbObjectsForGranteeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDbObjectsForGranteeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDbObjectsForGranteeArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetDbObjectsForGranteeArgs.role_name", &f_2)?;
    let ret = MapDGetDbObjectsForGranteeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      role_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_db_objects_for_grantee_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 2))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDbObjectsForGranteeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDbObjectsForGranteeResult {
  result_value: Option<Vec<TDBObject>>,
  e: Option<TMapDException>,
}

impl MapDGetDbObjectsForGranteeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDbObjectsForGranteeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBObject>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBObject> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_78 = TDBObject::read_from_in_protocol(i_prot)?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDbObjectsForGranteeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDbObjectsForGranteeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBObject>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDbObjectsForGrantee"
          )
        )
      )
    }
  }
}

//
// MapDGetDbObjectPrivsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDbObjectPrivsArgs {
  session: TSessionId,
  object_name: String,
  type_: TDBObjectType,
}

impl MapDGetDbObjectPrivsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDbObjectPrivsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TDBObjectType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDbObjectPrivsArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetDbObjectPrivsArgs.object_name", &f_2)?;
    verify_required_field_exists("MapDGetDbObjectPrivsArgs.type_", &f_3)?;
    let ret = MapDGetDbObjectPrivsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      object_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_db_object_privs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 2))?;
    o_prot.write_string(&self.object_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDbObjectPrivsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDbObjectPrivsResult {
  result_value: Option<Vec<TDBObject>>,
  e: Option<TMapDException>,
}

impl MapDGetDbObjectPrivsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDbObjectPrivsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TDBObject>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDBObject> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_79 = TDBObject::read_from_in_protocol(i_prot)?;
            val.push(list_elem_79);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDbObjectPrivsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDbObjectPrivsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TDBObject>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDbObjectPrivs"
          )
        )
      )
    }
  }
}

//
// MapDGetAllRolesForUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetAllRolesForUserArgs {
  session: TSessionId,
  user_name: String,
}

impl MapDGetAllRolesForUserArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetAllRolesForUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetAllRolesForUserArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetAllRolesForUserArgs.user_name", &f_2)?;
    let ret = MapDGetAllRolesForUserArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_roles_for_user_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 2))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetAllRolesForUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetAllRolesForUserResult {
  result_value: Option<Vec<String>>,
  e: Option<TMapDException>,
}

impl MapDGetAllRolesForUserResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetAllRolesForUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_80 = i_prot.read_string()?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetAllRolesForUserResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetAllRolesForUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetAllRolesForUser"
          )
        )
      )
    }
  }
}

//
// MapDHasRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDHasRoleArgs {
  session: TSessionId,
  grantee_name: String,
  role_name: String,
}

impl MapDHasRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDHasRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDHasRoleArgs.session", &f_1)?;
    verify_required_field_exists("MapDHasRoleArgs.grantee_name", &f_2)?;
    verify_required_field_exists("MapDHasRoleArgs.role_name", &f_3)?;
    let ret = MapDHasRoleArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      grantee_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("granteeName", TType::String, 2))?;
    o_prot.write_string(&self.grantee_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 3))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDHasRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDHasRoleResult {
  result_value: Option<bool>,
  e: Option<TMapDException>,
}

impl MapDHasRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDHasRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDHasRoleResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDHasRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDHasRole"
          )
        )
      )
    }
  }
}

//
// MapDHasObjectPrivilegeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDHasObjectPrivilegeArgs {
  session: TSessionId,
  grantee_name: String,
  object_name: String,
  object_type: TDBObjectType,
  permissions: TDBObjectPermissions,
}

impl MapDHasObjectPrivilegeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDHasObjectPrivilegeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<TDBObjectType> = None;
    let mut f_5: Option<TDBObjectPermissions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TDBObjectType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TDBObjectPermissions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDHasObjectPrivilegeArgs.session", &f_1)?;
    verify_required_field_exists("MapDHasObjectPrivilegeArgs.grantee_name", &f_2)?;
    verify_required_field_exists("MapDHasObjectPrivilegeArgs.object_name", &f_3)?;
    verify_required_field_exists("MapDHasObjectPrivilegeArgs.object_type", &f_4)?;
    verify_required_field_exists("MapDHasObjectPrivilegeArgs.permissions", &f_5)?;
    let ret = MapDHasObjectPrivilegeArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      grantee_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      object_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      object_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_object_privilege_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("granteeName", TType::String, 2))?;
    o_prot.write_string(&self.grantee_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ObjectName", TType::String, 3))?;
    o_prot.write_string(&self.object_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 4))?;
    self.object_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::Struct, 5))?;
    self.permissions.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDHasObjectPrivilegeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDHasObjectPrivilegeResult {
  result_value: Option<bool>,
  e: Option<TMapDException>,
}

impl MapDHasObjectPrivilegeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDHasObjectPrivilegeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDHasObjectPrivilegeResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDHasObjectPrivilegeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDHasObjectPrivilege"
          )
        )
      )
    }
  }
}

//
// MapDSetLicenseKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetLicenseKeyArgs {
  session: TSessionId,
  key: String,
  nonce: String,
}

impl MapDSetLicenseKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetLicenseKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDSetLicenseKeyArgs.session", &f_1)?;
    verify_required_field_exists("MapDSetLicenseKeyArgs.key", &f_2)?;
    verify_required_field_exists("MapDSetLicenseKeyArgs.nonce", &f_3)?;
    let ret = MapDSetLicenseKeyArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_license_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 3))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDSetLicenseKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDSetLicenseKeyResult {
  result_value: Option<TLicenseInfo>,
  e: Option<TMapDException>,
}

impl MapDSetLicenseKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDSetLicenseKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TLicenseInfo> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TLicenseInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDSetLicenseKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDSetLicenseKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TLicenseInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDSetLicenseKey"
          )
        )
      )
    }
  }
}

//
// MapDGetLicenseClaimsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetLicenseClaimsArgs {
  session: TSessionId,
  nonce: String,
}

impl MapDGetLicenseClaimsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetLicenseClaimsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetLicenseClaimsArgs.session", &f_1)?;
    verify_required_field_exists("MapDGetLicenseClaimsArgs.nonce", &f_2)?;
    let ret = MapDGetLicenseClaimsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nonce: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_license_claims_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nonce", TType::String, 2))?;
    o_prot.write_string(&self.nonce)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetLicenseClaimsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetLicenseClaimsResult {
  result_value: Option<TLicenseInfo>,
  e: Option<TMapDException>,
}

impl MapDGetLicenseClaimsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetLicenseClaimsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TLicenseInfo> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TLicenseInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetLicenseClaimsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetLicenseClaimsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TLicenseInfo> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetLicenseClaims"
          )
        )
      )
    }
  }
}

//
// MapDGetDeviceParametersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDeviceParametersArgs {
  session: TSessionId,
}

impl MapDGetDeviceParametersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDeviceParametersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDGetDeviceParametersArgs.session", &f_1)?;
    let ret = MapDGetDeviceParametersArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_device_parameters_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDGetDeviceParametersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDGetDeviceParametersResult {
  result_value: Option<BTreeMap<String, String>>,
  e: Option<TMapDException>,
}

impl MapDGetDeviceParametersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDGetDeviceParametersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_81 = i_prot.read_string()?;
            let map_val_82 = i_prot.read_string()?;
            val.insert(map_key_81, map_val_82);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDGetDeviceParametersResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDGetDeviceParametersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for MapDGetDeviceParameters"
          )
        )
      )
    }
  }
}

//
// MapDRegisterRuntimeExtensionFunctionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDRegisterRuntimeExtensionFunctionsArgs {
  session: TSessionId,
  udfs: Vec<extension_functions::TUserDefinedFunction>,
  udtfs: Vec<extension_functions::TUserDefinedTableFunction>,
  device_ir_map: BTreeMap<String, String>,
}

impl MapDRegisterRuntimeExtensionFunctionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDRegisterRuntimeExtensionFunctionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSessionId> = None;
    let mut f_2: Option<Vec<extension_functions::TUserDefinedFunction>> = None;
    let mut f_3: Option<Vec<extension_functions::TUserDefinedTableFunction>> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = extension_functions::TUserDefinedFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<extension_functions::TUserDefinedTableFunction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = extension_functions::TUserDefinedTableFunction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_85 = i_prot.read_string()?;
            let map_val_86 = i_prot.read_string()?;
            val.insert(map_key_85, map_val_86);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MapDRegisterRuntimeExtensionFunctionsArgs.session", &f_1)?;
    verify_required_field_exists("MapDRegisterRuntimeExtensionFunctionsArgs.udfs", &f_2)?;
    verify_required_field_exists("MapDRegisterRuntimeExtensionFunctionsArgs.udtfs", &f_3)?;
    verify_required_field_exists("MapDRegisterRuntimeExtensionFunctionsArgs.device_ir_map", &f_4)?;
    let ret = MapDRegisterRuntimeExtensionFunctionsArgs {
      session: f_1.expect("auto-generated code should have checked for presence of required fields"),
      udfs: f_2.expect("auto-generated code should have checked for presence of required fields"),
      udtfs: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_ir_map: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("register_runtime_extension_functions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("session", TType::String, 1))?;
    o_prot.write_string(&self.session)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udfs", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.udfs.len() as i32))?;
    for e in &self.udfs {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("udtfs", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.udtfs.len() as i32))?;
    for e in &self.udtfs {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("device_ir_map", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.device_ir_map.len() as i32))?;
    for (k, v) in &self.device_ir_map {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MapDRegisterRuntimeExtensionFunctionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct MapDRegisterRuntimeExtensionFunctionsResult {
  e: Option<TMapDException>,
}

impl MapDRegisterRuntimeExtensionFunctionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapDRegisterRuntimeExtensionFunctionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TMapDException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TMapDException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapDRegisterRuntimeExtensionFunctionsResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapDRegisterRuntimeExtensionFunctionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}
