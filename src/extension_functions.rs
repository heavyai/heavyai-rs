// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExtArgumentType(pub i32);

impl TExtArgumentType {
  pub const INT8: TExtArgumentType = TExtArgumentType(0);
  pub const INT16: TExtArgumentType = TExtArgumentType(1);
  pub const INT32: TExtArgumentType = TExtArgumentType(2);
  pub const INT64: TExtArgumentType = TExtArgumentType(3);
  pub const FLOAT: TExtArgumentType = TExtArgumentType(4);
  pub const DOUBLE: TExtArgumentType = TExtArgumentType(5);
  pub const VOID: TExtArgumentType = TExtArgumentType(6);
  pub const P_INT8: TExtArgumentType = TExtArgumentType(7);
  pub const P_INT16: TExtArgumentType = TExtArgumentType(8);
  pub const P_INT32: TExtArgumentType = TExtArgumentType(9);
  pub const P_INT64: TExtArgumentType = TExtArgumentType(10);
  pub const P_FLOAT: TExtArgumentType = TExtArgumentType(11);
  pub const P_DOUBLE: TExtArgumentType = TExtArgumentType(12);
  pub const P_BOOL: TExtArgumentType = TExtArgumentType(13);
  pub const BOOL: TExtArgumentType = TExtArgumentType(14);
  pub const ARRAY_INT8: TExtArgumentType = TExtArgumentType(15);
  pub const ARRAY_INT16: TExtArgumentType = TExtArgumentType(16);
  pub const ARRAY_INT32: TExtArgumentType = TExtArgumentType(17);
  pub const ARRAY_INT64: TExtArgumentType = TExtArgumentType(18);
  pub const ARRAY_FLOAT: TExtArgumentType = TExtArgumentType(19);
  pub const ARRAY_DOUBLE: TExtArgumentType = TExtArgumentType(20);
  pub const ARRAY_BOOL: TExtArgumentType = TExtArgumentType(21);
  pub const GEO_POINT: TExtArgumentType = TExtArgumentType(22);
  pub const GEO_LINE_STRING: TExtArgumentType = TExtArgumentType(23);
  pub const CURSOR: TExtArgumentType = TExtArgumentType(24);
  pub const GEO_POLYGON: TExtArgumentType = TExtArgumentType(25);
  pub const GEO_MULTI_POLYGON: TExtArgumentType = TExtArgumentType(26);
  pub const COLUMN_INT8: TExtArgumentType = TExtArgumentType(27);
  pub const COLUMN_INT16: TExtArgumentType = TExtArgumentType(28);
  pub const COLUMN_INT32: TExtArgumentType = TExtArgumentType(29);
  pub const COLUMN_INT64: TExtArgumentType = TExtArgumentType(30);
  pub const COLUMN_FLOAT: TExtArgumentType = TExtArgumentType(31);
  pub const COLUMN_DOUBLE: TExtArgumentType = TExtArgumentType(32);
  pub const COLUMN_BOOL: TExtArgumentType = TExtArgumentType(33);
  pub const TEXT_ENCODING_NONE: TExtArgumentType = TExtArgumentType(34);
  pub const TEXT_ENCODING_DICT: TExtArgumentType = TExtArgumentType(35);
  pub const COLUMN_LIST_INT8: TExtArgumentType = TExtArgumentType(36);
  pub const COLUMN_LIST_INT16: TExtArgumentType = TExtArgumentType(37);
  pub const COLUMN_LIST_INT32: TExtArgumentType = TExtArgumentType(38);
  pub const COLUMN_LIST_INT64: TExtArgumentType = TExtArgumentType(39);
  pub const COLUMN_LIST_FLOAT: TExtArgumentType = TExtArgumentType(40);
  pub const COLUMN_LIST_DOUBLE: TExtArgumentType = TExtArgumentType(41);
  pub const COLUMN_LIST_BOOL: TExtArgumentType = TExtArgumentType(42);
  pub const COLUMN_TEXT_ENCODING_DICT: TExtArgumentType = TExtArgumentType(43);
  pub const COLUMN_LIST_TEXT_ENCODING_DICT: TExtArgumentType = TExtArgumentType(44);
  pub const COLUMN_TIMESTAMP: TExtArgumentType = TExtArgumentType(45);
  pub const TIMESTAMP: TExtArgumentType = TExtArgumentType(46);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INT8,
    Self::INT16,
    Self::INT32,
    Self::INT64,
    Self::FLOAT,
    Self::DOUBLE,
    Self::VOID,
    Self::P_INT8,
    Self::P_INT16,
    Self::P_INT32,
    Self::P_INT64,
    Self::P_FLOAT,
    Self::P_DOUBLE,
    Self::P_BOOL,
    Self::BOOL,
    Self::ARRAY_INT8,
    Self::ARRAY_INT16,
    Self::ARRAY_INT32,
    Self::ARRAY_INT64,
    Self::ARRAY_FLOAT,
    Self::ARRAY_DOUBLE,
    Self::ARRAY_BOOL,
    Self::GEO_POINT,
    Self::GEO_LINE_STRING,
    Self::CURSOR,
    Self::GEO_POLYGON,
    Self::GEO_MULTI_POLYGON,
    Self::COLUMN_INT8,
    Self::COLUMN_INT16,
    Self::COLUMN_INT32,
    Self::COLUMN_INT64,
    Self::COLUMN_FLOAT,
    Self::COLUMN_DOUBLE,
    Self::COLUMN_BOOL,
    Self::TEXT_ENCODING_NONE,
    Self::TEXT_ENCODING_DICT,
    Self::COLUMN_LIST_INT8,
    Self::COLUMN_LIST_INT16,
    Self::COLUMN_LIST_INT32,
    Self::COLUMN_LIST_INT64,
    Self::COLUMN_LIST_FLOAT,
    Self::COLUMN_LIST_DOUBLE,
    Self::COLUMN_LIST_BOOL,
    Self::COLUMN_TEXT_ENCODING_DICT,
    Self::COLUMN_LIST_TEXT_ENCODING_DICT,
    Self::COLUMN_TIMESTAMP,
    Self::TIMESTAMP,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExtArgumentType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TExtArgumentType::from(enum_value))
  }
}

impl From<i32> for TExtArgumentType {
  fn from(i: i32) -> Self {
    match i {
      0 => TExtArgumentType::INT8,
      1 => TExtArgumentType::INT16,
      2 => TExtArgumentType::INT32,
      3 => TExtArgumentType::INT64,
      4 => TExtArgumentType::FLOAT,
      5 => TExtArgumentType::DOUBLE,
      6 => TExtArgumentType::VOID,
      7 => TExtArgumentType::P_INT8,
      8 => TExtArgumentType::P_INT16,
      9 => TExtArgumentType::P_INT32,
      10 => TExtArgumentType::P_INT64,
      11 => TExtArgumentType::P_FLOAT,
      12 => TExtArgumentType::P_DOUBLE,
      13 => TExtArgumentType::P_BOOL,
      14 => TExtArgumentType::BOOL,
      15 => TExtArgumentType::ARRAY_INT8,
      16 => TExtArgumentType::ARRAY_INT16,
      17 => TExtArgumentType::ARRAY_INT32,
      18 => TExtArgumentType::ARRAY_INT64,
      19 => TExtArgumentType::ARRAY_FLOAT,
      20 => TExtArgumentType::ARRAY_DOUBLE,
      21 => TExtArgumentType::ARRAY_BOOL,
      22 => TExtArgumentType::GEO_POINT,
      23 => TExtArgumentType::GEO_LINE_STRING,
      24 => TExtArgumentType::CURSOR,
      25 => TExtArgumentType::GEO_POLYGON,
      26 => TExtArgumentType::GEO_MULTI_POLYGON,
      27 => TExtArgumentType::COLUMN_INT8,
      28 => TExtArgumentType::COLUMN_INT16,
      29 => TExtArgumentType::COLUMN_INT32,
      30 => TExtArgumentType::COLUMN_INT64,
      31 => TExtArgumentType::COLUMN_FLOAT,
      32 => TExtArgumentType::COLUMN_DOUBLE,
      33 => TExtArgumentType::COLUMN_BOOL,
      34 => TExtArgumentType::TEXT_ENCODING_NONE,
      35 => TExtArgumentType::TEXT_ENCODING_DICT,
      36 => TExtArgumentType::COLUMN_LIST_INT8,
      37 => TExtArgumentType::COLUMN_LIST_INT16,
      38 => TExtArgumentType::COLUMN_LIST_INT32,
      39 => TExtArgumentType::COLUMN_LIST_INT64,
      40 => TExtArgumentType::COLUMN_LIST_FLOAT,
      41 => TExtArgumentType::COLUMN_LIST_DOUBLE,
      42 => TExtArgumentType::COLUMN_LIST_BOOL,
      43 => TExtArgumentType::COLUMN_TEXT_ENCODING_DICT,
      44 => TExtArgumentType::COLUMN_LIST_TEXT_ENCODING_DICT,
      45 => TExtArgumentType::COLUMN_TIMESTAMP,
      46 => TExtArgumentType::TIMESTAMP,
      _ => TExtArgumentType(i)
    }
  }
}

impl From<&i32> for TExtArgumentType {
  fn from(i: &i32) -> Self {
    TExtArgumentType::from(*i)
  }
}

impl From<TExtArgumentType> for i32 {
  fn from(e: TExtArgumentType) -> i32 {
    e.0
  }
}

impl From<&TExtArgumentType> for i32 {
  fn from(e: &TExtArgumentType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOutputBufferSizeType(pub i32);

impl TOutputBufferSizeType {
  pub const K_CONSTANT: TOutputBufferSizeType = TOutputBufferSizeType(0);
  pub const K_USER_SPECIFIED_CONSTANT_PARAMETER: TOutputBufferSizeType = TOutputBufferSizeType(1);
  pub const K_USER_SPECIFIED_ROW_MULTIPLIER: TOutputBufferSizeType = TOutputBufferSizeType(2);
  pub const K_TABLE_FUNCTION_SPECIFIED_PARAMETER: TOutputBufferSizeType = TOutputBufferSizeType(3);
  pub const K_PRE_FLIGHT_PARAMETER: TOutputBufferSizeType = TOutputBufferSizeType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::K_CONSTANT,
    Self::K_USER_SPECIFIED_CONSTANT_PARAMETER,
    Self::K_USER_SPECIFIED_ROW_MULTIPLIER,
    Self::K_TABLE_FUNCTION_SPECIFIED_PARAMETER,
    Self::K_PRE_FLIGHT_PARAMETER,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOutputBufferSizeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TOutputBufferSizeType::from(enum_value))
  }
}

impl From<i32> for TOutputBufferSizeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TOutputBufferSizeType::K_CONSTANT,
      1 => TOutputBufferSizeType::K_USER_SPECIFIED_CONSTANT_PARAMETER,
      2 => TOutputBufferSizeType::K_USER_SPECIFIED_ROW_MULTIPLIER,
      3 => TOutputBufferSizeType::K_TABLE_FUNCTION_SPECIFIED_PARAMETER,
      4 => TOutputBufferSizeType::K_PRE_FLIGHT_PARAMETER,
      _ => TOutputBufferSizeType(i)
    }
  }
}

impl From<&i32> for TOutputBufferSizeType {
  fn from(i: &i32) -> Self {
    TOutputBufferSizeType::from(*i)
  }
}

impl From<TOutputBufferSizeType> for i32 {
  fn from(e: TOutputBufferSizeType) -> i32 {
    e.0
  }
}

impl From<&TOutputBufferSizeType> for i32 {
  fn from(e: &TOutputBufferSizeType) -> i32 {
    e.0
  }
}

//
// TUserDefinedFunction
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUserDefinedFunction {
  pub name: Option<String>,
  pub arg_types: Option<Vec<TExtArgumentType>>,
  pub ret_type: Option<TExtArgumentType>,
}

impl TUserDefinedFunction {
  pub fn new<F1, F2, F3>(name: F1, arg_types: F2, ret_type: F3) -> TUserDefinedFunction where F1: Into<Option<String>>, F2: Into<Option<Vec<TExtArgumentType>>>, F3: Into<Option<TExtArgumentType>> {
    TUserDefinedFunction {
      name: name.into(),
      arg_types: arg_types.into(),
      ret_type: ret_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUserDefinedFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<TExtArgumentType>> = Some(Vec::new());
    let mut f_3: Option<TExtArgumentType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TExtArgumentType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = TExtArgumentType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TExtArgumentType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TUserDefinedFunction {
      name: f_1,
      arg_types: f_2,
      ret_type: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUserDefinedFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.arg_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("argTypes", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ret_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("retType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TUserDefinedFunction {
  fn default() -> Self {
    TUserDefinedFunction{
      name: Some("".to_owned()),
      arg_types: Some(Vec::new()),
      ret_type: None,
    }
  }
}

//
// TUserDefinedTableFunction
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUserDefinedTableFunction {
  pub name: Option<String>,
  pub sizer_type: Option<TOutputBufferSizeType>,
  pub sizer_arg_pos: Option<i32>,
  pub input_arg_types: Option<Vec<TExtArgumentType>>,
  pub output_arg_types: Option<Vec<TExtArgumentType>>,
  pub sql_arg_types: Option<Vec<TExtArgumentType>>,
  pub annotations: Option<Vec<BTreeMap<String, String>>>,
}

impl TUserDefinedTableFunction {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(name: F1, sizer_type: F2, sizer_arg_pos: F3, input_arg_types: F4, output_arg_types: F5, sql_arg_types: F6, annotations: F7) -> TUserDefinedTableFunction where F1: Into<Option<String>>, F2: Into<Option<TOutputBufferSizeType>>, F3: Into<Option<i32>>, F4: Into<Option<Vec<TExtArgumentType>>>, F5: Into<Option<Vec<TExtArgumentType>>>, F6: Into<Option<Vec<TExtArgumentType>>>, F7: Into<Option<Vec<BTreeMap<String, String>>>> {
    TUserDefinedTableFunction {
      name: name.into(),
      sizer_type: sizer_type.into(),
      sizer_arg_pos: sizer_arg_pos.into(),
      input_arg_types: input_arg_types.into(),
      output_arg_types: output_arg_types.into(),
      sql_arg_types: sql_arg_types.into(),
      annotations: annotations.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUserDefinedTableFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<TOutputBufferSizeType> = None;
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<Vec<TExtArgumentType>> = Some(Vec::new());
    let mut f_5: Option<Vec<TExtArgumentType>> = Some(Vec::new());
    let mut f_6: Option<Vec<TExtArgumentType>> = Some(Vec::new());
    let mut f_7: Option<Vec<BTreeMap<String, String>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TOutputBufferSizeType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TExtArgumentType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = TExtArgumentType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TExtArgumentType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = TExtArgumentType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TExtArgumentType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = TExtArgumentType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_4: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_5 = i_prot.read_string()?;
              let map_val_6 = i_prot.read_string()?;
              list_elem_4.insert(map_key_5, map_val_6);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TUserDefinedTableFunction {
      name: f_1,
      sizer_type: f_2,
      sizer_arg_pos: f_3,
      input_arg_types: f_4,
      output_arg_types: f_5,
      sql_arg_types: f_6,
      annotations: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUserDefinedTableFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sizer_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("sizerType", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sizer_arg_pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("sizerArgPos", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input_arg_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("inputArgTypes", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.output_arg_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("outputArgTypes", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sql_arg_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("sqlArgTypes", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.annotations {
      o_prot.write_field_begin(&TFieldIdentifier::new("annotations", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TUserDefinedTableFunction {
  fn default() -> Self {
    TUserDefinedTableFunction{
      name: Some("".to_owned()),
      sizer_type: None,
      sizer_arg_pos: Some(0),
      input_arg_types: Some(Vec::new()),
      output_arg_types: Some(Vec::new()),
      sql_arg_types: Some(Vec::new()),
      annotations: Some(Vec::new()),
    }
  }
}
