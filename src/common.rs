// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDeviceType(pub i32);

impl TDeviceType {
  pub const CPU: TDeviceType = TDeviceType(0);
  pub const GPU: TDeviceType = TDeviceType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CPU,
    Self::GPU,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDeviceType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TDeviceType::from(enum_value))
  }
}

impl From<i32> for TDeviceType {
  fn from(i: i32) -> Self {
    match i {
      0 => TDeviceType::CPU,
      1 => TDeviceType::GPU,
      _ => TDeviceType(i)
    }
  }
}

impl From<&i32> for TDeviceType {
  fn from(i: &i32) -> Self {
    TDeviceType::from(*i)
  }
}

impl From<TDeviceType> for i32 {
  fn from(e: TDeviceType) -> i32 {
    e.0
  }
}

impl From<&TDeviceType> for i32 {
  fn from(e: &TDeviceType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDatumType(pub i32);

impl TDatumType {
  pub const SMALLINT: TDatumType = TDatumType(0);
  pub const INT: TDatumType = TDatumType(1);
  pub const BIGINT: TDatumType = TDatumType(2);
  pub const FLOAT: TDatumType = TDatumType(3);
  pub const DECIMAL: TDatumType = TDatumType(4);
  pub const DOUBLE: TDatumType = TDatumType(5);
  pub const STR: TDatumType = TDatumType(6);
  pub const TIME: TDatumType = TDatumType(7);
  pub const TIMESTAMP: TDatumType = TDatumType(8);
  pub const DATE: TDatumType = TDatumType(9);
  pub const BOOL: TDatumType = TDatumType(10);
  pub const INTERVAL_DAY_TIME: TDatumType = TDatumType(11);
  pub const INTERVAL_YEAR_MONTH: TDatumType = TDatumType(12);
  pub const POINT: TDatumType = TDatumType(13);
  pub const LINESTRING: TDatumType = TDatumType(14);
  pub const POLYGON: TDatumType = TDatumType(15);
  pub const MULTIPOLYGON: TDatumType = TDatumType(16);
  pub const TINYINT: TDatumType = TDatumType(17);
  pub const GEOMETRY: TDatumType = TDatumType(18);
  pub const GEOGRAPHY: TDatumType = TDatumType(19);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SMALLINT,
    Self::INT,
    Self::BIGINT,
    Self::FLOAT,
    Self::DECIMAL,
    Self::DOUBLE,
    Self::STR,
    Self::TIME,
    Self::TIMESTAMP,
    Self::DATE,
    Self::BOOL,
    Self::INTERVAL_DAY_TIME,
    Self::INTERVAL_YEAR_MONTH,
    Self::POINT,
    Self::LINESTRING,
    Self::POLYGON,
    Self::MULTIPOLYGON,
    Self::TINYINT,
    Self::GEOMETRY,
    Self::GEOGRAPHY,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDatumType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TDatumType::from(enum_value))
  }
}

impl From<i32> for TDatumType {
  fn from(i: i32) -> Self {
    match i {
      0 => TDatumType::SMALLINT,
      1 => TDatumType::INT,
      2 => TDatumType::BIGINT,
      3 => TDatumType::FLOAT,
      4 => TDatumType::DECIMAL,
      5 => TDatumType::DOUBLE,
      6 => TDatumType::STR,
      7 => TDatumType::TIME,
      8 => TDatumType::TIMESTAMP,
      9 => TDatumType::DATE,
      10 => TDatumType::BOOL,
      11 => TDatumType::INTERVAL_DAY_TIME,
      12 => TDatumType::INTERVAL_YEAR_MONTH,
      13 => TDatumType::POINT,
      14 => TDatumType::LINESTRING,
      15 => TDatumType::POLYGON,
      16 => TDatumType::MULTIPOLYGON,
      17 => TDatumType::TINYINT,
      18 => TDatumType::GEOMETRY,
      19 => TDatumType::GEOGRAPHY,
      _ => TDatumType(i)
    }
  }
}

impl From<&i32> for TDatumType {
  fn from(i: &i32) -> Self {
    TDatumType::from(*i)
  }
}

impl From<TDatumType> for i32 {
  fn from(e: TDatumType) -> i32 {
    e.0
  }
}

impl From<&TDatumType> for i32 {
  fn from(e: &TDatumType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEncodingType(pub i32);

impl TEncodingType {
  pub const NONE: TEncodingType = TEncodingType(0);
  pub const FIXED: TEncodingType = TEncodingType(1);
  pub const RL: TEncodingType = TEncodingType(2);
  pub const DIFF: TEncodingType = TEncodingType(3);
  pub const DICT: TEncodingType = TEncodingType(4);
  pub const SPARSE: TEncodingType = TEncodingType(5);
  pub const GEOINT: TEncodingType = TEncodingType(6);
  pub const DATE_IN_DAYS: TEncodingType = TEncodingType(7);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::FIXED,
    Self::RL,
    Self::DIFF,
    Self::DICT,
    Self::SPARSE,
    Self::GEOINT,
    Self::DATE_IN_DAYS,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEncodingType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TEncodingType::from(enum_value))
  }
}

impl From<i32> for TEncodingType {
  fn from(i: i32) -> Self {
    match i {
      0 => TEncodingType::NONE,
      1 => TEncodingType::FIXED,
      2 => TEncodingType::RL,
      3 => TEncodingType::DIFF,
      4 => TEncodingType::DICT,
      5 => TEncodingType::SPARSE,
      6 => TEncodingType::GEOINT,
      7 => TEncodingType::DATE_IN_DAYS,
      _ => TEncodingType(i)
    }
  }
}

impl From<&i32> for TEncodingType {
  fn from(i: &i32) -> Self {
    TEncodingType::from(*i)
  }
}

impl From<TEncodingType> for i32 {
  fn from(e: TEncodingType) -> i32 {
    e.0
  }
}

impl From<&TEncodingType> for i32 {
  fn from(e: &TEncodingType) -> i32 {
    e.0
  }
}

//
// TTypeInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTypeInfo {
  pub type_: Option<TDatumType>,
  pub nullable: Option<bool>,
  pub is_array: Option<bool>,
  pub encoding: Option<TEncodingType>,
  pub precision: Option<i32>,
  pub scale: Option<i32>,
  pub comp_param: Option<i32>,
  pub size: Option<i32>,
}

impl TTypeInfo {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(type_: F1, nullable: F2, is_array: F3, encoding: F4, precision: F5, scale: F6, comp_param: F7, size: F8) -> TTypeInfo where F1: Into<Option<TDatumType>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<TEncodingType>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<i32>>, F8: Into<Option<i32>> {
    TTypeInfo {
      type_: type_.into(),
      nullable: nullable.into(),
      is_array: is_array.into(),
      encoding: encoding.into(),
      precision: precision.into(),
      scale: scale.into(),
      comp_param: comp_param.into(),
      size: size.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDatumType> = None;
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<TEncodingType> = None;
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<i32> = Some(0);
    let mut f_8: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDatumType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TEncodingType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTypeInfo {
      type_: f_1,
      nullable: f_2,
      is_array: f_3,
      encoding: f_4,
      precision: f_5,
      scale: f_6,
      comp_param: f_7,
      size: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("nullable", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_array {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_array", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.encoding {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.precision {
      o_prot.write_field_begin(&TFieldIdentifier::new("precision", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.comp_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp_param", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TTypeInfo {
  fn default() -> Self {
    TTypeInfo{
      type_: None,
      nullable: Some(false),
      is_array: Some(false),
      encoding: None,
      precision: Some(0),
      scale: Some(0),
      comp_param: Some(0),
      size: Some(0),
    }
  }
}
